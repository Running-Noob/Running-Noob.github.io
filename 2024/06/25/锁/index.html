<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="synchronized wait-notify park-unpark ReentrantLock"><meta property="og:type" content="article"><meta property="og:title" content="锁"><meta property="og:url" content="https://running-noob.github.io/2024/06/25/%E9%94%81/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="synchronized wait-notify park-unpark ReentrantLock"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%87%AA%E6%97%8B%E6%88%90%E5%8A%9F.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%861.png"><meta property="og:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%862.png"><meta property="og:image" content="https://running-noob.github.io/Running%20Noob/%E8%AE%A1%E7%AE%97%E6%9C%BA/Typora%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-git%E4%BB%93%E5%BA%93/Juc-notebook/img/4/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"><meta property="article:published_time" content="2024-06-25T14:14:36.000Z"><meta property="article:modified_time" content="2024-06-25T14:17:17.359Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"><link rel="canonical" href="https://running-noob.github.io/2024/06/25/%E9%94%81/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>锁 | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">243</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/06/25/%E9%94%81/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">锁</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-06-25 22:14:36 / 修改时间：22:17:17" itemprop="dateCreated datePublished" datetime="2024-06-25T22:14:36+08:00">2024-06-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>synchronized</li><li>wait-notify</li><li>park-unpark</li><li>ReentrantLock</li></ul></blockquote><span id="more"></span><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="★synchronized"><a href="#★synchronized" class="headerlink" title="★synchronized"></a>★synchronized</h3><ul><li><p>**在成员方法上加锁等于锁住当前对象 <code>this</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) {</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>**在静态方法上加锁等于锁住类对象 <code>clazz</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) {</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="Monitor（重量级锁）"><a href="#Monitor（重量级锁）" class="headerlink" title="Monitor（重量级锁）"></a>Monitor（重量级锁）</h4><ul><li><p>Monitor 被翻译为监视器或管程。</p><ul><li><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象的对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁（Heavyweight Locked）。</p></li><li><p>Mark Word 结构：最后两位是<strong>锁标志位</strong>。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png" alt="img"></p><p>64 位虚拟机 Mark Word：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png" alt="img"></p></li></ul></li><li><p>synchronized 锁的原理：</p><ol><li><p>开始时 Monitor 中 Owner 为 null。</p></li><li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 内容存入线程栈中的锁记录</strong>中（轻量级锁部分详解）。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861.png" alt="img"></p></li><li><p>在 Thread-2 上锁后，Thread-1、Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，它们发现 obj 的 Mark Work 已经指向了一个 Monitor，并进一步发现该 Monitor 的 Owner 已经被 Thread-2 占用了，那这些线程就会进入 EntryList 等待，状态为 BLOCKED。</p></li><li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 Mark Word。</p></li><li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞。</p></li><li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制，后面再说）。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png" alt="img"></p><ul><li>注意：<ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></li></ul></li></ol></li><li><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁	<span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="img"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ul><li><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><ul><li>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</li></ul></li><li><p>轻量级锁加锁流程：</p><ol><li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png" alt="img"></p></li><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，<strong>将 Mark Word 的值存入线程栈中的锁记录</strong>。</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png" alt="img"></p><p>如果 CAS 失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程。</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数。</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png" alt="img"></p></li><li><p>当退出 synchronized 代码块（解锁时）：</p><ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1。</li><li>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ol></li></ul><h5 id="锁膨胀（轻量级锁-重量级锁）"><a href="#锁膨胀（轻量级锁-重量级锁）" class="headerlink" title="锁膨胀（轻量级锁->重量级锁）"></a>锁膨胀（轻量级锁-&gt;重量级锁）</h5><ul><li><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong>。</p><ol><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png" alt="img"></p></li><li><p>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png" alt="img"></p></li><li><p>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程。</p></li></ol></li></ul><h4 id="自旋锁（重量级锁竞争时）"><a href="#自旋锁（重量级锁竞争时）" class="headerlink" title="自旋锁（重量级锁竞争时）"></a>自旋锁（重量级锁竞争时）</h4><ul><li><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁。如果当前线程自旋成功，即此时持锁线程已经退出了同步块，释放了锁，这时当前线程就可以避免阻塞。</p><p>注意：</p><ul><li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势。</li><li>自旋失败的线程会进入阻塞状态。</li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong>。</p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源。</p></li><li><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%87%AA%E6%97%8B%E6%88%90%E5%8A%9F.png" alt="img"></p></li><li><p>自旋失败的情况：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5.png" alt="img"></p></li></ul><p>注意：</p><ul><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul></li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul><li><p>偏向锁的思想是偏向于<strong>让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作</strong>：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png" alt="img"></p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul></li><li><p>一个对象创建时：</p><ul><li><p>如果<strong>开启了偏向锁</strong>（默认开启），那么对象创建后，<strong>MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</strong>。</p><p>如果<strong>没有开启偏向锁</strong>，那么对象创建后，<strong>mark word 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为0，第一次用到 hashcode 时才会赋值</strong>。</p><ul><li>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了，从对象头的格式可以看出来，如果计算过 hashCode，那 54 位的线程 ID 已经存不下了，所以该对象不能再用偏向锁了。</li></ul></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul></li></ul><h5 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h5><ul><li>撤销偏向锁的状态：<ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 将导致偏向锁被撤销，<strong>偏向锁升级为轻量级锁</strong></li><li>当有其它线程使用偏向锁对象时，会将<strong>偏向锁升级为轻量级锁</strong></li><li>调用 wait/notify，需要申请 Monitor，进入 WaitSet，<strong>偏向锁升级为重量级锁</strong></li></ul></li><li><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID<ul><li>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</li><li>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li></ul></li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><ul><li>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong><ul><li>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</li></ul></li></ul><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait-notify"></a>wait-notify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU。</p><ul><li>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后再去争抢锁。</li></ul><p>Object 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></pre></td></tr></table></figure><ul><li>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。<strong>必须获得此对象的锁，才能调用这几个方法，也就是说线程必须成为 Monitor 的 Owner 之后，上面的方法调用才有效</strong>。</li></ul></li><li><p>对比 sleep()：</p><ul><li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li><li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li><li>使用区域不同：<strong>wait() 方法必须放在同步控制方法和同步代码块（先获取锁）中使用，即需要和 synchronized 一起使用</strong>，而 sleep() 方法可以放在任何地方使用</li></ul></li></ul><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><ul><li><p><strong>Owner 线程发现当前继续向下执行的条件不满足，则调用 wait 方法</strong>，即可进入 WaitSet 变为 WAITING 状态</p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p><ul><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png" alt="img"></p></li></ul><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><ul><li><p><strong>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</strong></p><ul><li><p>解决方法：采用 notifyAll</p></li><li><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><ul><li><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(lock) {</span><br><span class="line">    <span class="keyword">while</span> (条件不成立) { </span><br><span class="line">        lock.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 向下执行代码...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) {</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park-unpark"></a>park-unpark</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li><p><code>LockSupport</code> 是用来创建锁和其他同步类的<strong>线程原语</strong>。</p><ul><li><code>LockSupport</code> 类方法：<ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul></li></ul><p><code>LockSupport</code> 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li><strong>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</strong>。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul></li></ul><h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><ul><li><p>先 park 再 unpark：</p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ol><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%861.png" alt="img"></p></li><li><p>先 unpark 再 park：</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li></ol><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%862.png" alt="img"></p></li></ul><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><img src="../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/Juc-notebook/img/4/线程状态转换.png" style="zoom:67%"><ul><li>假设有线程 t</li></ul><h4 id="情况-1-NEW-—-RUNNABLE"><a href="#情况-1-NEW-—-RUNNABLE" class="headerlink" title="情况 1 NEW —> RUNNABLE"></a>情况 1 NEW —&gt; RUNNABLE</h4><ul><li>当调用 t.start() 方法时，由 NEW —&gt; RUNNABLE</li></ul><h4 id="情况-2-RUNNABLE-—-WAITING"><a href="#情况-2-RUNNABLE-—-WAITING" class="headerlink" title="情况 2 RUNNABLE —> WAITING"></a>情况 2 RUNNABLE —&gt; WAITING</h4><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后<ul><li>调用 <code>obj.wait()</code> 方法时，t 线程从 RUNNABLE —&gt; WAITING</li><li>调用 <code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 WAITING —&gt; RANNABLE</li><li>竞争锁失败，t 线程从 WAITING —&gt; BLOCKED</li></ul></li></ul></li></ul><h4 id="情况-3-RUNNABLE-—-WAITING"><a href="#情况-3-RUNNABLE-—-WAITING" class="headerlink" title="情况 3 RUNNABLE —> WAITING"></a>情况 3 RUNNABLE —&gt; WAITING</h4><ul><li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 RUNNABLE —&gt; WAITING<ul><li>注意是当前线程在 t 线程对象的监视器上等待</li></ul></li><li>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING —&gt; RUNNABLE</li></ul><h4 id="情况-4-RUNNABLE-—-WAITING"><a href="#情况-4-RUNNABLE-—-WAITING" class="headerlink" title="情况 4 RUNNABLE —> WAITING"></a>情况 4 RUNNABLE —&gt; WAITING</h4><ul><li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 RUNNABLE —&gt; WAITING</li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程的 <code>interrupt()</code>，会让目标线程从 WAITING —&gt; RUNNABLE</li></ul><h4 id="情况-5-RUNNABLE-—-TIMED-WAITING"><a href="#情况-5-RUNNABLE-—-TIMED-WAITING" class="headerlink" title="情况 5 RUNNABLE —> TIMED_WAITING"></a>情况 5 RUNNABLE —&gt; TIMED_WAITING</h4><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后<ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 RUNNABLE —&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或者调用 <code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING —&gt; RANNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING —&gt; BLOCKED</li></ul></li></ul></li></ul><h4 id="情况-6-RUNNABLE-—-TIMED-WAITING"><a href="#情况-6-RUNNABLE-—-TIMED-WAITING" class="headerlink" title="情况 6 RUNNABLE —> TIMED_WAITING"></a>情况 6 RUNNABLE —&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 RUNNABLE —&gt; TIMED_WAITING<ul><li>注意是当前线程在 t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或者 t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 TIMED_WAITING —&gt; RUNNABLE</li></ul><h4 id="情况-7-RUNNABLE-—-TIMED-WAITING"><a href="#情况-7-RUNNABLE-—-TIMED-WAITING" class="headerlink" title="情况 7 RUNNABLE —> TIMED_WAITING"></a>情况 7 RUNNABLE —&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>Thread.sleep(long n)</code>，当前线程从 RUNNABLE —&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING —&gt; RUNNABLE</li></ul><h4 id="情况-8-RUNNABLE-—-TIMED-WAITING"><a href="#情况-8-RUNNABLE-—-TIMED-WAITING" class="headerlink" title="情况 8 RUNNABLE —> TIMED_WAITING"></a>情况 8 RUNNABLE —&gt; TIMED_WAITING</h4><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线程从 RUNNABLE —&gt; TIMED_WAITING</li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程的 <code>interrupt()</code>，或是等待超时，会让目标线程从 TIMED_WAITING —&gt; RUNNABLE</li></ul><h4 id="情况-9-RUNNABLE-—-BLOCKED"><a href="#情况-9-RUNNABLE-—-BLOCKED" class="headerlink" title="情况 9 RUNNABLE —> BLOCKED"></a>情况 9 RUNNABLE —&gt; BLOCKED</h4><ul><li>t 线程用 <code>synchronized(obj)</code> 获取对象锁时如果竞争失败，则从 RUNNABLE —&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，则从 BLOCKED —&gt; RUNNABLE，其它失败的线程仍然 BLOCKED</li></ul><h4 id="情况-10-RUNNABLE-—-TERMINATED"><a href="#情况-10-RUNNABLE-—-TERMINATED" class="headerlink" title="情况 10 RUNNABLE —> TERMINATED"></a>情况 10 RUNNABLE —&gt; TERMINATED</h4><ul><li>当前线程所有代码运行完毕，进入TERMINATED</li></ul><h3 id="★ReentrantLock"><a href="#★ReentrantLock" class="headerlink" title="★ReentrantLock"></a>★ReentrantLock</h3><ul><li>ReentrantLock 相对于 synchronized 具备如下特点：<ol><li>锁的实现：synchronized 是 JVM 实现的，使用关键字 <code>synchronized</code> 来使用。而 ReentrantLock 是 JDK 实现的，要创建 <code>ReentrantLock</code> 对象来使用。</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</li><li>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</li><li>可中断：ReentrantLock 可中断，而 synchronized 不行</li><li>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<ul><li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li><li>不公平锁的含义是阻塞队列内公平，队列外非公平</li></ul></li><li>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列<ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</li><li>两者都是可重入锁</li></ol></li></ul><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><code>public void lock()</code>：获得锁<ul><li>如果锁没有被另一个线程占用，则将锁定计数设置为 1</li><li>如果当前线程已经保持锁定，则保持计数增加 1</li><li>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</li></ul></li><li><code>public void unlock()</code>：尝试释放锁<ul><li>如果当前线程是该锁的持有者，则保持计数递减</li><li>如果保持计数现在为零，则锁定被释放</li><li>如果当前线程不是该锁的持有者，则抛出异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">	<span class="comment">// 获取锁</span></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	reentrantLock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁。如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁。</li><li>用 lock 方法加两把锁会是什么情况呢？<ul><li>加锁两次解锁两次：正常执行</li><li>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></li><li>加锁一次解锁两次：运行程序会直接报错</li></ul></li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><ul><li><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li>如果没有锁竞争，此方法就会获取 lock 对象锁</li><li>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {    </span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {        </span><br><span class="line">        <span class="keyword">try</span> {            </span><br><span class="line">            System.out.println(<span class="string">"尝试获取锁"</span>);            </span><br><span class="line">            lock.lockInterruptibly();        </span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {            </span><br><span class="line">            System.out.println(<span class="string">"没有获取到锁，被打断，直接返回"</span>);            </span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        }        </span><br><span class="line">        <span class="keyword">try</span> {            </span><br><span class="line">            System.out.println(<span class="string">"获取到锁"</span>);        </span><br><span class="line">        } <span class="keyword">finally</span> {            </span><br><span class="line">            lock.unlock();        </span><br><span class="line">        }    </span><br><span class="line">    }, <span class="string">"t1"</span>);    </span><br><span class="line">    lock.lock();    </span><br><span class="line">    t1.start();    </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);    </span><br><span class="line">    System.out.println(<span class="string">"主线程进行打断锁"</span>);    </span><br><span class="line">    t1.interrupt();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>注意：如果是不可中断模式 <code>lock.lock()</code>，那么即使使用了 interrupt 也不会让等待状态中的线程中断</li></ul></li></ul><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><ul><li><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p><p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) {</span><br><span class="line">                System.out.println(<span class="string">"获取不到锁"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="string">"被打断，获取不到锁"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            log.debug(<span class="string">"获取到锁"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }, <span class="string">"t1"</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">"主线程获取到锁"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        System.out.println(<span class="string">"主线程释放了锁"</span>);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>注意：tryLock 期间也可以被打断</li></ul></li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p><ul><li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li><li>不公平锁的含义是阻塞队列内公平，队列外非公平</li></ul></li><li><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock 默认是不公平的</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> {</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>说明：公平锁一般没有必要，会降低并发度。</p></li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量。</p></li><li><p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</li><li><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</li></ul><p>使用流程：</p><ul><li><strong>await / signal 前需要获得锁</strong></li><li>await 执行后，会释放锁进入 ConditionObject 等待</li><li>await 的线程被唤醒（或打断，或超时）去重新竞争 lock 锁</li><li><strong>线程在条件队列被打断会抛出中断异常</strong></li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {    </span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建一个新的条件变量</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"进入等待"</span>);</span><br><span class="line">            <span class="comment">//进入休息室等待</span></span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">"被唤醒了"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }    </span><br><span class="line">    }).start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//叫醒</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {            </span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">            <span class="comment">// condition2.signal(); // 用condition2是不能唤醒的，因为之前的线程是在condition1中等待</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2><a href="#" class="headerlink"></a></h2></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/06/25/%E9%94%81/" title="锁">https://running-noob.github.io/2024/06/25/锁/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/06/25/Java%E7%BA%BF%E7%A8%8B/" rel="prev" title="Java线程"><i class="fa fa-chevron-left"></i> Java线程</a></div><div class="post-nav-item"><a href="/2024/06/25/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/" rel="next" title="Java内存模型JMM">Java内存模型JMM <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85synchronized"><span class="nav-text">★synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor%EF%BC%88%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="nav-text">Monitor（重量级锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E8%86%A8%E8%83%80%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="nav-text">锁膨胀（轻量级锁-&gt;重量级锁）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89%E6%97%B6%EF%BC%89"><span class="nav-text">自旋锁（重量级锁竞争时）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-text">撤销偏向锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-text">锁消除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify"><span class="nav-text">wait-notify</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#park-unpark"><span class="nav-text">park-unpark</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1"><span class="nav-text">底层原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">线程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-1-NEW-%E2%80%94-RUNNABLE"><span class="nav-text">情况 1 NEW —&gt; RUNNABLE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-2-RUNNABLE-%E2%80%94-WAITING"><span class="nav-text">情况 2 RUNNABLE —&gt; WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-3-RUNNABLE-%E2%80%94-WAITING"><span class="nav-text">情况 3 RUNNABLE —&gt; WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-4-RUNNABLE-%E2%80%94-WAITING"><span class="nav-text">情况 4 RUNNABLE —&gt; WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-5-RUNNABLE-%E2%80%94-TIMED-WAITING"><span class="nav-text">情况 5 RUNNABLE —&gt; TIMED_WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-6-RUNNABLE-%E2%80%94-TIMED-WAITING"><span class="nav-text">情况 6 RUNNABLE —&gt; TIMED_WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-7-RUNNABLE-%E2%80%94-TIMED-WAITING"><span class="nav-text">情况 7 RUNNABLE —&gt; TIMED_WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-8-RUNNABLE-%E2%80%94-TIMED-WAITING"><span class="nav-text">情况 8 RUNNABLE —&gt; TIMED_WAITING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-9-RUNNABLE-%E2%80%94-BLOCKED"><span class="nav-text">情况 9 RUNNABLE —&gt; BLOCKED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B5-10-RUNNABLE-%E2%80%94-TERMINATED"><span class="nav-text">情况 10 RUNNABLE —&gt; TERMINATED</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85ReentrantLock"><span class="nav-text">★ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">可重入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="nav-text">可打断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="nav-text">锁超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">条件变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text"></span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">243</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">469k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:27</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
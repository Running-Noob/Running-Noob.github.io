<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="以一个黑马点评项目作为 Redis 的实战篇内容 黑马点评半成品代码地址：https:&#x2F;&#x2F;gitcode.net&#x2F;Drifter_Galaxy&#x2F;hmdp.git 其中的 hm-dianping.zip（后端）、nginx-1.18.0.zip（里面有前端资源）、hmdp.sql 文件是我们需要的。 具体如何导入该项目，见视频 P25"><meta property="og:type" content="article"><meta property="og:title" content="Redis实战篇"><meta property="og:url" content="https://running-noob.github.io/2024/03/10/Redis%E5%AE%9E%E6%88%98%E7%AF%87/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="以一个黑马点评项目作为 Redis 的实战篇内容 黑马点评半成品代码地址：https:&#x2F;&#x2F;gitcode.net&#x2F;Drifter_Galaxy&#x2F;hmdp.git 其中的 hm-dianping.zip（后端）、nginx-1.18.0.zip（里面有前端资源）、hmdp.sql 文件是我们需要的。 具体如何导入该项目，见视频 P25"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-03-10T11:54:31.000Z"><meta property="article:modified_time" content="2024-04-29T13:08:49.539Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://running-noob.github.io/2024/03/10/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Redis实战篇 | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">240</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/03/10/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis实战篇</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-10 19:54:31" itemprop="dateCreated datePublished" datetime="2024-03-10T19:54:31+08:00">2024-03-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-29 21:08:49" itemprop="dateModified" datetime="2024-04-29T21:08:49+08:00">2024-04-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>33 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>以一个黑马点评项目作为 Redis 的实战篇内容<ul><li>黑马点评半成品代码地址：<a target="_blank" rel="noopener" href="https://gitcode.net/Drifter_Galaxy/hmdp.git">https://gitcode.net/Drifter_Galaxy/hmdp.git</a><ul><li>其中的 <code>hm-dianping.zip</code>（后端）、<code>nginx-1.18.0.zip</code>（里面有前端资源）、<code>hmdp.sql</code> 文件是我们需要的。</li><li>具体如何导入该项目，见视频 <code>P25</code></li></ul></li></ul></li></ul></blockquote><span id="more"></span><h2 id="二、实战篇"><a href="#二、实战篇" class="headerlink" title="二、实战篇"></a>二、实战篇</h2><ul><li><p>以一个黑马点评项目作为 Redis 的实战篇内容：</p><ul><li>黑马点评半成品代码地址：<a target="_blank" rel="noopener" href="https://gitcode.net/Drifter_Galaxy/hmdp.git">https://gitcode.net/Drifter_Galaxy/hmdp.git</a><ul><li>其中的 <code>hm-dianping.zip</code>（后端）、<code>nginx-1.18.0.zip</code>（里面有前端资源）、<code>hmdp.sql</code> 文件是我们需要的。</li><li>具体如何导入该项目，见视频 <code>P25</code></li></ul></li></ul></li></ul><h3 id="2-1-短信登录"><a href="#2-1-短信登录" class="headerlink" title="2.1 短信登录"></a>2.1 短信登录</h3><ul><li>短信登录的总流程：</li></ul><h4 id="2-1-1-发送短信验证码"><a href="#2-1-1-发送短信验证码" class="headerlink" title="2.1.1 发送短信验证码"></a>2.1.1 发送短信验证码</h4><ul><li><p>发送短信验证码的流程：</p><ul><li><strong><code>/api</code> 的作用：</strong><ul><li><strong>在 Web 开发中，使用路径中包含 <code>/api</code> 的约定是一种常见的做法，通常用于区分前端页面的路径和后端 API 的路径。</strong></li></ul></li></ul></li><li><p>根据短信登录总流程的第一个图示进行业务代码的编写（<strong>从接到前端请求开始往后端写</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送手机验证码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping("/code")</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam("phone")</span> String phone, HttpSession session)</span> {</span><br><span class="line">    <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; {</span><br><span class="line">    Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> {</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) {</span><br><span class="line">            <span class="comment">// 手机号不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"手机号有误，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 3.将手机号验证码保存到session</span></span><br><span class="line">        session.setAttribute(<span class="string">"phone"</span>, phone);</span><br><span class="line">        session.setAttribute(<span class="string">"code"</span>, code);</span><br><span class="line">        log.info(<span class="string">"手机号验证码为：{}"</span>, code);</span><br><span class="line">        <span class="comment">// 4.发送验证码</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-短信验证码登录"><a href="#2-1-2-短信验证码登录" class="headerlink" title="2.1.2 短信验证码登录"></a>2.1.2 短信验证码登录</h4><ul><li><p>短信验证码登录的流程：</p></li><li><p>根据短信登录总流程的第二个图示进行业务代码的编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 登录功能</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping("/login")</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span> {</span><br><span class="line">    <span class="comment">// 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm, session);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; {</span><br><span class="line">    ...</span><br><span class="line">    Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> {</span><br><span class="line">        <span class="comment">// 1.校验手机号，防止用户在得到短信验证码后修改手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cachePhone</span> <span class="operator">=</span> session.getAttribute(<span class="string">"phone"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cachePhone == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"手机号过期，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!phone.equals(cachePhone.toString())) {</span><br><span class="line">            <span class="comment">// 前后手机号不一致</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"获取验证码的手机号和当前手机号不一致"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.校验验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">"code"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cacheCode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"验证码过期，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!code.equals(cacheCode.toString())) {</span><br><span class="line">            <span class="comment">// 验证码有误</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"验证码有误，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3.根据手机号查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">"phone"</span>, cachePhone.toString()).one();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 用户不存在则保存新用户数据到数据库中</span></span><br><span class="line">            user = createUserWithPhone(cachePhone.toString());</span><br><span class="line">            save(user);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.保存用户信息到session中</span></span><br><span class="line">        session.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-3-校验登录状态-拦截器"><a href="#2-1-3-校验登录状态-拦截器" class="headerlink" title="2.1.3 校验登录状态 - 拦截器"></a>2.1.3 校验登录状态 - 拦截器</h4><ul><li><p>因为用户需要先登录，才能对点评 app 的大多数功能进行操作，所以需要一个<strong>登录校验拦截器</strong>来帮助我们校验用户的登录状态，这样就不需要在每个 <code>Controller</code> 中都校验用户的登录状态了。另外，<code>XxxController</code> 在实现功能操作时有可能需要用户的信息，所以我们要把用户的信息保存在 <code>ThreadLocal</code> 中。</p></li><li><p>根据短信登录总流程的第三个图示进行业务代码的编写：</p><ul><li><p>登录校验拦截器的实现：</p><ul><li><p>创建登录校验拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 2.获取session中的用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> (UserDTO) session.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果用户不存在，则拦截，返回 401 状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果用户存在，就将用户保存在ThreadLocal中</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 移除用户，避免内存泄漏</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：在将用户信息保存在 <code>ThreadLocal</code> 中时，并没有将 <code>User</code> 对象保存在 <code>ThreadLocal</code> 中，而是将 <code>UserDTO</code> 保存在 <code>ThreadLocal</code> 中（<code>UserDTO</code> 中仅有 <code>User</code> 的部分属性），目的是为了隐藏用户的敏感信息。</li></ul></li><li><p>注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.utils.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * springmvc相关的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 指定以下这些路径不拦截</span></span><br><span class="line">                        <span class="string">"/user/code"</span>,</span><br><span class="line">                        <span class="string">"/user/login"</span>,</span><br><span class="line">                        <span class="string">"/blog/hot"</span>,</span><br><span class="line">                        <span class="string">"/shop/**"</span>,</span><br><span class="line">                        <span class="string">"/shop-type/**"</span>,</span><br><span class="line">                        <span class="string">"/upload/**"</span>,</span><br><span class="line">                        <span class="string">"/voucher/**"</span></span><br><span class="line">                );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("/me")</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 获取当前登录的用户并返回</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(user);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-4-服务器集群的session共享问题"><a href="#2-1-4-服务器集群的session共享问题" class="headerlink" title="2.1.4 服务器集群的session共享问题"></a>2.1.4 服务器集群的session共享问题</h4><ul><li><strong><code>session</code> 共享问题：多台 Tomcat 并不共享 session 存储空间，当请求切换到不同 tomcat 服务时导致数据丢失的问题</strong>。</li></ul><h5 id="★基于Redis实现共享session登录"><a href="#★基于Redis实现共享session登录" class="headerlink" title="★基于Redis实现共享session登录"></a>★基于Redis实现共享session登录</h5><ul><li><p>既然要使用 Redis 来存储用户的信息，那就要考虑用什么样的数据结构来存储：</p><ul><li>对于验证码，考虑使用 <code>String</code> 类型，并且 <code>key</code> 是手机号，<code>value</code> 是验证码。</li><li>对于用户信息，考虑使用 <code>Hash</code> 类型，并且 <code>key</code> 是随机 token（不使用手机号作为 <code>key</code> 是为了安全，因为我们要将用户信息的 <code>key</code> 保存在浏览器内存中）。</li></ul></li><li><p>接下来就基于 <code>2.1.1 - 2.1.3</code> 小节的代码，进行修改。</p><ul><li><p>发送短信验证码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> {</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) {</span><br><span class="line">            <span class="comment">// 手机号不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"手机号有误，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 3.将手机号验证码保存到redis，key是手机号，value是验证码，并设置有效期为两分钟</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, Duration.ofMinutes(RedisConstants.LOGIN_CODE_TTL));</span><br><span class="line">        log.info(<span class="string">"手机号验证码为：{}"</span>, code);</span><br><span class="line">        <span class="comment">// 4.发送验证码</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>短信验证码登录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> {</span><br><span class="line">        <span class="comment">// 1.校验验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);</span><br><span class="line">        <span class="keyword">if</span> (cacheCode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 验证码过期</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"验证码过期，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!code.equals(cacheCode)) {</span><br><span class="line">            <span class="comment">// 验证码有误</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"验证码有误，请重试"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.根据手机号查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">"phone"</span>, phone).one();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 用户不存在则保存新用户数据到数据库中</span></span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">            save(user);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3.保存用户信息到redis中</span></span><br><span class="line">        <span class="comment">//      3.1 随机生成token，作为登录令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//      3.2 将用户信息用Hash类型存储在redis中，key是token，value是用户信息，并设置有效期为30分钟</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create().setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString())));</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));</span><br><span class="line">        <span class="comment">// 4.返回token给前端</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>校验登录状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.f.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">"authorization"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果token不存在，则拦截，返回 401 状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.根据token获取redis中的用户</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">userMap</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) {</span><br><span class="line">            <span class="comment">// 如果用户不存在，则拦截，返回 401 状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果用户存在，就刷新token的有效期，并将用户保存在ThreadLocal中</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 移除用户，避免内存泄漏</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：如果用户一直在操作，就要一直刷新 token 的有效期。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.utils.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * springmvc相关的配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 指定以下这些路径不拦截</span></span><br><span class="line">                        <span class="string">"/user/code"</span>,</span><br><span class="line">                        <span class="string">"/user/login"</span>,</span><br><span class="line">                        <span class="string">"/blog/hot"</span>,</span><br><span class="line">                        <span class="string">"/shop/**"</span>,</span><br><span class="line">                        <span class="string">"/shop-type/**"</span>,</span><br><span class="line">                        <span class="string">"/upload/**"</span>,</span><br><span class="line">                        <span class="string">"/voucher/**"</span></span><br><span class="line">                );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><code>MvcConfig</code> 注入 <code>StringRedisTemplate</code>，然后传给 <code>LoginInterceptor</code>，因为 <code>LoginInterceptor</code> 不是 bean，不能注入其他 bean。</li></ul></li></ul></li></ul><h5 id="登录拦截器的优化"><a href="#登录拦截器的优化" class="headerlink" title="登录拦截器的优化"></a>登录拦截器的优化</h5><ul><li><p>目前登录拦截器的业务逻辑是：<strong>会被拦截的用户请求</strong>进入拦截器，进行 <code>preHandle</code> 操作，在 <code>preHandle</code> 中对 redis 中的 token 进行有效期刷新。</p><p>但是，如果用户在登录后，一直访问不需要拦截的路径，那 redis 中的 token 的有效期就一直不被刷新，最终 token 失效，用户还要重新登录。所以我们需要对登录拦截器进行优化：<strong>在这个拦截器前面再加个拦截器，然后在新增拦截器上进行保存用户信息到 <code>ThreadLocal</code> 和刷新 token 有效期的操作</strong>。</p><ul><li><p>创建拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.f.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/7 15:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">"authorization"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果token不存在，直接放行，由后续的拦截器进行拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.根据token获取redis中的用户</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">userMap</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) {</span><br><span class="line">            <span class="comment">// 如果用户不存在，直接放行，由后续的拦截器进行拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果用户存在，就刷新token的有效期，并将用户保存在ThreadLocal中</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, Duration.ofMinutes(RedisConstants.LOGIN_USER_TTL));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 移除用户，避免内存泄漏</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果用户不存在，则拦截，返回 401 状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>注册拦截器并指定顺序（<code>order</code> 越小优先级越高）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.utils.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.RefreshTokenInterceptor;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * springmvc相关的配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/6 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        <span class="comment">// token刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                <span class="comment">// 拦截所有请求</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .order(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 指定以下这些路径不拦截</span></span><br><span class="line">                        <span class="string">"/user/code"</span>,</span><br><span class="line">                        <span class="string">"/user/login"</span>,</span><br><span class="line">                        <span class="string">"/blog/hot"</span>,</span><br><span class="line">                        <span class="string">"/shop/**"</span>,</span><br><span class="line">                        <span class="string">"/shop-type/**"</span>,</span><br><span class="line">                        <span class="string">"/upload/**"</span>,</span><br><span class="line">                        <span class="string">"/voucher/**"</span></span><br><span class="line">                )</span><br><span class="line">                .order(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-2-★★★商户查询缓存"><a href="#2-2-★★★商户查询缓存" class="headerlink" title="2.2 ★★★商户查询缓存"></a>2.2 ★★★商户查询缓存</h3><ul><li><strong>缓存</strong>：就是数据交换的缓冲区（称作Cache），是存贮数据的临时地方，一般读写性能较高。<ul><li>由于 Redis 基于内存，具有低延迟，速度快的特征，所以 Redis 很适合用作缓存。</li></ul></li></ul><h4 id="2-2-1-添加商户缓存"><a href="#2-2-1-添加商户缓存" class="headerlink" title="2.2.1 添加商户缓存"></a>2.2.1 添加商户缓存</h4><ul><li><p>添加商户缓存的流程：</p><ul><li><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询商铺信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id 商铺id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 商铺详情数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping("/{id}")</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable("id")</span> Long id)</span> {</span><br><span class="line">    <span class="keyword">return</span> shopService.queryShopById(id);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.Shop;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShopService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Shop&gt; {</span><br><span class="line">    Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.Shop;</span><br><span class="line"><span class="keyword">import</span> com.f.mapper.ShopMapper;</span><br><span class="line"><span class="keyword">import</span> com.f.service.IShopService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.RedisConstants;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> {</span><br><span class="line">        <span class="comment">// 1.从redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="comment">// 2.判断商铺缓存是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 3.存在则直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.不存在则从数据库中查询商铺信息</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 5.判断商铺信息是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 6.不存在则返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 7.存在则将商铺信息写入redis，并返回商铺信息</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + shop.getId(),</span><br><span class="line">                JSONUtil.toJsonStr(shop), Duration.ofMinutes(RedisConstants.CACHE_SHOP_TTL));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>经过测试，在使用缓存之前，查询耗时 92ms；在使用缓存之后，查询耗时 11ms，大大加快了查询效率。</li></ul></li></ul></li></ul><h4 id="2-2-2-★缓存更新策略"><a href="#2-2-2-★缓存更新策略" class="headerlink" title="2.2.2 ★缓存更新策略"></a>2.2.2 ★缓存更新策略</h4><ul><li><p>如果数据库中的数据发生改变，而 Redis 还没及时更新相关数据，那么从 Redis 缓存中取到的数据就是过时的数据，就存在<strong>数据一致性问题</strong>。为了解决这个问题，我们需要使用缓存更新策略：</p><ul><li><strong>内存淘汰</strong></li><li><strong>超时剔除</strong></li><li><strong>主动更新</strong></li></ul></li></ul><h5 id="★主动更新"><a href="#★主动更新" class="headerlink" title="★主动更新"></a>★主动更新</h5><ul><li><p>主动更新策略需要考虑下面几个问题：</p><ul><li>删除缓存还是更新缓存？<ul><li><strong>删除缓存，查询时再更新缓存，避免无效的写操作</strong>。</li></ul></li><li>如何保证缓存与数据库的操作同时成功或失败？</li><li>先操作缓存还是先操作数据库？<ul><li>由于操作数据库的速度比操作缓存的速度慢，所以操作缓存的时候有极低概率会被操作数据库的线程抢占cpu，出现线程安全问题，而反过来出现线程安全问题的概率更大，所以<strong>先操作数据库再操作缓存</strong>。<ul><li>视频 <code>P38</code> 有动画演示，不明白的话可以看一下。</li></ul></li></ul></li></ul></li><li><p><strong>总结：缓存更新策略的最佳实践方案：</strong></p><ol><li><strong>低一致性需求：使用 Redis 自带的内存淘汰机制。</strong></li><li><strong>高一致性需求：主动更新，并以超时剔除作为兜底方案：</strong><ul><li><strong>读操作：</strong><ul><li><strong>缓存命中则返回。</strong></li><li><strong>缓存未命中则查询数据库，并写入缓存，设定超时时间。</strong></li></ul></li><li><strong>写操作：</strong><ul><li><strong>先写数据库，然后再删除缓存。</strong></li><li><strong>要确保数据库与缓存操作的原子性。</strong></li></ul></li></ul></li></ol></li></ul><h4 id="2-2-3-实现商铺缓存与数据库的双写一致"><a href="#2-2-3-实现商铺缓存与数据库的双写一致" class="headerlink" title="2.2.3 实现商铺缓存与数据库的双写一致"></a>2.2.3 实现商铺缓存与数据库的双写一致</h4><ul><li><p>在更新商铺信息的方法中，实现前面所说的：</p><ul><li>先写数据库，然后再删除缓存。</li><li>确保数据库与缓存操作的原子性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 更新商铺信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> shop 商铺数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShop</span><span class="params">(<span class="meta">@RequestBody</span> Shop shop)</span> {</span><br><span class="line">    <span class="comment">// 更新商铺，包括操作数据库和操作缓存</span></span><br><span class="line">    <span class="keyword">return</span> shopService.updateShopById(shop);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShopService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Shop&gt; {</span><br><span class="line">    ......</span><br><span class="line">    Result <span class="title function_">updateShopById</span><span class="params">(Shop shop)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 事务保证原子性操作</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShopById</span><span class="params">(Shop shop)</span> {</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"商铺不存在，无法更新"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1.更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">// 2.删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-4-★缓存穿透"><a href="#2-2-4-★缓存穿透" class="headerlink" title="2.2.4 ★缓存穿透"></a>2.2.4 ★缓存穿透</h4><ul><li><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p></li><li><p>缓存穿透的解决思路：</p><ul><li><p><strong>缓存空对象</strong>：</p><ul><li>当用户请求的数据在缓存和数据库中都不存在时，为了避免用户不断请求该数据，给数据库造成太大压力，所以在 Redis 缓存中缓存 <code>null</code>，这样用户再次重复请求后，得到的就是缓存中的 <code>null</code>。</li></ul></li><li><p><strong>布隆过滤</strong>：</p><p>布隆过滤器（Bloom Filter）是一种空间高效的数据结构，主要用于判断一个元素是否属于一个集合，而不存储具体的元素内容。它适用于那些需要判断大量元素是否存在的场景，如缓存、数据去重等。</p><p><strong>布隆过滤器说数据不存在，那是一定不存在</strong>，因为如果元素存在，那么其哈希函数对应的位置应该为 1。<strong>布隆过滤器说数据存在，数据未必存在</strong>，因为不同元素经过哈希函数映射到位数组时可能发生冲突，导致多个元素的多个位置相同。</p><ul><li>通过在客户端和 Redis 之间增加一层布隆过滤器来解决缓存穿透问题。不过还是存在一定的缓存穿透风险，原因如上，布隆过滤器说数据存在，数据未必存在。</li></ul></li></ul></li><li><p>在考虑了缓存穿透问题后，对查询商铺的代码进行修改：</p><ul><li>增加了缓存空对象以及判断缓存内容是否为 <code>""</code> 的逻辑代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="comment">// 1.从redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.判断商铺缓存是否存在且不为空</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span> &amp;&amp; !shopJson.equals(<span class="string">""</span>)) {</span><br><span class="line">        <span class="comment">// 3.存在则直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) { <span class="comment">// 表示商铺信息是空值，用于解决缓存穿透问题</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"商铺信息不存在"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.不存在则从数据库中查询商铺信息</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 5.判断商铺信息是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 6.不存在则将空值写入redis，并返回错误信息</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id,</span><br><span class="line">                                              <span class="string">""</span>, Duration.ofMinutes(RedisConstants.CACHE_NULL_TTL));</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 7.存在则将商铺信息写入redis，并返回商铺信息</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + shop.getId(),</span><br><span class="line">                                          JSONUtil.toJsonStr(shop), Duration.ofMinutes(RedisConstants.CACHE_SHOP_TTL));</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>除了被动的解决缓存穿透问题，也可以<strong>主动去避免出现缓存穿透问题</strong>，例如：</p><ul><li>增强 id 的复杂度，避免被猜测 id 规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul></li></ul><h4 id="2-2-5-★缓存雪崩"><a href="#2-2-5-★缓存雪崩" class="headerlink" title="2.2.5 ★缓存雪崩"></a>2.2.5 ★缓存雪崩</h4><ul><li><strong>缓存雪崩</strong>是指在同一时段大量的缓存 <code>key</code> 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。</li><li>缓存雪崩的解决思路：<ul><li>给不同的 <code>key</code> 的 <code>TTL</code> 添加随机值。</li><li>利用 Redis 集群提高服务的可用性。</li><li>给缓存业务添加降级限流策略，当 Redis 故障时，直接拒绝服务，避免将大量请求送到数据库，虽然降低了用户体验，但是保证了数据库的健康。</li><li>给业务添加多级缓存，如浏览器缓存、Nginx缓存、Redis缓存、jvm内部缓存等。</li></ul></li></ul><h4 id="2-2-6-★缓存击穿"><a href="#2-2-6-★缓存击穿" class="headerlink" title="2.2.6 ★缓存击穿"></a>2.2.6 ★缓存击穿</h4><ul><li><p><strong>缓存击穿</strong>问题也叫热点 <code>key</code> 问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的 <code>key</code> 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p></li><li><p>缓存击穿的解决方案：</p><ul><li><strong>互斥锁</strong>：查询缓存未命中，获取互斥锁，<strong>获取到互斥锁的才能查询数据库重建缓存</strong>，将数据写入缓存中后，释放锁。</li><li><strong>逻辑过期</strong>：查询缓存，发现逻辑时间已经过期，获取互斥锁，开启新线程；在新线程中查询数据库重建缓存，将数据写入缓存中后，释放锁；在释放锁之前，查询该数据时，都会将过期的数据返回。</li></ul><table><thead><tr><th align="center">解决方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center"><strong>互斥锁</strong></td><td align="center">没有额外的内存消耗；保证一致性；实现简单</td><td align="center">线程需要等待，性能受影响；可能有死锁风险</td></tr><tr><td align="center"><strong>逻辑过期</strong></td><td align="center">线程无需等待，性能较好</td><td align="center">有额外内存消耗；不保证一致性；实现复杂</td></tr></tbody></table></li></ul><h5 id="基于互斥锁方式解决缓存击穿问题"><a href="#基于互斥锁方式解决缓存击穿问题" class="headerlink" title="基于互斥锁方式解决缓存击穿问题"></a>基于互斥锁方式解决缓存击穿问题</h5><ul><li><p>核心：利用 Redis 的 <code>setnx</code> 方法来表示获取锁。该方法的含义是：如果 Redis 中没有这个 Key，则插入成功；如果有这个 Key，则插入失败。通过插入成功或失败来表示是否有线程插入 Key，<strong>插入成功的 Key 则认为是获取到锁的线程；释放锁就是将这个 Key 删除</strong>，因为删除 Key 以后其他线程才能再执行 <code>setnx</code> 方法。</p><ul><li><p>互斥锁方式解决缓存击穿问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在缓存穿透的基础上用互斥锁解决缓存击穿问题</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryShopWithMutex</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="comment">// 1.从redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.判断商铺缓存是否存在且不为空</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span> &amp;&amp; !shopJson.equals(<span class="string">""</span>)) {</span><br><span class="line">        <span class="comment">// 3.存在则直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) { <span class="comment">// 表示商铺信息是空值，用于解决缓存穿透问题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 4.不存在则尝试获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="comment">// 5.判断是否获取互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) {</span><br><span class="line">            <span class="comment">// 6.获取互斥锁失败，休眠并重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryShopWithMutex(id);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 7.获取互斥锁成功，去数据库查询商铺信息</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="comment">// 模拟缓存重建的延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 8.判断商铺信息是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 9.不存在则将空值写入redis，用于解决缓存穿透问题</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id,</span><br><span class="line">                                                  <span class="string">""</span>, Duration.ofMinutes(RedisConstants.CACHE_NULL_TTL));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 9.存在则将商铺信息写入redis，并在finally中释放互斥锁</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + shop.getId(),</span><br><span class="line">                                              JSONUtil.toJsonStr(shop), Duration.ofMinutes(RedisConstants.CACHE_SHOP_TTL));</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        stringRedisTemplate.delete(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁，通过是否成功插入key来判断是否获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> {</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">"1"</span>,</span><br><span class="line">                                                                 Duration.ofSeconds(RedisConstants.LOCK_SHOP_TTL));</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> {</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="基于逻辑过期方式解决缓存击穿问题"><a href="#基于逻辑过期方式解决缓存击穿问题" class="headerlink" title="基于逻辑过期方式解决缓存击穿问题"></a>基于逻辑过期方式解决缓存击穿问题</h5><ul><li><p>既然要对 <code>Shop</code> 对象增加一个逻辑过期时间，那就需要增加 <code>Shop</code> 类的属性，这违反了 <code>OCP</code> 原则，为此，新建一个 <code>RedisData</code> 类，用于逻辑过期时间的增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>将店铺数据预设到缓存中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将店铺数据预设到缓存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireTime)</span> {</span><br><span class="line">    <span class="comment">// 1.查询店铺数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.封装逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusDays(expireTime));</span><br><span class="line">    <span class="comment">// 3.写入redis缓存，没有设置redis中的ttl</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id,</span><br><span class="line">                                          JSONUtil.toJsonStr(redisData));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>逻辑过期方式解决缓存击穿问题代码实现：</p><ul><li>不考虑缓存穿透问题，因为缓存是人为预设的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用逻辑过期解决缓存击穿问题（不考虑缓存穿透）</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryShopWithLogicalExpire</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="comment">// 1.从redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.判断商铺缓存是否命中</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 3.未命中则返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.命中则再判断商铺缓存是否过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断商铺缓存是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) {</span><br><span class="line">        <span class="comment">// 6.商铺缓存未过期，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 7.商铺缓存过期，尝试获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 8.判断是否获取互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (isLock) {</span><br><span class="line">        <span class="comment">// 9.如果获取互斥锁，新开一个线程用于更新商铺缓存</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                saveShop2Redis(id, RedisConstants.SHOP_EXPIRE_TTL);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放互斥锁</span></span><br><span class="line">                unlock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 10.不论是否获取互斥锁，都返回过时的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>总的来说，缓存穿透、缓存雪崩、缓存击穿最终带来的问题都是给数据库带来了巨大的请求压力，可能会导致数据库的崩溃</strong>，所以需要采取相关措施来解决这些缓存问题。</p></li></ul><h3 id="2-3-优惠券秒杀"><a href="#2-3-优惠券秒杀" class="headerlink" title="2.3 优惠券秒杀"></a>2.3 优惠券秒杀</h3><h4 id="2-3-1-全局唯一ID"><a href="#2-3-1-全局唯一ID" class="headerlink" title="2.3.1 全局唯一ID"></a>2.3.1 全局唯一ID</h4><ul><li><p>全局 ID 生成器，是一种<strong>在分布式系统下</strong>用来生成全局唯一 ID 的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul><p>而 Redis 恰好能满足以上大部分特性，除了安全性需要另外做一些处理。</p><ul><li><p>为了 ID 的安全性，不直接使用 Redis 自增的数值，而是拼接一些其它信息：</p><ul><li>符号位：1bit，永远为0，表示正数</li><li>时间戳：31bit，以秒为单位</li><li>序列号：32bit，秒内的计数器，支持每秒产生 2^32 个不同 ID</li></ul></li></ul></li><li><p>全局 ID 生成器生成全局唯一 ID 的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/8 16:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> {</span><br><span class="line">    <span class="comment">// 定义初始时间戳，以2000年1月1日为基准</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> LocalDateTime</span><br><span class="line">            .of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            .toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="comment">// 时间戳左移位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyPrefix用于区分不同的业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> {</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">// 2.生成序列号（用redis的自增长）</span></span><br><span class="line">        <span class="comment">// 获取当前日期（精确到天）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy:MM:dd"</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">incr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">"incr:"</span> + keyPrefix + <span class="string">":"</span> + date);</span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="comment">//return timeStamp &lt;&lt; COUNT_BITS + incr;</span></span><br><span class="line">        <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_BITS | incr;  <span class="comment">// 用或运算效率更高</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>使用 Redis 达到全局唯一 ID 的策略：<ul><li>每天一个 key，例如：<code>incr:order:2024:03:08</code> 表示是 2024 年 3 月 8 日关于订单业务的 key，既防止 redis 自增值太大，又方便统计订单量（订单量即为 key 对应的 value）。</li><li><strong>ID 构造是：时间戳 + 计数器</strong></li></ul></li></ul></li></ul><h4 id="2-3-2-优惠券秒杀下单"><a href="#2-3-2-优惠券秒杀下单" class="headerlink" title="2.3.2 优惠券秒杀下单"></a>2.3.2 优惠券秒杀下单</h4><ul><li><p>优惠券秒杀下单的流程：</p><ul><li><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul></li><li><p>根据流程图进行代码编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 前端控制器</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/voucher-order")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderController</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService voucherOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("seckill/{id}")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(<span class="meta">@PathVariable("id")</span> Long voucherId)</span> {</span><br><span class="line">        <span class="keyword">return</span> voucherOrderService.seckillVoucher(voucherId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoucherOrderService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;VoucherOrder&gt; {</span><br><span class="line">    Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.SeckillVoucher;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.f.mapper.VoucherOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.f.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.f.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.RedisIdWorker;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 1.查询优惠券信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始或结束</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(now)</span><br><span class="line">                || voucher.getEndTime().isBefore(now)) {</span><br><span class="line">            <span class="comment">// 3.如果秒杀还未开始或者已经结束，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"秒杀还未开始或已经结束"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.如果秒杀开始，且没有结束，再判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 5.库存不足，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 6.库存充足，扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">"voucher_id"</span>, voucherId) <span class="comment">// where id = ?</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        order.setId(redisIdWorker.nextId(<span class="string">"order"</span>));</span><br><span class="line">        order.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">// 8.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(order.getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-3-★超卖问题"><a href="#2-3-3-★超卖问题" class="headerlink" title="2.3.3 ★超卖问题"></a>2.3.3 ★超卖问题</h4><ul><li><p>在高并发场景下，上面的代码会出现超卖问题，即，虽然库存只有 100 张特价券，但却出现卖出超过 100 张特价券的情况。这是因为多线程在同时操作同一个资源。</p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁，加锁分为两种：<strong>悲观锁</strong>和<strong>乐观锁</strong>：</p><ul><li>悲观锁比较简单，直接添加同步锁，让线程串行执行，但性能不高。</li></ul></li><li><p>我们重点来看乐观锁。</p></li></ul><h5 id="★乐观锁解决超卖问题"><a href="#★乐观锁解决超卖问题" class="headerlink" title="★乐观锁解决超卖问题"></a>★乐观锁解决超卖问题</h5><ul><li><p>乐观锁的关键是<strong>在修改时，判断之前查询得到的数据是否有被修改过（也就是在 set 语句中添加 where 条件）</strong>，常见的方式有两种：</p><ul><li><p><strong>版本号法</strong>：每个数据记录都有一个版本号，用于追踪数据的变化。在并发操作中，乐观锁机制通过比较版本号来判断数据是否已经被其他事务修改，从而协调事务的执行。</p></li><li><p><strong>CAS法</strong>：<code>CAS（Compare And Swap）</code>，CAS 有 3 个操作数：</p><ul><li>需要读写的内存值 <code>V</code></li></ul></li><li><p>进行比较的值 <code>A</code></p><ul><li>拟写入的新值 <code>B</code></li></ul><p>当且仅当预期值 <code>A</code> 和内存值 <code>V</code> 相同时，将内存值 <code>V</code> 修改为 <code>B</code>，否则什么都不做。</p><ul><li><code>CAS</code> 法可以看作是版本号法的简化。</li></ul></li></ul></li><li><p>接下来用 <code>CAS</code> 法解决库存超卖问题，只需要修改前面代码中的第 6 步即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.库存充足，扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">"voucher_id"</span>, voucherId).eq(<span class="string">"stock"</span>, voucher.getStock()) <span class="comment">// where id = ? and stock = ? 添加了乐观锁</span></span><br><span class="line">    .update();</span><br><span class="line"><span class="keyword">if</span> (!success) {</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>结果是不会出现线程安全问题，但是特价券会出现过剩的情况，即 100 张特价券并没有被卖完。这就是<strong>乐观所的弊端</strong>：例如多个线程一开始标识 stock 为 100，然后有个线程把 stock 减一了，其他那些线程就会返回错误，特价券就剩余下来了。</p></li><li><p>改进：不去在 sql 语句中判断库存是否改变，而是在 sql 语句中判断库存是否 &gt;0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.库存充足，扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">    .update();</span><br><span class="line"><span class="keyword">if</span> (!success) {</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>乐观锁用于修改数据时。</strong></p></li></ul><h4 id="2-3-4-一人一单"><a href="#2-3-4-一人一单" class="headerlink" title="2.3.4 一人一单"></a>2.3.4 一人一单</h4><ul><li><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单。</p></li><li><p>在之前的代码中增加判断用户是否已经买过该特价券的业务逻辑：</p><ul><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 1.查询优惠券信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始或结束</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(now)</span><br><span class="line">                || voucher.getEndTime().isBefore(now)) {</span><br><span class="line">            <span class="comment">// 3.如果秒杀还未开始或者已经结束，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"秒杀还未开始或已经结束"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.如果秒杀开始，且没有结束，再判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 5.库存不足，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 6.判断用户是否已经买过该特价券了</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="comment">// 7.如果用户已经买过该特价券，就返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 8.库存充足，扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 9.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        order.setId(redisIdWorker.nextId(<span class="string">"order"</span>));</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">// 10.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(order.getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>用 jmeter 压测发现，用户还是可以购买多张特价券，<strong>原因在于：先查询，再判断</strong>。在多并发场景下，如果多个用户同时查询，那在判断的时候，就出现了多线程导致的错误。</li></ul></li><li><p>既然是多线程错误，那加锁吧，但是注意：不能用乐观锁，因为<strong>乐观锁用于修改数据时</strong>，而这里是查询数据，所以我们要用悲观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.SeckillVoucher;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.f.mapper.VoucherOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.f.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.f.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.RedisIdWorker;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 1.查询优惠券信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始或结束</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(now)</span><br><span class="line">                || voucher.getEndTime().isBefore(now)) {</span><br><span class="line">            <span class="comment">// 3.如果秒杀还未开始或者已经结束，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"秒杀还未开始或已经结束"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.如果秒杀开始，且没有结束，再判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 5.库存不足，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> {	<span class="comment">// 使用悲观锁</span></span><br><span class="line">        <span class="comment">// 6.判断用户是否已经买过该特价券了</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="comment">// 7.如果用户已经买过该特价券，就返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 8.库存充足，扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 9.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        order.setId(redisIdWorker.nextId(<span class="string">"order"</span>));</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">// 10.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(order.getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了，因为<strong>在集群模式下，我们会有多个 jvm 的锁监视器</strong>，就导致可能出现同一个用户的多个线程都能执行的情况。具体可以看视频 <code>P55</code>。</p><ul><li>为了解决这个问题，我们需要使用分布式锁。</li></ul></li></ul><h4 id="2-3-5-★★★分布式锁"><a href="#2-3-5-★★★分布式锁" class="headerlink" title="2.3.5 ★★★分布式锁"></a>2.3.5 ★★★分布式锁</h4><ul><li>在集群模式下，<code>synchronized</code> 锁失效了，**<code>synchronized</code> 只能保证单个 jvm 内部的多个线程之间互斥**，而没有办法让集群模式下的多个 jvm 进程之间互斥。</li></ul><h5 id="2-3-5-1-分布式锁-原理"><a href="#2-3-5-1-分布式锁-原理" class="headerlink" title="2.3.5.1 分布式锁-原理"></a>2.3.5.1 分布式锁-原理</h5><ul><li><p>为了实现多个 jvm 进程之间的互斥，我们不去使用 jvm 内部的锁监视器，而是<strong>在外部开一个锁监视器</strong>，让它监视所有的线程。</p></li><li><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁需要满足的特性：</p><ul><li>多进程可见，互斥，高可用，高性能，安全性。</li></ul></li><li><p><strong>分布式锁的核心是实现多进程之间互斥</strong>，而满足这一点的方式有很多，常见的有三种：</p><ul><li>MySQL：MySQL 本身带有锁机制，但是由于 MySQL 性能一般，所以采用分布式锁的情况下，使用 MySQL 作为分布式锁比较少见。</li><li>Redis：Redis 作为分布式锁比较常见，利用 <code>setnx</code> 方法，如果 Key 插入成功，则表示获取到锁，插入失败则表示无法获取到锁。</li><li>Zookeeper：Zookeeper 也是企业级开发中比较好的一个实现分布式锁的方案。</li></ul><table><thead><tr><th align="center"></th><th align="center">MySQL</th><th align="center">Redis</th><th align="center">Zookeeper</th></tr></thead><tbody><tr><td align="center">互斥</td><td align="center">利用 MySQL 本身的互斥锁机制</td><td align="center">利用 <code>setnx</code> 互斥命令</td><td align="center">利用节点的唯一性和有序性</td></tr><tr><td align="center">高可用</td><td align="center">好</td><td align="center">好</td><td align="center">好</td></tr><tr><td align="center">高性能</td><td align="center">一般</td><td align="center">好</td><td align="center">一般</td></tr><tr><td align="center">安全性</td><td align="center">断开链接，自动释放锁</td><td align="center">利用锁超时时间，到期释放</td><td align="center">临时节点，断开链接自动释放</td></tr></tbody></table></li></ul><h5 id="2-3-5-2-分布式锁-Redis实现"><a href="#2-3-5-2-分布式锁-Redis实现" class="headerlink" title="2.3.5.2 分布式锁-Redis实现"></a>2.3.5.2 分布式锁-Redis实现</h5><ul><li><p>我们在这里基于 Redis 来实现分布式锁：</p><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p><strong>获取锁</strong>：</p><ul><li><p>互斥：确保只能有一个线程获取锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加锁，利用setnx的互斥特性</span><br><span class="line">SETNX lock thread1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>释放锁</strong>：</p><ul><li><p>手动释放：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 释放锁，删除即可</span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li><li><p>超时释放：获取锁时添加一个超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加锁过期时间避免服务宕机引起的死锁</span><br><span class="line">EXPIRE lock <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>思考：如何做到<strong>添加锁操作和超时释放锁操作必须同时成功或者同时失败</strong>？</p><p>避免刚添加完锁后，服务器宕机，不能进行超时释放锁的操作。</p><ul><li><code>SET</code> 操作和 <code>EXPIRE</code> 操作写在同个语句即可：<code>SET lock thread1 EX 10 NX</code> （NX 表示 key 不存在的时候才可以 SET）。</li></ul></li><li><p>接下来基于 Redis 实现分布式锁的初级版本：</p><ul><li><p>定义分布式锁的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/9 9:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁的超时时间，过期后自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表获取锁成功，false代表失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/9 9:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">"lock:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String key, StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> {</span><br><span class="line">        <span class="comment">// 获取当前线程标识</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + key, threadId.toString(), Duration.ofSeconds(timeoutSec)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>在一人一单业务中使用分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.f.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.SeckillVoucher;</span><br><span class="line"><span class="keyword">import</span> com.f.pojo.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.f.mapper.VoucherOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.f.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.f.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.RedisIdWorker;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.SimpleRedisLock;</span><br><span class="line"><span class="keyword">import</span> com.f.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 1.查询优惠券信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始或结束</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(now)</span><br><span class="line">                || voucher.getEndTime().isBefore(now)) {</span><br><span class="line">            <span class="comment">// 3.如果秒杀还未开始或者已经结束，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"秒杀还未开始或已经结束"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.如果秒杀开始，且没有结束，再判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 5.库存不足，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 使用分布式锁（对同一个用户的id上锁）</span></span><br><span class="line">        <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">"order:"</span> + UserHolder.getUser().getId(), stringRedisTemplate);</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">10L</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) {   <span class="comment">// 获取锁失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();  <span class="comment">// 代理对象才能实现事务</span></span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 6.判断用户是否已经买过该特价券了</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="comment">// 7.如果用户已经买过该特价券，就返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 8.库存充足，扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 9.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        order.setId(redisIdWorker.nextId(<span class="string">"order"</span>));</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line">        save(order);</span><br><span class="line">        <span class="comment">// 10.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(order.getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-3-5-3-Redis分布式锁误删问题"><a href="#2-3-5-3-Redis分布式锁误删问题" class="headerlink" title="2.3.5.3 Redis分布式锁误删问题"></a>2.3.5.3 Redis分布式锁误删问题</h5><ul><li><p>考虑这样一种极端情况：</p><ul><li>线程 1 首先获取分布式锁，然后执行自己的业务，但是线程 1 的业务阻塞了，超过了分布式锁的 TTL，所以分布式锁被超时释放了，此时线程 1 还在执行业务。</li><li>线程 2 来获取分布式锁，因为线程 1 的分布式锁被超时释放，所以线程 2 可以获取分布式锁，然后执行自己的业务。</li><li>此时问题来了，在线程 2 执行自己的业务时，线程 1 的业务完成，它开始手动释放锁，因为线程 1 和线程 2 共用一把锁，这就导致，<strong>线程 1 将线程 2 的分布式锁释放了</strong>。</li><li>线程 3 再来获取分布式锁，因为分布式锁被线程 1 释放了（按理来说应该是由线程 2 来释放的），所以线程 3 可以获取分布式锁，然后执行自己的业务。</li></ul><p>这就造成了分布式锁误删的问题。</p><ul><li><p>为了解决这一问题，我们需要<strong>在释放锁的时候判断锁的标识是否一致，Redis 锁的标识一般是指 value 的区分</strong>，前面在获取锁时，我们是将线程标识，即线程 id 作为 value 存入，因此在释放锁时，只要判断当前线程的 id 是否为当前锁的 value 即可。</p><ul><li>这里的线程标识，我们之前用的是线程 id 进行标识，但是如果放到集群线程下，多个 jvm 可能会出现同个线程 id 的线程，这样会引发线程安全问题，所以这里要用 <code>ThreadID + UUID</code>，<strong>用 <code>UUID</code> 来区分不同的 jvm，用 <code>ThreadID</code> 来区分不同的线程</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/9 9:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">"lock:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UUID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String key, StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> {</span><br><span class="line">        <span class="comment">// 获取当前线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> UUID_PREFIX + <span class="string">"-"</span> + Thread.currentThread().getId();</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + key, threadId, Duration.ofSeconds(timeoutSec)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 获取线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> UUID_PREFIX + <span class="string">"-"</span> + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁中标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + key);</span><br><span class="line">        <span class="comment">// 判断线程标识和锁中标识是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(value)) {</span><br><span class="line">            <span class="comment">// 一致则释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-3-5-4-分布式锁的原子性问题"><a href="#2-3-5-4-分布式锁的原子性问题" class="headerlink" title="2.3.5.4 分布式锁的原子性问题"></a>2.3.5.4 分布式锁的原子性问题</h5><ul><li><p>我们考虑一种比较极端的情况：</p><ul><li><p>在 <code>SimpleRedisLock</code> 的 <code>unlock</code> 方法中，“判断线程标识和锁中标识是否一致” 和 “释放锁” 是两步操作，在这两步操作中，如果发生了阻塞，就有可能会出现并发问题：</p><ul><li>线程 1 首先获取分布式锁，然后执行自己的业务，线程 1 执行完自己的业务，并判断线程标识和锁中标识一致，就在线程 1 要释放分布式锁时，发生了阻塞（例如 jvm 的垃圾回收机制会阻塞所有代码）。</li><li>线程 1 一直阻塞直到超时释放锁，此时线程 2 来获取分布式锁，因为线程 1 的分布式锁被超时释放，所以线程 2 可以获取分布式锁，然后执行自己的业务。</li><li>此时问题来了，在线程 2 执行自己的业务时，线程 1 的阻塞结束，因为线程 1 在之前已经判断线程标识和锁中标识一致，所以线程 1 接下来直接执行释放锁的操作，于是线程 1 将线程 2 的分布式锁释放了。</li><li>线程 3 再来获取分布式锁，因为分布式锁被线程 1 释放了（按理来说应该是由线程 2 来释放的），所以线程 3 可以获取分布式锁，然后执行自己的业务。</li></ul><p>同样出现了分布式锁被误删的问题，这里的原因在于：“判断线程标识和锁中标识是否一致” 和 “释放锁” 是两步操作，存在原子性问题。</p></li></ul></li></ul><h6 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h6><ul><li><p>Redis 提供了 Lua 脚本功能，<strong>在一个脚本中编写多条 Redis 命令，确保多条命令执行时的原子性</strong>。Lua 是一种编<br>程语言，它的基本语法可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p><ul><li><p>Lua 语言调用 Redis：<code>redis.call('命令名称', 'key', '其他参数', ...)</code></p><ul><li>写好脚本以后，使用 Redis 命令来调用脚本：<code>EVAL script numkeys key [key ...] arg [arg ...]</code></li></ul></li></ul></li><li><p>在介绍了 Lua 脚本后，再来看看之前分布式锁的原子性问题：</p><ul><li><p>目前 <code>unlock</code> 的业务流程：</p><ol><li>获取锁中的线程标识</li><li>判断是否与指定的标识（当前线程标识）一致</li><li>如果一致则释放锁（删除)</li><li>如果不一致则什么都不做</li></ol><p>用 Lua 脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁的key</span></span><br><span class="line"><span class="comment">-- local key = KEYS[1]</span></span><br><span class="line"><span class="comment">-- 当前线程标识</span></span><br><span class="line"><span class="comment">-- local threadId = ARGV[1]</span></span><br><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">'get'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 比较</span></span><br><span class="line"><span class="keyword">if</span>(id == ARGV[<span class="number">1</span>]) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">'del'</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="Java调用Lua脚本"><a href="#Java调用Lua脚本" class="headerlink" title="Java调用Lua脚本"></a>Java调用Lua脚本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/9 9:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">"lock:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UUID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"unlock.lua"</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String key, StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> {</span><br><span class="line">        <span class="comment">// 获取当前线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> UUID_PREFIX + <span class="string">"-"</span> + Thread.currentThread().getId();</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + key, threadId, Duration.ofSeconds(timeoutSec)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 调用Lua脚本</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(KEY_PREFIX + key),</span><br><span class="line">                UUID_PREFIX + <span class="string">"-"</span> + Thread.currentThread().getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>总结：<ul><li>基于 Redis 的分布式锁的实现思路：<ul><li>利用 <code>set nx ex</code> 获取锁，并设置过期时间，保存线程标识；</li><li>释放锁时先判断线程标识是否与自己一致，一致则删除锁，并使用 Lua 脚本保证原子性操作</li></ul></li><li>特性：<ul><li>利用 <code>set nx</code> 满足互斥性</li><li>利用 <code>set ex</code> 保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用 Redis 集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h4 id="2-3-6-Redisson"><a href="#2-3-6-Redisson" class="headerlink" title="2.3.6 Redisson"></a>2.3.6 Redisson</h4><ul><li>基于 <code>setnx</code> 实现的分布式锁存在下面的问题：<ul><li><strong>不可重入</strong>：同一个线程无法多次获取同一把锁。</li><li><strong>不可重试</strong>：获取锁只尝试一次就返回 false，没有重试机制。</li><li><strong>超时释放</strong>：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患。</li><li><strong>主从一致性</strong>：如果 Redis 提供了主从集群，由于主从同步存在延迟，当主宕机时，如果从还未同步主中的锁数据，则会出现主从一致性问题。</li></ul></li><li>Redisson 可以帮助我们，Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid)，它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</li></ul><h5 id="2-3-6-1-Redisson入门"><a href="#2-3-6-1-Redisson入门" class="headerlink" title="2.3.6.1 Redisson入门"></a>2.3.6.1 Redisson入门</h5><ul><li><p>使用 Redisson 的步骤：</p><ol><li><p>导入 Redisson 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redisson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 Redisson 客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/3/12 21:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加Redis地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://192.168.44.132:6379"</span>).setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 返回RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>使用 Redisson 的分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 使用Redisson的分布式锁（对同一个用户的id上锁）</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">"lock:order:"</span> + UserHolder.getUser().getId());</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!isLock) {   <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();  <span class="comment">// 代理对象才能实现事务</span></span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol></li></ul><h5 id="2-3-6-2-Redisson可重入锁原理"><a href="#2-3-6-2-Redisson可重入锁原理" class="headerlink" title="2.3.6.2 Redisson可重入锁原理"></a>2.3.6.2 Redisson可重入锁原理</h5><ul><li><p>为什么要引入可重入锁这种机制？</p><ul><li>假如有一个线程 1 获得了对象 A 的锁，那么该线程 1 如果在未释放锁前再次请求该对象的锁时，如果没有可重入锁的机制，线程 1 是不会再次获取到锁的，这样的话就会出现死锁的情况。</li><li>可重入锁的概念就是：自己可以获取自己的锁。</li></ul></li><li><p>为了实现可重入锁，就要<strong>在锁已经存在的情况下进行判断，判断当前锁是否是自己的锁，如果是自己的锁，就可以再次获取，并将获取次数加 1</strong>，如果不是自己的锁，就获取锁失败。</p><ul><li><p>因为要另外记录重入次数，所以不能再用 String 类型的数据结构，而是要使用 Hash 类型的数据结构：</p><ul><li><strong>第一次获取锁时，value 值为 1，然后每重入一次，value 值加一。</strong></li></ul></li></ul></li><li><p><strong>释放锁时，不是直接删除锁，而是将锁的 value 值减一，直到 value 为 0 的时候才可以删除锁。</strong></p><p>因为 Hash 类型的 Redis 命令没有 <code>set ex nx</code> 这种命令，所以我们只能先判断是否存在（exist），再设置过期时间。为了保证原子性操作，我们要将上图中锁的业务逻辑写在 Lua 脚本里。</p></li><li><p>Redisson 的可重入锁就利用了上面类似的原理。</p></li></ul><h5 id="2-3-6-3-Redisson锁重试和WatchDog机制"><a href="#2-3-6-3-Redisson锁重试和WatchDog机制" class="headerlink" title="2.3.6.3 Redisson锁重试和WatchDog机制"></a>2.3.6.3 Redisson锁重试和WatchDog机制</h5><ul><li><p>Redisson 分布式锁原理：</p><ul><li><strong>可重入</strong>：利用 Hash 结构记录线程标识和重入次数。</li><li><strong>可重试</strong>：利用信号量和 PubSub 功能实现等待、唤醒，获取锁失败的重试机制。</li><li><strong>超时续约</strong>：利用 WatchDog 机制，每隔一段时间（leaseTime / 3），重置超时时间。</li></ul><p>剩下还有一个主从一致性问题。</p></li></ul><h5 id="2-3-6-4-Redisson的multiLock原理"><a href="#2-3-6-4-Redisson的multiLock原理" class="headerlink" title="2.3.6.4 Redisson的multiLock原理"></a>2.3.6.4 Redisson的multiLock原理</h5><ul><li><p>既然使用 Redis 的主从集群会出现主从一致性问题，那就干脆不使用主从集群，而是将每个 Redis 节点都作为主节点。</p><ul><li>在获取锁时，应用会向每个 Redis 主节点都获取锁，即向每个 Redis 主节点都进行 <code>set nx ex</code> 操作，<strong>只有向每个 Redis 主节点进行的 <code>set nx ex</code> 操作都成功了，应用才能真正获取锁</strong>。<ul><li>为了 Redis 集群的高性能，可以在每个 Redis 主节点后面再挂上从节点。</li></ul></li><li>此时，就算其中一个 Redis 主节点宕机了，相应的从节点中没有保存锁数据，也不会出现并发问题：<ul><li>就算别的应用能对该 “新的主节点” 进行 <code>set nx ex</code> 操作来获取锁（因为没有保存锁数据），但是该应用不能对其他的 Redis 主节点进行获取锁的操作，而我们说过，只有向每个 Redis 主节点进行的 <code>set nx ex</code> 操作都成功了，应用才能真正获取锁，所以该应用并不能获取锁。</li></ul></li></ul><p>这样，就不会因为主从一致性，而导致并发问题。</p><ul><li>这种将多个锁联合在一起，成为一个联锁的方案，就是 <code>multiLock</code>。</li></ul></li></ul><h5 id="2-3-6-5-★总结"><a href="#2-3-6-5-★总结" class="headerlink" title="2.3.6.5 ★总结"></a>2.3.6.5 ★总结</h5><ul><li><strong>分布式锁总结</strong>：<ul><li>不可重入Redis分布式锁：<ul><li>原理：利用 <code>setnx</code> 的互斥性；利用 <code>ex</code> 避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li><strong>可重入Redis分布式锁</strong>：<ul><li>原理：利用 Hash 结构，记录线程标识和重入次数；利用信号量控制锁重试等待；利用 WatchDog 延续锁时间<ul><li>解决了不可重入、无法重试、锁超时失效的问题</li></ul></li><li>缺陷：Redis 主节点宕机引起锁失效问题</li></ul></li><li>**<code>multiLock</code>**：<ul><li>原理：多个独立的 Redis 节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ul></li></ul><h4 id="2-3-7-Redis秒杀优化"><a href="#2-3-7-Redis秒杀优化" class="headerlink" title="2.3.7 Redis秒杀优化"></a>2.3.7 Redis秒杀优化</h4><ul><li><p>由于目前的优惠券秒杀业务包含以下几步：</p><ul><li>查询优惠券，判断秒杀库存</li><li>查询订单，校验一人一单（<strong>用到分布式锁，保证一人一单</strong>）</li><li>减库存（<strong>用到乐观锁，防止超卖</strong>）</li><li>创建订单</li></ul><p>这几步都涉及到和数据库的操作，所以业务的性能并不高，业务耗时较长。</p><p>为了提高业务性能，考虑对业务流程进行优化：</p><ul><li><p>判断秒杀库存和校验一人一单的步骤完成后，其实就可以返回结果给客户，而不需要等到减库存和创建订单的步骤完成，特别是减库存和创建订单涉及数据库的写操作，耗时会比较久。</p><ul><li><strong>可以在判断秒杀库存和校验一人一单的步骤完成后，就将优惠券id、用户id、订单id的相关信息保存到阻塞队列，然后就返回结果给客户。而且通过 Redis 进行这两步来提高性能。</strong></li><li><strong>接着由另外的线程异步读取阻塞队列中的信息，完成减库存和创建订单的操作。</strong></li></ul><p>通过异步执行优惠券秒杀业务，来提高业务性能。</p></li></ul></li><li><p><strong>用 String 类型来存储库存，用 Set 类型来存储用户 id（保证唯一性，即保证一人一单）</strong>。</p></li><li><p>改进秒杀业务，提高并发性能。</p><p>需求：</p><ol><li>新增秒杀优惠券的同时，将优惠券信息保存到 Redis 中</li><li>基于 Lua 脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券 id 和用户 id 封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ol></li></ul><h5 id="2-3-7-1-基于Redis完成秒杀资格的判断"><a href="#2-3-7-1-基于Redis完成秒杀资格的判断" class="headerlink" title="2.3.7.1 基于Redis完成秒杀资格的判断"></a>2.3.7.1 基于Redis完成秒杀资格的判断</h5><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到 Redis 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> {</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>基于 Lua 脚本，判断秒杀库存、一人一单，决定用户是否抢购成功：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1 优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">'seckill:stock:'</span>..voucherId</span><br><span class="line"><span class="comment">-- 2.2 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">'seckill:order:'</span>..voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, stockKey)) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2判断用户是否下单 sismember orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">'sismember'</span>,orderKey,userId)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.3扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">'incrby'</span>,stockKey,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.4下单 sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">'sadd'</span>,orderKey,userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-3-7-2-基于阻塞队列实现异步秒杀下单"><a href="#2-3-7-2-基于阻塞队列实现异步秒杀下单" class="headerlink" title="2.3.7.2 基于阻塞队列实现异步秒杀下单"></a>2.3.7.2 基于阻塞队列实现异步秒杀下单</h5><ul><li><p>如果抢购成功，将下单信息封装后存入阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                                              Collections.emptyList(),</span><br><span class="line">                                              voucherId.toString(), userId.toString());</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="comment">// 3.不为0则返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (!result.equals(<span class="number">0L</span>)) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.equals(<span class="number">1L</span>) ? <span class="string">"库存不足"</span> : <span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.为0则将下单信息保存到阻塞队列中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setVoucherId(voucherId);</span><br><span class="line">    orderTasks.add(order);</span><br><span class="line">    <span class="comment">// 5.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">// 2.减少库存，创建订单</span></span><br><span class="line">                <span class="comment">// 2.1库存充足，扣减库存</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                    .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                    .eq(<span class="string">"voucher_id"</span>, voucherOrder.getVoucherId()).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">                    .update();</span><br><span class="line">                <span class="keyword">if</span> (!success) {</span><br><span class="line">                    log.error(<span class="string">"库存不足"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 2.2创建订单</span></span><br><span class="line">                save(voucherOrder);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                log.error(<span class="string">"处理订单异常"</span>, e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>最终优化后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> {</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"seckill.lua"</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.减少库存，创建订单</span></span><br><span class="line">                    <span class="comment">// 2.1库存充足，扣减库存</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                            .setSql(<span class="string">"stock = stock -1"</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                            .eq(<span class="string">"voucher_id"</span>, voucherOrder.getVoucherId()).gt(<span class="string">"stock"</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0 添加了乐观锁</span></span><br><span class="line">                            .update();</span><br><span class="line">                    <span class="keyword">if</span> (!success) {</span><br><span class="line">                        log.error(<span class="string">"库存不足"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 2.2创建订单</span></span><br><span class="line">                    save(voucherOrder);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    log.error(<span class="string">"处理订单异常"</span>, e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString());</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="comment">// 3.不为0则返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (!result.equals(<span class="number">0L</span>)) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(result.equals(<span class="number">1L</span>) ? <span class="string">"库存不足"</span> : <span class="string">"您已经购买过该特价券，每人仅限一张"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.为0则将下单信息保存到阻塞队列中</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(voucherId);</span><br><span class="line">        orderTasks.add(order);</span><br><span class="line">        <span class="comment">// 5.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-8-Redis消息队列实现异步秒杀"><a href="#2-3-8-Redis消息队列实现异步秒杀" class="headerlink" title="2.3.8 Redis消息队列实现异步秒杀"></a>2.3.8 Redis消息队列实现异步秒杀</h4><ul><li><p>上一节我们基于 jvm 的阻塞队列进行秒杀优化存在 2 个问题：</p><ol><li>jvm 的内存限制问题。</li><li>数据安全问题：jvm 的内存数据没有持久化，每当服务器重启或者宕机或者从阻塞队列取的时候遇到异常，数据都会丢失。</li></ol><p>解决办法： 消息队列。</p></li><li><p><strong>消息队列（Message Queue）</strong>，字面意思就是存放消息的队列。最简单的消息队列模型包括 3 个角色：</p><ul><li><strong>消息队列</strong>：存储和管理消息，也被称为消息代理（Message Broker）</li><li><strong>生产者</strong>：发送消息到消息队列</li><li><strong>消费者</strong>：从消息队列获取消息并处理消息</li></ul></li><li><p>视频中后面讲的是 Redis 自己提供的消息队列，而不是用市面上主流的消息队列，所以就不记笔记了。</p></li></ul><h3 id="2-4-关注推送（Feed流）"><a href="#2-4-关注推送（Feed流）" class="headerlink" title="2.4 关注推送（Feed流）"></a>2.4 关注推送（Feed流）</h3><ul><li><p>关注推送也叫做 Feed 流，直译为投喂。为用户持续的提供 “沉浸式” 的体验，通过无限下拉刷新获取新的信息。</p><ul><li><p>Feed 流产品有两种常见模式：</p><ul><li><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注，例如朋友圈。</li><li>优点：信息全面，不会有缺失。并且实现也相对简单<ul><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul></li><li><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣信息来吸引用户。<ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用</li></ul></li></ul><p>本例中的个人页面，是基于关注的好友来做 Feed 流，因此采用 Timeline 的模式。该模式的实现方案有三种：</p><ul><li><strong>拉模式（读扩散）</strong></li></ul></li><li><p><strong>推模式（写扩散）</strong></p><ul><li><strong>推拉结合（读写混合）</strong></li></ul><p>| | 拉模式 | 推模式 | 推拉结合 |</p></li></ul><p>| :———-: | :——: | :—————: | :——————-: |<br>| 写比例 | 低 | 高 | 中 |<br>| 读比例 | 高 | 低 | 中 |<br>| 用户读取延迟 | 高 | 低 | 低 |<br>| 实现难度 | 复杂 | 简单 | 很复杂 |<br>| 使用场景 | 很少使用 | 用户量少，没有大V | 过千万的用户量，有大V |</p><ul><li>这三种模式的具体动画表示可以看视频 <code>P84</code></li></ul></li><li><p>本例采用实现简单的推模式，通过将用户发布的文章推送到粉丝的收件箱来实现关注推送。</p></li></ul><h4 id="2-4-1-基于推模式实现关注推送"><a href="#2-4-1-基于推模式实现关注推送" class="headerlink" title="2.4.1 基于推模式实现关注推送"></a>2.4.1 基于推模式实现关注推送</h4><ul><li><p>需求：</p><ul><li><p>修改新增探店笔记的业务，在保存 blog 到数据库的同时，推送到粉丝的收件箱</p></li><li><p>收件箱满足可以根据时间戳排序，必须用 Redis 的数据结构实现</p><ul><li>根据目前所学，<code>List</code> 或者 <code>SortedSet</code> 类型的数据结构都能满足要求。</li></ul></li><li><p>查询收件箱数据时，可以实现分页查询</p><ul><li><p>Feed 流的分页问题：Feed 流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>需要使用<strong>滚动分页</strong>，通过记录上一次读取的页数的 <code>lastId</code> 来避免重复读取的情况。</p><ul><li>因为要实现分页查询的滚动分页，所以 <code>List</code> 类型的数据结构就不能满足要求了，因为它只能根据角标来分页，而在 Feed 流中角标是会变化的。由于 <code>SortedSet</code> 类型的数据结构有 <code>ZRANGEBYSCORE key min max</code> 命令，所以就可以满足我们的要求。</li></ul></li></ul></li></ul></li><li><p>修改新增探店笔记的业务，在保存 blog 到数据库的同时，推送到粉丝的收件箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> {</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"保存笔记失败"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.查找所有关注了作者的粉丝</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">"follow_user_id"</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.将笔记的id推送到粉丝的收件箱</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) {</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();   <span class="comment">// 粉丝id</span></span><br><span class="line">        stringRedisTemplate.opsForZSet().add(RedisConstants.FEED_KEY + userId,</span><br><span class="line">                                             blog.getId().toString(),</span><br><span class="line">                                             System.currentTimeMillis());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 5.返回笔记id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h5 id="滚动分页"><a href="#滚动分页" class="headerlink" title="滚动分页"></a>滚动分页</h5><ul><li><p>查询收件箱数据时，可以实现分页查询：</p><ul><li><p>滚动分页查询主要使用 <code>SortedSet</code> 的 <code>ZRANGEBYSCORE</code> 方法，因为以时间戳作为 score，越新的笔记排名理应越靠前，所以要降序排序，所以应该使用 <code>ZREVRANGEBYSCORE</code> 方法，主要涉及四个参数：</p><p><code>ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]</code></p><ul><li><p><code>max</code>：指定范围对应的最大 score</p><ul><li><strong>第一次查询给当前时间戳，往后查询给 “上一次查询的 <code>min</code>”</strong></li></ul></li><li><p><code>min</code>：指定范围对应的最小 score</p><ul><li>因为 score 为时间戳，所以恒为正数，那么把 <code>min</code> 固定为 0 即可</li></ul></li><li><p><code>offset</code>：读取偏移量，为 0 表示从 <code>max</code> 所在的数据开始向下读 <code>count</code> 条数据</p><ul><li><strong>第一次查询给 0，往后查询给 “上一次查询的 <code>min</code> 对应的数据个数”</strong>，避免好几条数据因为 score 值相同而出现问题，例如下面这样，<code>m6</code> 被重复查询了。</li></ul></li><li><p><code>count</code>：读取数据的条数</p><ul><li>由前端传值，来决定一页显示几条数据</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;   <span class="comment">// 查询到的min，作为下一次查询的max</span></span><br><span class="line">    <span class="keyword">private</span> Integer offset; <span class="comment">// 读取偏移量</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> {</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.根据当前用户找到对应的收件箱，并根据max和offset找到收件箱对应的片段</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; tuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (tuples == <span class="literal">null</span> || tuples.isEmpty()) {   <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.解析数据：blogId、minTime、offset</span></span><br><span class="line">    List&lt;String&gt; blogIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : tuples) {</span><br><span class="line">        <span class="comment">// 获取blogId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">blogId</span> <span class="operator">=</span> tuple.getValue();</span><br><span class="line">        blogIds.add(blogId);</span><br><span class="line">        <span class="comment">// 获取时间戳和offset</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span> (minTime == time) {</span><br><span class="line">            count++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            minTime = time;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.根据blogId查询对应的博客并封装</span></span><br><span class="line">    List&lt;Blog&gt; blogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String blogId : blogIds) {</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> query().eq(<span class="string">"id"</span>, blogId).one();</span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        blogs.add(blog);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 5.返回结果</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    scrollResult.setList(blogs);</span><br><span class="line">    scrollResult.setMinTime(minTime);</span><br><span class="line">    scrollResult.setOffset(count);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-UV统计"><a href="#2-5-UV统计" class="headerlink" title="2.5 UV统计"></a>2.5 UV统计</h3><ul><li><p><code>UV</code>：全称 <code>Unique Visitor</code>，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1 天内同一个用户多次访问该网站，只记录 1 次。</p><ul><li>相应的还有一个 <code>PV</code> 概念：全称 <code>Page View</code>，也叫页面访问量或点击量，用户每访问网站的一个页面，记录 1 次 PV，用户多次打开页面，则记录多次 PV，PV 往往用来衡量网站的流量。</li></ul><p>UV 统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存，但是如果每个访问的用户都保存到 Redis 中，数据量会非常恐怖。所以我们采用 <code>HyperLogLog</code> 来进行统计。</p></li></ul><h4 id="2-5-1-HyperLogLog"><a href="#2-5-1-HyperLogLog" class="headerlink" title="2.5.1 HyperLogLog"></a>2.5.1 HyperLogLog</h4><ul><li><p><code>Hyperloglog（HLL）</code>是从 <code>Loglog</code> 算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p><ul><li><p>Redis 中的 HLL 是基于 String 结构实现的，单个 HLL 的内存永远小于 16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于 0.81% 的误差，不过对于 UV 统计来说，这完全可以忽略。</p><p>下面是 Redis 中 HyperLogLog 的相关命令：</p></li></ul></li></ul><h4 id="2-5-2-使用HyperLogLog实现UV统计"><a href="#2-5-2-使用HyperLogLog实现UV统计" class="headerlink" title="2.5.2 使用HyperLogLog实现UV统计"></a>2.5.2 使用HyperLogLog实现UV统计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> {</span><br><span class="line">    String[] ids = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        ids[j] = <span class="string">"user_"</span> + (i);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) { <span class="comment">// 每一千条数据推一次到Redis</span></span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">"hll"</span>, ids);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">"hll"</span>);    <span class="comment">// 统计</span></span><br><span class="line">    System.out.println(size);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/03/10/Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="Redis实战篇">https://running-noob.github.io/2024/03/10/Redis实战篇/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/05/Springboot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87/" rel="prev" title="Springboot开发实用篇"><i class="fa fa-chevron-left"></i> Springboot开发实用篇</a></div><div class="post-nav-item"><a href="/2024/03/10/%E5%AD%97%E7%AC%A6%E4%B8%B2Tag/" rel="next" title="字符串Tag">字符串Tag <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98%E7%AF%87"><span class="nav-text">二、实战篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="nav-text">2.1 短信登录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="nav-text">2.1.1 发送短信验证码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95"><span class="nav-text">2.1.2 短信验证码登录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E6%A0%A1%E9%AA%8C%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2.1.3 校验登录状态 - 拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%9A%84session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-text">2.1.4 服务器集群的session共享问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABsession%E7%99%BB%E5%BD%95"><span class="nav-text">★基于Redis实现共享session登录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">登录拦截器的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E2%98%85%E2%98%85%E2%98%85%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-text">2.2 ★★★商户查询缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.1 添加商户缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E2%98%85%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-text">2.2.2 ★缓存更新策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="nav-text">★主动更新</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="nav-text">2.2.3 实现商铺缓存与数据库的双写一致</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E2%98%85%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">2.2.4 ★缓存穿透</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-%E2%98%85%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">2.2.5 ★缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-%E2%98%85%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">2.2.6 ★缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="nav-text">基于互斥锁方式解决缓存击穿问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="nav-text">基于逻辑过期方式解决缓存击穿问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="nav-text">2.3 优惠券秒杀</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="nav-text">2.3.1 全局唯一ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="nav-text">2.3.2 优惠券秒杀下单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E2%98%85%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-text">2.3.3 ★超卖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-text">★乐观锁解决超卖问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="nav-text">2.3.4 一人一单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E2%98%85%E2%98%85%E2%98%85%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">2.3.5 ★★★分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%8E%9F%E7%90%86"><span class="nav-text">2.3.5.1 分布式锁-原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3.5.2 分布式锁-Redis实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-3-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="nav-text">2.3.5.3 Redis分布式锁误删问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">2.3.5.4 分布式锁的原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">Lua脚本</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Java%E8%B0%83%E7%94%A8Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">Java调用Lua脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-Redisson"><span class="nav-text">2.3.6 Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-1-Redisson%E5%85%A5%E9%97%A8"><span class="nav-text">2.3.6.1 Redisson入门</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-2-Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-text">2.3.6.2 Redisson可重入锁原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-3-Redisson%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8CWatchDog%E6%9C%BA%E5%88%B6"><span class="nav-text">2.3.6.3 Redisson锁重试和WatchDog机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-4-Redisson%E7%9A%84multiLock%E5%8E%9F%E7%90%86"><span class="nav-text">2.3.6.4 Redisson的multiLock原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-5-%E2%98%85%E6%80%BB%E7%BB%93"><span class="nav-text">2.3.6.5 ★总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-7-Redis%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="nav-text">2.3.7 Redis秒杀优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-7-1-%E5%9F%BA%E4%BA%8ERedis%E5%AE%8C%E6%88%90%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-text">2.3.7.1 基于Redis完成秒杀资格的判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-7-2-%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="nav-text">2.3.7.2 基于阻塞队列实现异步秒杀下单</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-8-Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="nav-text">2.3.8 Redis消息队列实现异步秒杀</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81%EF%BC%88Feed%E6%B5%81%EF%BC%89"><span class="nav-text">2.4 关注推送（Feed流）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%9F%BA%E4%BA%8E%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="nav-text">2.4.1 基于推模式实现关注推送</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E5%88%86%E9%A1%B5"><span class="nav-text">滚动分页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-UV%E7%BB%9F%E8%AE%A1"><span class="nav-text">2.5 UV统计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-HyperLogLog"><span class="nav-text">2.5.1 HyperLogLog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E4%BD%BF%E7%94%A8HyperLogLog%E5%AE%9E%E7%8E%B0UV%E7%BB%9F%E8%AE%A1"><span class="nav-text">2.5.2 使用HyperLogLog实现UV统计</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">240</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">466k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:14</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
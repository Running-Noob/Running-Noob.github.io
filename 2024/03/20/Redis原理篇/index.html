<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="原理篇 数据结构 网络模型 通信协议 内存策略"><meta property="og:type" content="article"><meta property="og:title" content="Redis原理篇"><meta property="og:url" content="https://running-noob.github.io/2024/03/20/Redis%E5%8E%9F%E7%90%86%E7%AF%87/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="原理篇 数据结构 网络模型 通信协议 内存策略"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-03-20T11:54:49.000Z"><meta property="article:modified_time" content="2024-04-29T13:07:22.720Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://running-noob.github.io/2024/03/20/Redis%E5%8E%9F%E7%90%86%E7%AF%87/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Redis原理篇 | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">248</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/03/20/Redis%E5%8E%9F%E7%90%86%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis原理篇</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-20 19:54:49" itemprop="dateCreated datePublished" datetime="2024-03-20T19:54:49+08:00">2024-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-29 21:07:22" itemprop="dateModified" datetime="2024-04-29T21:07:22+08:00">2024-04-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>原理篇<ul><li>数据结构</li><li>网络模型</li><li>通信协议</li><li>内存策略</li></ul></li></ul></blockquote><span id="more"></span><h2 id="三、★原理篇"><a href="#三、★原理篇" class="headerlink" title="三、★原理篇"></a>三、★原理篇</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><h4 id="3-1-1-动态字符串SDS"><a href="#3-1-1-动态字符串SDS" class="headerlink" title="3.1.1 动态字符串SDS"></a>3.1.1 动态字符串SDS</h4><ul><li><p>我们都知道 Redis 中保存的 <code>key</code> 是字符串，<code>value</code> 往往是字符串或者字符串的集合，可见字符串是 Redis 中最常用的一种<br>数据结构。不过Redis 并没有直接使用 C 语言中的字符串，而是构建了一种新的字符串结构，称为<strong>简单动态字符串（Simple Dynamic String）</strong>，简称 <strong>SDS</strong>。</p><ul><li>例如，当我们执行命令 <code>SET name jack</code>，那么 Redis 将在底层创建两个 SDS，其中一个是包含 “name” 的 SDS，另一个是包含 “jack” 的 SDS。</li></ul></li><li><p>Redis 是 C 语言实现的，SDS 就是 C 语言中的结构体，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> Len; <span class="comment">/*buf已保存的字符串字节数，不包含结束标示*/</span></span><br><span class="line">	<span class="type">uint8_t</span> alloc; <span class="comment">/*buf申请的总的字节数，不包含结束标示*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/*不同SDS的头类型，用来控制SDS的头大小*/</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>SDS 之所以叫做动态字符串，是因为它具备<strong>动态扩容</strong>的能力。</li></ul></li></ul><h4 id="3-1-2-IntSet"><a href="#3-1-2-IntSet" class="headerlink" title="3.1.2 IntSet"></a>3.1.2 IntSet</h4><ul><li><code>IntSet</code> 是 Redis 中 set 集合的一种实现方式，基于整数数组来实现，并且具备<strong>长度可变、有序、唯一</strong>等特征。其结构如下：</li></ul><h5 id="IntSet类型自动升级"><a href="#IntSet类型自动升级" class="headerlink" title="IntSet类型自动升级"></a>IntSet类型自动升级</h5><ul><li><p>总结：<code>Intset</code> 可以看做是特殊的整数数组，具备一些特点：</p><ol><li>Redis 会确保 Intset 中的元素唯一、<strong>有序</strong>。</li><li>具备类型升级机制，可以节省内存空间。</li><li>底层采用二分查找方式来查询、插入。</li></ol><p>适用于数据量不多的情况，因为 <code>contents</code> 数组最多存放 2^8 = 256 个元素地址。</p></li></ul><h4 id="3-1-3-Dict"><a href="#3-1-3-Dict" class="headerlink" title="3.1.3 Dict"></a>3.1.3 Dict</h4><ul><li><p>我们知道 Redis 是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过 <code>Dict</code> 来实现的。</p><p><code>Dict</code> 由三部分组成，分别是：哈希表（<code>DictHashTable</code>）、哈希节点（<code>DictEntry</code>）、字典（<code>Dict</code>）。</p><ul><li><p><strong>当我们向 <code>Dict</code> 添加键值对时，Redis 首先根据 key 计算出 hash 值 h，然后利用 <code>h &amp; sizemask</code> 来计算元素应该存储到数组中的哪个索引位置</strong>。例如，下面的例子中，首先存储 k1，然后存储 k2，k1 和 k2 都存储在数组索引为 1 的位置，所以就会形成一条链表，就像 Java 的 Hashtable 那样，而且在 <code>Dict</code> 中，<strong>新存进来的数据挂在链表首部</strong>。</p></li><li><p><code>Dict</code> 的基本结构示例图如下：</p></li></ul></li></ul><h5 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h5><ul><li><p><code>Dict</code> 中的 HashTable 就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低，为此，<code>Dict</code> 在一定条件下会进行哈希表的扩容：</p><ul><li><code>Dict</code> 在每次新增键值对时都会检查负载因子（<code>LoadFactor=used/size</code>），满足以下两种情况时会触发哈希表扩容：<ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程。</li><li>哈希表的 LoadFactor &gt; 5。</li></ul></li></ul><p><code>Dict</code> 除了扩容以外，每次删除元素时，也会对负载因子做检查，当 LoadFactor&lt;0.1 时，会做哈希表收缩。</p></li><li><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 size 和 sizemask 变化，而 key 的查询与 sizemask 有关。因此必须对哈希表中的每一个 key 重新计算索引，插入新的哈希表，这个过程称为 <strong>rehash</strong>。过程是这样的：</p><ol><li>计算新 hash 表的 realSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新 size 为第一个大于等于 <code>dict.ht[0].used + 1</code> 的 2^n。</li><li>如果是收缩，则新 size 为第一个大于等于 <code>dict.ht[0].used</code> 的 2^n（不得小于4）。</li></ul></li><li>按照新的 realSize 申请内存空间，创建 dictht，并赋值给 dict.ht[1]。</li><li>设置 dict.rehashidx = 0，标示开始 rehash。</li><li>将 dict.ht[0] 中的每一个 dictEntry 都 rehash 到 dict.ht[1]。</li><li>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，释放原来的 dict.ht[0] 的内存。</li></ol></li><li><p><code>Dict</code> 的 rehash 并不是一次性完成的。试想一下，如果 <code>Dict</code> 中包含数百万的 entry，要在一次 rehash 完成，极有可能导致主线程阻塞。因此 <strong><code>Dict</code> 的 rehash 是分多次、渐进式的完成，因此称为渐进式 rehash</strong>。流程如下：</p><ol><li><p>计算新 hash 表的 realSize，值取决于当前要做的是扩容还是收缩：</p><ul><li>如果是扩容，则新 size 为第一个大于等于 <code>dict.ht[0].used + 1</code> 的 2^n。</li><li>如果是收缩，则新 size 为第一个大于等于 <code>dict.ht[0].used</code> 的 2^n（不得小于4）。</li></ul></li><li><p>按照新的 realSize 申请内存空间，创建 dictht，并赋值给 dict.ht[1]。</p></li><li><p>设置 dict.rehashidx = 0，标示开始 rehash。</p></li><li><p><strong>每次执行新增、查询、修改、删除操作时，都检查一下 <code>dict.rehashidx</code> 是否大于 -1，如果是则将 <code>dict.ht[0].table[rehashidx]</code> 的 entry 链表 rehash 到 dict.ht[1]，并且将 rehashidx++。直至 dict.ht[0] 的所有数据都 rehash 到 dict.ht[1]。</strong> -&gt; 渐进式rehash</p></li><li><p>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，释放原来的 dict.ht[0] 的内存。</p></li><li><p>将 rehashidx 赋值为 -1，代表 rehash 结束。</p><p><strong>注意</strong>：在 rehash 过程中，新增操作，则直接写入 dict.ht[1]，查询、修改和删除则会在 dict.ht[0] 和 dict.ht[1] 依次查找并执行。这样可以确保 dict.ht[0] 的数据只减不增，随着 rehash 最终为空。</p></li></ol></li></ul><h4 id="3-1-4-ZipList"><a href="#3-1-4-ZipList" class="headerlink" title="3.1.4 ZipList"></a>3.1.4 ZipList</h4><ul><li><p><code>Dict</code> 内部使用了大量的指针，用来指向分离的内存块，使得内存碎片化，同时指针自身也会占用一定的内存空间，所以 <code>Dict</code> 对内存资源的占用是较多的。</p><ul><li>为了尽可能的节省内存，设计了一种新的数据结构 <code>ZipList</code>。</li></ul></li><li><p><code>ZipList</code> 是一种特殊的“双端链表”，由一系列特殊编码的<strong>连续内存块</strong>组成，可以在任意一端进行压入/弹出操作，并且该操作的时间复杂度为 O(1)。</p></li><li><p><code>ZipList</code> 中的 <code>entry</code> 又由三部分组成：</p></li></ul><h5 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h5><h4 id="3-1-5-QuickList"><a href="#3-1-5-QuickList" class="headerlink" title="3.1.5 QuickList"></a>3.1.5 QuickList</h4><ul><li><p>QA：</p><ul><li>ZipList 虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？<ul><li>为了缓解这个问题，我们必须限制 ZipList 的长度和 entry 大小。</li></ul></li><li>但是我们要存储大量数据，超出了 ZipList 最佳的上限该怎么办？<ul><li>我们可以创建多个 ZipList 来分片存储数据。</li></ul></li><li>数据拆分后比较分散，不方便管理和查找，这多个 ZipList 如何建立联系？<ul><li>通过链表的方式来联系。</li></ul></li></ul></li><li><p>Redis 在 3.2 版本引入了新的数据结构 <code>QuickList</code>，它是一个<strong>双端链表</strong>，只不过**链表中的每个节点都是一个 <code>ZipList</code>**。</p></li></ul><h4 id="3-1-6-SkipList"><a href="#3-1-6-SkipList" class="headerlink" title="3.1.6 SkipList"></a>3.1.6 SkipList</h4><ul><li><p><code>QuickList</code> 需要从头结点或者尾结点开始查询，如果要查询中间结点，效率就会很低，而 <code>SkipList</code> 使得我们可以跳着找结点，从而提高性能。</p></li><li><p><code>SkipList</code>（跳表）首先是链表，但与传统链表相比有几点差异：</p><ul><li><strong>元素按照升序排列存储</strong>。</li><li><strong>节点可能包含多个指针，指针跨度不同（可以跳着找）</strong>。</li></ul></li></ul><h4 id="3-1-7-RedisObject"><a href="#3-1-7-RedisObject" class="headerlink" title="3.1.7 RedisObject"></a>3.1.7 RedisObject</h4><ul><li><p>前面六种数据结构都是 Redis 数据结构的底层实现，**这六种数据结构最终会被封装为 <code>RedisObject</code>**。</p></li><li><p><strong>Redis 中的任意数据类型的键和值都会被封装为一个 <code>RedisObject</code>，也叫做 Redis 对象</strong>，源码如下：</p></li><li><p>Redis 中常用的五种数据结构的底层数据结构如下：</p></li></ul><h4 id="★3-1-8-五种数据结构编码方式"><a href="#★3-1-8-五种数据结构编码方式" class="headerlink" title="★3.1.8 五种数据结构编码方式"></a>★3.1.8 五种数据结构编码方式</h4><h5 id="3-1-8-1-String"><a href="#3-1-8-1-String" class="headerlink" title="3.1.8.1 String"></a>3.1.8.1 String</h5><h5 id="3-1-8-2-List-QuickList"><a href="#3-1-8-2-List-QuickList" class="headerlink" title="3.1.8.2 List (QuickList)"></a>3.1.8.2 List (QuickList)</h5><h5 id="3-1-8-3-Set-Dict、IntSet"><a href="#3-1-8-3-Set-Dict、IntSet" class="headerlink" title="3.1.8.3 Set (Dict、IntSet)"></a>3.1.8.3 Set (Dict、IntSet)</h5><ul><li><p><code>Set</code> 既可能采用 HT 编码（<code>Dict</code>），也可能采用 <code>IntSet</code> 编码。</p><ul><li><p><strong>只有当存储的所有数据都是整数，并且元素数量不超过指定的 <code>set-max-intset-entries</code> 时，才会使用 <code>IntSet</code> 编码</strong></p><ul><li>如果此时向 <code>IntSet</code> 编码的 <code>Set</code> 中插入一个新元素，使得当前这个 <code>Set</code> 违背了 <code>IntSet</code> 编码的两个条件中的任意一个，那该 <code>Set</code> 就会由 <code>IntSet</code> 编码转换为 HT 编码（<code>Dict</code>）。</li></ul></li></ul></li></ul><h5 id="3-1-8-4-★ZSet-SkipList-Dict、ZipList"><a href="#3-1-8-4-★ZSet-SkipList-Dict、ZipList" class="headerlink" title="3.1.8.4 ★ZSet (SkipList+Dict、ZipList)"></a>3.1.8.4 ★ZSet (SkipList+Dict、ZipList)</h5><ul><li><p><code>ZSet</code> 就是 <code>SortedSet</code>。</p><ul><li><p>由于 <code>ZSet</code> 需要兼顾使用 <code>SkipList</code> 和 <code>Dict</code> 的特性，所以将一份数据存成两份，虽然性能好，但是非常占用内存空间，当数据量较少时使用 <code>SkipList</code> 和 <code>Dict</code> 的优势不明显。</p><ul><li><p>因此 <strong><code>ZSet</code> 还会采用 <code>ZipList</code> 结构来节省内存，不过需要同时满足以下两个条件：</strong></p><ol><li><strong>元素数量小于 <code>zset_max_ziplist_entries</code>，默认值 128</strong></li><li><strong>每个元素都小于 <code>zset_max_ziplist_value</code> 字节，默认值 64</strong></li></ol></li><li><p><code>ZipList</code> 本身没有排序功能，而且没有键值对的概念，因此需要通过代码逻辑来实现 <code>ZSet</code> 所需的功能：</p><ul><li><code>ZipList</code> 是连续内存，因此 score 和 element 是紧挨在一起的两个 entry，element 在前，score在后。</li><li>score 越小越接近队首，score 越大越接近队尾，按照 score 值升序排列。</li></ul></li></ul></li></ul></li><li><p>和 <code>Set</code> 类似，<code>ZSet</code> 也存在从一种编码方式向另一种编码方式转换的可能性，即从 <code>ZipList</code> 转换为 <code>SkipList+Dict</code>。</p></li></ul><h5 id="3-1-8-5-Hash-ZipList、Dict"><a href="#3-1-8-5-Hash-ZipList、Dict" class="headerlink" title="3.1.8.5 Hash (ZipList、Dict)"></a>3.1.8.5 Hash (ZipList、Dict)</h5><ul><li><p><code>Hash</code> 结构与 Redis 中的 <code>ZSet</code> 非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别在于：</p><ul><li><code>ZSet</code> 的键是 member，值是 score；<code>Hash</code> 的键和值都是任意值。</li><li><code>ZSet</code> 要根据 score 排序；**<code>Hash</code> 则无需排序**。</li></ul><p>因此，我们完全可以参考 <code>ZSet</code> 的编码，来设计 <code>Hash</code> 的编码，只需要把排序有关的 <code>SkipList</code> 去掉即可。</p></li><li><p><code>Hash</code> 同样存在编码方式的转换问题，源码分析直接看视频 <code>P159</code> 吧。</p></li></ul><h3 id="3-2-网络模型"><a href="#3-2-网络模型" class="headerlink" title="3.2 网络模型"></a>3.2 网络模型</h3><h4 id="3-2-1-用户空间和内核空间"><a href="#3-2-1-用户空间和内核空间" class="headerlink" title="3.2.1 用户空间和内核空间"></a>3.2.1 用户空间和内核空间</h4><ul><li><p>任何 Linux 发行版，其系统内核都是 Linux，我们的应用都需要通过 Linux 内核与硬件交互。</p><ul><li><p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p><p>进程的寻址空间会划分为两部分：<strong>内核空间</strong>、<strong>用户空间</strong>。</p><ul><li><strong>用户空间</strong>只能执行受限的命令 (Ring3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问。</li><li><strong>内核空间</strong>可以执行特权命令 (Ring0)，调用一切系统资源。</li></ul></li><li><p>Linux 系统为了提高 IO 效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li><strong>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备。</strong></li></ul></li><li><p><strong>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区。</strong></p></li><li><p>从图中可以看到，影响 IO 效率的主要因素有两个：</p></li><li><p>等待<strong>数据从硬件读取到内核空间</strong> <code>wait for data</code></p><ul><li>等待<strong>数据从内核缓冲区拷贝到用户缓冲区</strong> <code>copy</code></li></ul></li></ul></li><li><p>接下来以读数据为例，讲述五种 IO 之间的区别。</p><ul><li>这五种 IO 的不同之处就在于对 “影响 IO 效率的两个主要因素” 的处理方式不同。</li></ul></li></ul><h4 id="3-2-2-阻塞IO"><a href="#3-2-2-阻塞IO" class="headerlink" title="3.2.2 阻塞IO"></a>3.2.2 阻塞IO</h4><ul><li>顾名思义，阻塞 IO 就是<strong>用户进程在两个阶段都必须阻塞等待</strong>。</li></ul><h4 id="3-2-3-非阻塞IO"><a href="#3-2-3-非阻塞IO" class="headerlink" title="3.2.3 非阻塞IO"></a>3.2.3 非阻塞IO</h4><ul><li><p>顾名思义，非阻塞 IO 的 <code>recvfrom</code> 操作会<strong>立即返回结果而不是阻塞用户进程</strong>。</p><ul><li><p>在<strong>一阶段</strong>时是<strong>非阻塞</strong>，内核会直接返回错误信息。</p><p>在<strong>二阶段</strong>时是<strong>阻塞</strong>，等待数据从内核缓冲区拷贝到用户缓冲区。</p></li></ul></li><li><p>其实没啥用，因为用户进程一直反复调用 <code>recvfrom</code>，什么都没干，相当于阻塞。而且忙等机制会导致 CPU 空转，CPU 使用率暴增。</p></li></ul><h4 id="3-2-4-★★★IO多路复用"><a href="#3-2-4-★★★IO多路复用" class="headerlink" title="3.2.4 ★★★IO多路复用"></a>3.2.4 ★★★IO多路复用</h4><ul><li><p>无论是阻塞 IO 还是非阻塞 IO，用户应用在一阶段都需要调用 <code>recvfrom</code> 来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用 <code>recvfrom</code> 时，恰好没有数据，阻塞 IO 会使进程阻塞，非阻塞 IO 会使 CPU 空转，都不能充分发挥CPU的作用。</li><li>如果调用 <code>recvfrom</code> 时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据。</li></ul><p>考虑这样一种情况：服务端处理客户端 socket 请求时，在单线程情况下，只能依次处理每一个 socket，如果正在处理的 socket 恰好未就绪（数据不可读或不可写)，线程就会被阻塞，所有其它客户端 socket 都必须等待，性能自然会很差。</p><ul><li>为了解决这个问题，可以不让客户端的 socket 请求排队等待，而是看哪个 socket 请求的数据在内核态中已经准备就绪了，如果就绪了，用户应用就去内核缓冲区读取相应的 socket 请求的数据。<ul><li>问题在于：用户进程如何知道内核中数据是否就绪呢？<ul><li>通过 FD 知道。</li></ul></li></ul></li></ul></li><li><p>文件描述符（<code>File Descriptor</code>）：简称 <code>FD</code>，是一个从 0 开始递增的无符号整数，用来关联 Linux 中的一个文件。在 Linux<br>中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（<code>Socket</code>）。</p><ul><li><p><strong>IO 多路复用就是利用单个线程来同时监听多个 <code>FD</code>，并在某个 <code>FD</code> 可读、可写时得到通知</strong>，从而避免无效的等待，充分利用 CPU 资源。</p><ul><li><p>不过监听 <code>FD</code> 的方式，通知的方式又有多种实现，常见的有：</p><ul><li><code>select</code></li><li><code>poll</code></li><li><code>epoll</code></li></ul><p><code>select</code> 和 <code>poll</code> 只会通知用户进程有 <code>FD</code> 就绪，但不确定具体是哪个 <code>FD</code>，需要用户进程逐个遍历 <code>FD</code> 来确认。</p><p><strong><code>epoll</code> 则会在通知用户进程 <code>FD</code> 就绪的同时，把已就绪的 <code>FD</code> 写入用户空间</strong>。</p></li></ul></li></ul></li></ul><h5 id="3-2-4-1-select"><a href="#3-2-4-1-select" class="headerlink" title="3.2.4.1 select"></a>3.2.4.1 select</h5><ul><li><p><code>select</code> 是 Linux 中最早的 l/O 多路复用实现方案：</p><ul><li><code>select</code> 模式存在的问题：<ul><li>需要将整个 <code>fd_set</code> 从用户空间拷贝到内核空间，<code>select</code> 结束还要再次拷贝回用户空间。</li><li><code>select</code> 无法得知具体是哪个 <code>fd</code> 就绪，需要遍历整个 <code>fd_set</code>。</li><li><code>fd_set</code> 监听的 <code>fd</code> 数量不能超过 1024。</li></ul></li></ul></li></ul><h5 id="3-2-4-2-poll"><a href="#3-2-4-2-poll" class="headerlink" title="3.2.4.2 poll"></a>3.2.4.2 poll</h5><ul><li><code>poll</code> 模式对 <code>select</code> 模式做了简单改进，但性能提升不明显，部分关键代码如下：</li><li><code>select</code> 模式存在的问题在 <code>poll</code> 模式中依然存在，只解决了 <code>fd</code> 数量限制的问题，而且还可能带来性能的下降。</li></ul><h5 id="3-2-4-3-★epoll"><a href="#3-2-4-3-★epoll" class="headerlink" title="3.2.4.3 ★epoll"></a>3.2.4.3 ★epoll</h5><ul><li><p><code>epoll</code> 模式是对 <code>select</code> 和 <code>poll</code> 的改进，它提供了三个函数：</p><ol><li><code>epoll_create</code>：创建 <code>eventpoll</code>，<code>eventpoll</code> 包含有一颗红黑树和一个链表。</li><li><code>epoll_ctl</code>：将一个 <code>FD</code> 添加到 <code>epoll</code> 的红黑树中，并设置 <code>ep_poll_callback</code>，<strong>callback 触发时，就把对应的 <code>FD</code> 加入到 <code>rdlist</code> 这个就绪列表中</strong>。</li><li><code>epoll_wait</code>：检查 <code>rdlist</code> 列表是否为空，不为空则返回就绪的 <code>FD</code> 的数量，同时，<strong>将 <code>rdlist</code> 中就绪的 <code>FD</code> 拷贝到 <code>events</code> 空数组中，这样用户空间就明确知道有哪些 <code>FD</code> 的数据就绪了</strong>。</li></ol><ul><li>相比于 <code>select</code> 和 <code>poll</code>，<code>epoll</code> 解决了前两种模式存在的问题：<ol><li>基于 <code>epoll</code> 实例中的红黑树保存要监听的 <code>FD</code>，理论上无上限，而且增删改查效率都非常高，性能不会随监听的 <code>FD</code> 数量增多而下降。</li><li><strong>每个 <code>FD</code> 只需要执行一次 <code>epoll_ctl</code> 添加到红黑树</strong>，以后每次 <code>epoll_wait</code> 无需传递任何参数，无需重复拷贝 <code>FD</code> 到内核空间。</li><li><strong>内核会将就绪的 <code>FD</code> 直接拷贝到用户空间的指定位置，用户进程无需遍历所有 FD 就能知道就绪的 <code>FD</code> 是谁</strong>。</li></ol></li></ul></li></ul><h6 id="事件通知机制"><a href="#事件通知机制" class="headerlink" title="事件通知机制"></a>事件通知机制</h6><ul><li><p>当 <code>FD</code> 有数据可读时，我们调用 <code>epoll_wait</code> 就可以得到通知。事件通知的模式一般有两种：</p><ul><li><code>LevelTriggered</code>：简称 LT。当 <code>FD</code> 有数据可读时，会重复通知多次，直至数据处理完成。是 <code>epoll</code> 的默认模式。</li><li><code>EdgeTriggered</code>：简称 ET。当 <code>FD</code> 有数据可读时，只会被通知一次，不管数据是否处理完成。<ul><li>ET 模式避免了 LT 模式可能出现的惊群现象。</li><li>ET 模式最好结合非阻塞 IO 读取 FD 数据，相比 LT 会复杂一些。</li></ul></li></ul><p>例子见视频 <code>P167</code>。</p></li></ul><h6 id="web服务流程"><a href="#web服务流程" class="headerlink" title="web服务流程"></a>web服务流程</h6><ul><li>基于 <code>epoll</code> 模式的 web 服务的基本流程如图：</li></ul><h4 id="3-2-5-信号驱动IO"><a href="#3-2-5-信号驱动IO" class="headerlink" title="3.2.5 信号驱动IO"></a>3.2.5 信号驱动IO</h4><ul><li><p>信号驱动 IO 是与内核建立 <code>SIGIO</code> 的信号关联并设置回调，当内核有 <code>FD</code> 就绪时，会发出 <code>SIGIO</code> 信号通知用户，期间用户应用可以执行其他业务，无需阻塞等待（相比于非阻塞 IO，这是真正的 “非阻塞”）。</p><ul><li>缺点：</li><li>当有大量 IO 操作时，信号较多，<code>SIGIO</code> 处理函数不能及时处理可能导致信号队列溢出。而且内核空间与用户空间的频繁信号交互性能也较低。</li></ul></li></ul><h4 id="3-2-6-异步IO"><a href="#3-2-6-异步IO" class="headerlink" title="3.2.6 异步IO"></a>3.2.6 异步IO</h4><ul><li><p>异步 IO 的整个过程都是非阻塞的，用户进程调用完异步 API 后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。</p><p>可以看到，异步 IO 模型中，用户进程在两个阶段都是非阻塞状态。</p><ul><li><p>缺点：</p><ul><li><p>因为进程不阻塞，所以进程会一直接收用户请求，然后进程会一直调用异步 API 请求内核准备数据，而 IO 读写速度一般是比较慢的，所以就会导致内核积累的任务量越来越多。</p><ul><li><p>所以如果采用异步 IO，要做好并发限流机制，那实现起来的复杂度就会提高。</p><p>而 <strong>IO 多路复用既保证了一定的并发性，也不会对内核造成太大压力，实现复杂度也相对低</strong>，所以 IO 多路复用用的多，而异步 IO 用的少。</p></li></ul></li></ul></li></ul></li></ul><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul><li>IO 操作分为同步和异步，而 <strong>IO 操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的 IO 操作），也就是二阶段是同步还是异步</strong>。</li></ul><h4 id="3-2-7-★★★Redis网络模型"><a href="#3-2-7-★★★Redis网络模型" class="headerlink" title="3.2.7 ★★★Redis网络模型"></a>3.2.7 ★★★Redis网络模型</h4><ul><li><p><strong>Redis 到底是单线程还是多线程？</strong></p><ul><li><strong>如果仅仅聊 Redis 的核心业务部分（命令处理），答案是单线程。</strong></li><li><strong>如果是聊整个 Redis，那么答案就是多线程。</strong></li></ul><p>在 Redis 版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令 <code>unlink</code></li><li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对于多核 CPU 的利用率</li></ul></li><li><p><strong>为什么 Redis 要选择单线程</strong>？</p><ul><li>抛开持久化不谈，Redis 是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销。</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣。</li></ul><p>总结就是：收益不高，成本不低。</p></li><li><p>Redis 通过 IO 多路复用来提高网络性能，并且<strong>支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库 API 库</strong> AE。</p></li></ul><h5 id="Redis单线程网络模型流程"><a href="#Redis单线程网络模型流程" class="headerlink" title="Redis单线程网络模型流程"></a>Redis单线程网络模型流程</h5><ul><li><p>结合视频 <code>P171</code> 看。</p></li><li><p>简单来说，Redis <strong>单线程网络模型</strong>的核心就是 <strong>IO 多路复用 + 事件派发</strong>。</p><ul><li>通过 IO 多路复用来监听已经就绪的 <code>FD</code>，对就绪的 <code>FD</code> 进行处理，提高了网络性能。</li><li>通过事件派发来将不同的事件派发给不同的处理器：<ul><li><strong><code>client socket</code> 的注册派发给 <code>server socket</code> 的读处理器 <code>acceptTcpHandler</code>。</strong></li><li><strong>用户发送的请求派发给 <code>client socket</code> 的读处理器 <code>readQueryFromClient</code>。</strong></li><li><strong>请求处理的结果派发给 <code>client socket</code> 的写处理器 <code>sendReplyToClient</code>。</strong></li></ul></li></ul></li><li><p>Redis 6.0 版本中引入了多线程，目的是为了提高 IO 读写效率。因此<strong>在解析客户端命令、写响应结果时采用了多线程</strong>。<strong>核心的命令执行、IO 多路复用模块依然是由主线程执行</strong>。</p></li></ul><h3 id="3-3-通信协议"><a href="#3-3-通信协议" class="headerlink" title="3.3 通信协议"></a>3.3 通信协议</h3><h4 id="3-3-1-RESP协议"><a href="#3-3-1-RESP协议" class="headerlink" title="3.3.1 RESP协议"></a>3.3.1 RESP协议</h4><ul><li><p>Redis 是一个 C/S 架构的软件，通信一般分两步：</p><ol><li>客户端（client）向服务端（server）发送一条命令。（客户端 –请求–&gt; 服务端）</li><li>服务端解析并执行命令，返回响应结果给客户端。（服务端 –响应–&gt; 客户端）</li></ol><p>因此<strong>客户端发送命令的格式、服务端响应结果的格式必须有一个规范</strong>，这个规范就是通信协议。</p><ul><li><p>而在 Redis 中采用的是 <code>RESP(Redis Serialization Protocol)</code> 协议：</p><ul><li>Redis 1.2 版本引入了 RESP 协议。</li><li>Redis 2.0 版本中成为与 Redis 服务端通信的标准，称为 RESP2。</li><li>Redis 6.0 版本中，从 RESP2 升级到了 RESP3 协议，增加了更多数据类型并且支持 6.0 的新特性 – 客户端缓存。</li></ul><p>由于 RESP3 的兼容性问题，目前，默认使用的依然是 RESP2 协议，也是我们要学习的协议版本（以下简称 RESP )。</p></li></ul></li></ul><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li><p>在 RESP 中，通过首字节的字符来区分不同数据类型，常用的数据类型包括 5 种：</p><ul><li><p><strong>单行字符串</strong>：首字节是 <code>+</code></p></li><li><p><strong>错误 Errors</strong>：首字节是 <code>-</code></p></li><li><p><strong>数值</strong>：首字节是 <code>:</code></p></li><li><p><strong>多行字符串</strong>：首字节是 <code>$</code></p></li><li><p><strong>数组</strong>：首字节是 <code>*</code></p></li><li><p>一般来说，<strong>客户端给服务端发送的请求，一般都是数组类型</strong>。</p><p><strong>服务端给客户端发送的响应，就可能为以上五种数据类型</strong>。</p></li></ul></li></ul><h3 id="3-4-★★★内存策略"><a href="#3-4-★★★内存策略" class="headerlink" title="3.4 ★★★内存策略"></a>3.4 ★★★内存策略</h3><ul><li><p>Redis 之所以性能强，最主要的原因就是基于内存存储。然而单节点的 Redis 其内存大小不宜过大，会影响持久化或主从同步性能。</p><ul><li><p>我们可以通过修改配置文件来设置 Redis 的最大内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#格式：</span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line">#例如：</span><br><span class="line">maxmemory 1gb</span><br></pre></td></tr></table></figure><p>当内存使用达到上限时，就无法存储更多数据了。如果这样的话，当内存达到使用上限后，我们再向其中存数据，不是存不进去了？</p><ul><li>所以 Redis 有自己的内存策略来释放内存。</li></ul></li></ul></li></ul><h4 id="3-4-1-过期key处理-内存过期策略"><a href="#3-4-1-过期key处理-内存过期策略" class="headerlink" title="3.4.1 过期key处理(内存过期策略)"></a>3.4.1 过期key处理(内存过期策略)</h4><ul><li>在学习 Redis 缓存的时候我们说过，可以通过 <code>expire</code> 命令给 Redis 的 key 设置 <code>TTL</code>（存活时间），当 key 的 <code>TTL</code> 到期以后，再次访问 <code>name</code> 返回的是 <code>nil</code>，说明这个 key 已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。<ul><li>这里有两个问题需要我们思考：<ul><li><strong>Redis 是如何知道一个 key 是否过期呢？</strong><ul><li><strong>利用两个 <code>Dict</code> 分别记录 <code>key-value</code> 以及 <code>key-TTL</code> 。</strong></li></ul></li><li><strong>是不是 <code>TTL</code> 到期就立即删除了呢？</strong><ul><li><strong>惰性删除</strong></li><li><strong>周期删除</strong></li></ul></li></ul></li></ul></li></ul><h5 id="Redis的DB结构"><a href="#Redis的DB结构" class="headerlink" title="Redis的DB结构"></a>Redis的DB结构</h5><ul><li>Redis 本身是一个典型的 <strong><code>key-value</code> 内存存储数据库</strong>，因此所有的 key、value 都保存在之前学习过的 <code>Dict</code> 结构中（一共有 16 个这样的 DB：<code>SELECT 0</code> 就是选择第 1 个 DB）。不过在其 database 结构体中，有两个主要的 <code>Dict</code>：一个用来记录 <code>key-value</code>，另一个用来记录 <code>key-TTL</code>。</li></ul><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><ul><li><p>顾名思义，并不是在 <code>TTL</code> 到期后就立刻删除，而是<strong>在访问一个 key 的时候，检查该 key 的存活时间，如果已经过期才执行删除</strong>。</p><ul><li>惰性删除有一个问题：如果 key 已经过期了，但是后面一直没有被访问，那这个过期的 key 就会一直存在，不会被删除，而在极端情况下，如果有大量这样的过期 key 未被删除，就会占用 Redis 大量的内存空间。</li></ul></li></ul><h5 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a>周期删除</h5><ul><li><p>顾名思义，通过一个定时任务，<strong>周期性的抽样部分过期的 key，然后执行删除</strong>。执行周期有两种：</p><ul><li><p>Redis 会设置一个定时任务 <code>serverCron()</code> ，按照 <code>server.hz</code> 的频率来执行过期 key 清理，**模式为 <code>SLOW</code>**。</p><ol><li>执行频率受 <code>server.hz</code> 影响，默认为 10，即每秒执行 10 次，每个执行周期 100ms。</li><li>执行清理耗时不超过一次执行周期的 25%。</li><li>逐个遍历 db，逐个遍历 db 中的 bucket，抽取 20 个 key 判断是否过期。</li><li>如果没达到时间上限（25ms）并且过期 key 比例大于 10%，再进行一次抽样，否则结束。</li></ol><p><strong>低频高时长</strong></p></li><li><p>Redis 的每个事件循环前会调用 <code>beforeSleep()</code> 函数，执行过期 key 清理，**模式为 <code>FAST</code>**。</p><ol><li>执行频率受 <code>beforeSleep()</code> 调用频率影响，但两次 <code>FAST</code> 模式间隔不低于 2ms。</li><li>执行清理耗时不超过 1ms。</li><li>逐个遍历 db，逐个遍历 db 中的 bucket，抽取 20 个 key 判断是否过期。</li><li>如果没达到时间上限（1ms）并且过期 key 比例大于10%，再进行一次抽样，否则结束。</li></ol><p><strong>高频低时长</strong></p></li></ul></li></ul><h4 id="3-4-2-内存淘汰策略"><a href="#3-4-2-内存淘汰策略" class="headerlink" title="3.4.2 内存淘汰策略"></a>3.4.2 内存淘汰策略</h4><ul><li><p><strong>内存淘汰</strong>：就是当 Redis 内存使用达到设置的阈值时，<strong>Redis 主动挑选部分 key 删除以释放更多内存</strong>的流程。</p><ul><li><p>这里同样有两个问题需要我们思考：</p><ul><li><p><strong>Redis 什么时候知道内存使用达到了设置的阈值呢？</strong></p><ul><li><strong>Redis 会在每次处理客户端命令的方法 <code>porocessCommand()</code> 时尝试做内存淘汰，在这里判断内存的使用是否达到了设置的阈值。</strong></li></ul></li><li><p><strong>该淘汰哪些 key 呢？</strong></p><ul><li><p><strong>Redis 支持 8 种不同策略来选择要删除的 key。</strong></p><p><code>LRU</code> 和 <code>LFU</code> 的值在哪里知道呢？</p><ul><li><p>还记得 <code>RedisObject</code> 结构体对象吗，就在这里面记录。</p><p>如果采用 <code>LRU</code> 策略，就以秒为单位记录最近一次访问时间，长度 24 bit。</p><p>如果采用 <code>LFU</code> 策略，就高 16 位以分钟为单位记录最近一次访问时间，低 8 位记录<strong>逻辑访问次数</strong>。</p></li></ul></li></ul></li></ul></li></ul></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/03/20/Redis%E5%8E%9F%E7%90%86%E7%AF%87/" title="Redis原理篇">https://running-noob.github.io/2024/03/20/Redis原理篇/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/13/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97Tag/" rel="prev" title="栈与队列Tag"><i class="fa fa-chevron-left"></i> 栈与队列Tag</a></div><div class="post-nav-item"><a href="/2024/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91Tag/" rel="next" title="二叉树Tag">二叉树Tag <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E2%98%85%E5%8E%9F%E7%90%86%E7%AF%87"><span class="nav-text">三、★原理篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="nav-text">3.1.1 动态字符串SDS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-IntSet"><span class="nav-text">3.1.2 IntSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IntSet%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7"><span class="nav-text">IntSet类型自动升级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-Dict"><span class="nav-text">3.1.3 Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="nav-text">渐进式rehash</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-ZipList"><span class="nav-text">3.1.4 ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-text">ZipList的连锁更新问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-QuickList"><span class="nav-text">3.1.5 QuickList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-6-SkipList"><span class="nav-text">3.1.6 SkipList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-RedisObject"><span class="nav-text">3.1.7 RedisObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%853-1-8-%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">★3.1.8 五种数据结构编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-1-String"><span class="nav-text">3.1.8.1 String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-2-List-QuickList"><span class="nav-text">3.1.8.2 List (QuickList)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-3-Set-Dict%E3%80%81IntSet"><span class="nav-text">3.1.8.3 Set (Dict、IntSet)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-4-%E2%98%85ZSet-SkipList-Dict%E3%80%81ZipList"><span class="nav-text">3.1.8.4 ★ZSet (SkipList+Dict、ZipList)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-8-5-Hash-ZipList%E3%80%81Dict"><span class="nav-text">3.1.8.5 Hash (ZipList、Dict)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.2 网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-text">3.2.1 用户空间和内核空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E9%98%BB%E5%A1%9EIO"><span class="nav-text">3.2.2 阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-text">3.2.3 非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E2%98%85%E2%98%85%E2%98%85IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">3.2.4 ★★★IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-1-select"><span class="nav-text">3.2.4.1 select</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-2-poll"><span class="nav-text">3.2.4.2 poll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-3-%E2%98%85epoll"><span class="nav-text">3.2.4.3 ★epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">事件通知机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#web%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-text">web服务流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-text">3.2.5 信号驱动IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-%E5%BC%82%E6%AD%A5IO"><span class="nav-text">3.2.6 异步IO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-text">同步和异步</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-%E2%98%85%E2%98%85%E2%98%85Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.2.7 ★★★Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%B5%81%E7%A8%8B"><span class="nav-text">Redis单线程网络模型流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-text">3.3 通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-RESP%E5%8D%8F%E8%AE%AE"><span class="nav-text">3.3.1 RESP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E2%98%85%E2%98%85%E2%98%85%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-text">3.4 ★★★内存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E8%BF%87%E6%9C%9Fkey%E5%A4%84%E7%90%86-%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-text">3.4.1 过期key处理(内存过期策略)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%E7%9A%84DB%E7%BB%93%E6%9E%84"><span class="nav-text">Redis的DB结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-text">周期删除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">3.4.2 内存淘汰策略</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">248</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">475k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:49</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
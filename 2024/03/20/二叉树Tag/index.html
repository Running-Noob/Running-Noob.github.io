<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="二叉树理论基础  二叉树的种类 二叉树的遍历方式 二叉树的定义  ……"><meta property="og:type" content="article"><meta property="og:title" content="二叉树Tag"><meta property="og:url" content="https://running-noob.github.io/2024/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91Tag/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="二叉树理论基础  二叉树的种类 二叉树的遍历方式 二叉树的定义  ……"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png"><meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"><meta property="og:image" content="https://pic.leetcode.cn/1698026966-JDYPDU-image.png"><meta property="og:image" content="https://pic.leetcode.cn/1698027008-nPFLbM-image.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155515650.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151702443.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000824.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"><meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif"><meta property="article:published_time" content="2024-03-20T13:12:59.000Z"><meta property="article:modified_time" content="2024-04-29T13:25:37.829Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png"><link rel="canonical" href="https://running-noob.github.io/2024/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91Tag/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>二叉树Tag | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">244</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91Tag/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">二叉树Tag</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-20 21:12:59" itemprop="dateCreated datePublished" datetime="2024-03-20T21:12:59+08:00">2024-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-29 21:25:37" itemprop="dateModified" datetime="2024-04-29T21:25:37+08:00">2024-04-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LeetCode刷题笔记</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li><p>二叉树理论基础</p><ul><li>二叉树的种类</li><li>二叉树的遍历方式</li><li>二叉树的定义</li></ul><p>……</p></li></ul></blockquote><span id="more"></span><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树理论基础篇"><a href="#二叉树理论基础篇" class="headerlink" title="二叉树理论基础篇"></a>二叉树理论基础篇</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><ul><li><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><ul><li><p>满二叉树：如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="img"></p></li><li><p>完全二叉树的定义如下：在完全二叉树中，除了最底层结点可能没填满外，其余每层结点数都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个结点。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="img"></p></li></ul></li><li><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img"></p></li><li><p>平衡二叉搜索树：又被称为 AVL 树，且具有以下性质：它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过 1</strong>，并且左右两个子树都是一棵平衡二叉树。如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="img"></p></li></ul><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><ul><li>二叉树主要有两种遍历方式：<ul><li>深度优先遍历：先往深走，遇到叶子结点再往回走。<ul><li><strong>前序遍历</strong>（递归法，迭代法）</li><li><strong>中序遍历</strong>（递归法，迭代法）</li><li><strong>后序遍历</strong>（递归法，迭代法）</li></ul></li><li>广度优先遍历：一层一层的去遍历。<ul><li><strong>层次遍历</strong>（迭代法）</li></ul></li></ul></li><li>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，<strong>经常会使用递归的方式来实现深度优先遍历</strong>，也就是实现前中后序遍历，使用递归是比较方便的。<ul><li>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以<strong>借助栈使用递归的方式</strong>来实现的。</li><li>而广度优先遍历的实现一般使用<strong>队列</strong>来实现</li></ul></li></ul><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() {}</span><br><span class="line">    TreeNode(<span class="type">int</span> val) { <span class="built_in">this</span>.val = val; }</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="1-二叉树的递归遍历"><a href="#1-二叉树的递归遍历" class="headerlink" title="1.二叉树的递归遍历"></a>1.二叉树的递归遍历</h3><h4 id="★递归三部曲"><a href="#★递归三部曲" class="headerlink" title="★递归三部曲"></a>★递归三部曲</h4><ul><li><p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p><strong>递归算法的时间复杂度</strong>本质上是要看: <strong>递归的次数 * 每次递归中的操作次数</strong>。</p></li><li><p>前序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 前序遍历：中左右</span></span><br><span class="line">        result.add(root.val);</span><br><span class="line">        result = preorderTraversal(root.left);</span><br><span class="line">        result = preorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 中序遍历：左中右</span></span><br><span class="line">        result = inorderTraversal(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        result = inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 后序遍历：左右中</span></span><br><span class="line">        result = postorderTraversal(root.left);</span><br><span class="line">        result = postorderTraversal(root.right);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-二叉树的迭代遍历-栈"><a href="#2-二叉树的迭代遍历-栈" class="headerlink" title="2.二叉树的迭代遍历(栈)"></a>2.二叉树的迭代遍历(栈)</h3><ul><li><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。那用栈也是可以实现二叉树的前中后序遍历的。</p></li><li><p>前序遍历：</p><ul><li><p>先看一下前序遍历。</p><ul><li>前序遍历是中左右，每次先处理的是中间结点，那么先将根结点放入栈中，然后将右孩子加入栈，再加入左孩子。</li><li>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="二叉树前序遍历（迭代法）"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 如果root为null，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="comment">// 根结点先出栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 先压栈右结点，再压栈左结点，才能保证前序遍历的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：</p><ul><li>中序遍历的逻辑和前序遍历不同，在前序遍历中，先访问的元素是中间结点，要处理的元素也是中间结点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间结点。</strong><ul><li>中序遍历是左中右，先访问的是二叉树顶部的结点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理结点（也就是在把结点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></li></ul></li><li>我们可以这样做：<ul><li>先把根结点入栈，然后每次结点出栈的时候，如果是第一次出栈，则按照<strong>右结点、当前结点、左结点</strong>的顺序入栈，如果是第二次出栈，则输出。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于查看结点是否是第一次出栈</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 先排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(node)) { <span class="comment">// 结点是第一次出栈</span></span><br><span class="line">                temp.add(node);</span><br><span class="line">                <span class="comment">// 如果结点是第一次出栈，就按照node.right，node，node.left的顺序入栈</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                deque.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 结点是第二次出栈</span></span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：</p><ul><li>后序遍历和中序遍历大同小异，它的处理顺序和访问顺序也是不一致的。</li><li>我们可以这样做：<ul><li>先把根结点入栈，然后每次结点出栈的时候，如果是第一次出栈，则按照<strong>当前结点、右结点、左结点</strong>的顺序入栈，如果是第二次出栈，则输出。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于查看结点是否是第一次出栈</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 先排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(node)) { <span class="comment">// 结点是第一次出栈</span></span><br><span class="line">                temp.add(node);</span><br><span class="line">                <span class="comment">// 如果结点是第一次出栈，就按照node，node.right，node.left的顺序入栈</span></span><br><span class="line">                deque.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 结点是第二次出栈</span></span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>还有第二种解法：</p><ul><li><p>后序遍历是：左右中；前序遍历是：中左右。</p><ul><li><p>那我们可以按前序遍历的解法，先把 <code>result</code> 中的顺序调整为 “中右左”，然后再把 result 反转就变为了 “左右中”。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png" alt="前序到后序"></p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 先排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li>可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。<ul><li><strong>这是因为前序遍历中访问结点（遍历结点）和处理结点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></li></ul></li></ul></li></ul><h3 id="3-二叉树的统一迭代法"><a href="#3-二叉树的统一迭代法" class="headerlink" title="3.二叉树的统一迭代法"></a>3.二叉树的统一迭代法</h3><ul><li><p>二叉树的统一迭代法就在于判断当前弹栈元素是不是第一次弹栈，如果是第一次弹栈，就要进行相应的再压栈处理，否则就输出到结果集中。</p></li><li><p>可以看到前中后序遍历的实现代码都可以是大同小异的：</p><ul><li><p>前序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于查看结点是否是第一次出栈</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 先排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(node)) { <span class="comment">// 结点是第一次出栈</span></span><br><span class="line">                temp.add(node);</span><br><span class="line">                <span class="comment">// 如果结点是第一次出栈，就按照node.right，node.left，node的顺序入栈</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.left);</span><br><span class="line">                }</span><br><span class="line">                deque.push(node);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 结点是第二次出栈</span></span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于查看结点是否是第一次出栈</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 先排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(node)) { <span class="comment">// 结点是第一次出栈</span></span><br><span class="line">                temp.add(node);</span><br><span class="line">                <span class="comment">// 如果结点是第一次出栈，就按照node.right，node，node.left的顺序入栈</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                deque.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 结点是第二次出栈</span></span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于查看结点是否是第一次出栈</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 先排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (!temp.contains(node)) { <span class="comment">// 结点是第一次出栈</span></span><br><span class="line">                temp.add(node);</span><br><span class="line">                <span class="comment">// 如果结点是第一次出栈，就按照node，node.right，node.left的顺序入栈</span></span><br><span class="line">                deque.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 结点是第二次出栈</span></span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-二叉树的层序遍历-队列"><a href="#4-二叉树的层序遍历-队列" class="headerlink" title="4.二叉树的层序遍历(队列)"></a>4.二叉树的层序遍历(队列)</h3><ul><li><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><ul><li>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></li></ul></li></ul><h4 id="层序遍历的万用模板"><a href="#层序遍历的万用模板" class="headerlink" title="层序遍历的万用模板"></a>层序遍历的万用模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 辅助队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 保存每一层的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size(); <span class="comment">// 用于判断当前层是不是遍历完了</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                itemList.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line">            result.add(itemList);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="4-1-二叉树的层次遍历II"><a href="#4-1-二叉树的层次遍历II" class="headerlink" title="4.1 二叉树的层次遍历II"></a>4.1 二叉树的层次遍历II</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给你二叉树的根结点 <code>root</code> ，返回其结点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子结点所在层到根结点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>就是在 <code>4.二叉树的层序遍历</code> 的基础上，增加一个 <code>Collections.reverse()</code> 方法而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                itemList.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.add(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.add(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line">            result.add(itemList);</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-二叉树的右视图"><a href="#4-2-二叉树的右视图" class="headerlink" title="4.2 二叉树的右视图"></a>4.2 二叉树的右视图</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个二叉树的 <strong>根结点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的结点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的结点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></li></ul><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ul><li><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进 result 数组中，随后返回 result 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size(); <span class="comment">// 记录当前层级的元素个数</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) { <span class="comment">// len为0表示是当前层级的最后一个元素</span></span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-二叉树的层平均值"><a href="#4-3-二叉树的层平均值" class="headerlink" title="4.3 二叉树的层平均值"></a>4.3 二叉树的层平均值</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个非空二叉树的根结点 <code>root</code> , 以数组的形式返回每一层结点的平均值。与实际答案相差 <code>10^(-5)</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数量在 <code>[1, 104]</code> 范围内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul></li></ul><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><ul><li><p>本题就是层序遍历的时候把一层求个总和在取一个均值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size(); <span class="comment">// 用于判断当前层级是否遍历完</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> len; <span class="comment">// 用于计算平均数</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于计算当前层的总和</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line">            result.add(sum / num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-N叉树的层序遍历"><a href="#4-4-N叉树的层序遍历" class="headerlink" title="4.4 N叉树的层序遍历"></a>4.4 N叉树的层序遍历</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个 N 叉树，返回其结点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子结点都由 null 值分隔（参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的结点总数在 <code>[0, 10^4]</code> 之间</li></ul></li></ul><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><ul><li><p>这道题依旧是模板题，只不过一个结点有多个孩子了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;Node&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                itemList.add(node.val);</span><br><span class="line">                List&lt;Node&gt; children = node.children;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.size(); i++) {</span><br><span class="line">                    deque.addLast(children.get(i));</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line">            result.add(itemList);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-5-在每个树行中找最大值"><a href="#4-5-在每个树行中找最大值" class="headerlink" title="4.5 在每个树行中找最大值"></a>4.5 在每个树行中找最大值</h4><h5 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一棵二叉树的根结点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,2,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>二叉树的结点个数的范围是 <code>[0,104]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul></li></ul><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><ul><li><p>层序遍历，取每一层的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size(); <span class="comment">// 用于判断当前层是否遍历完</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                <span class="keyword">if</span> (node.val &gt; max) {</span><br><span class="line">                    max = node.val;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line">            result.add(max);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-6-填充每个结点的下一个右侧结点指针II"><a href="#4-6-填充每个结点的下一个右侧结点指针II" class="headerlink" title="4.6 填充每个结点的下一个右侧结点指针II"></a>4.6 填充每个结点的下一个右侧结点指针II</h4><h5 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node {</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧结点。如果找不到下一个右侧结点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧结点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的结点数在范围 <code>[0, 6000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></li></ul><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><ul><li><p>依然套用层序遍历的模板，只不过要注意当 len 为 0 时，要让当前出队的结点的 next 指向 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> {</span><br><span class="line">        ArrayDeque&lt;Node&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (n1.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(n1.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (n1.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(n1.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">                    n1.next = <span class="literal">null</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    n1.next = n2;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-7-二叉树的最大深度"><a href="#4-7-二叉树的最大深度" class="headerlink" title="4.7 二叉树的最大深度"></a>4.7 二叉树的最大深度</h4><h5 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根结点到最远叶子结点的最长路径上的结点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点的数量在 <code>[0, 10^4]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></li></ul><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><ul><li><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p><ul><li>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">                    result += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> getDepth(root, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> {</span><br><span class="line">        <span class="type">int</span> leftDepth, rightDepth;</span><br><span class="line">        leftDepth = rightDepth = depth;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">            leftDepth = getDepth(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">            rightDepth = getDepth(node.right, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-8-二叉树的最小深度"><a href="#4-8-二叉树的最小深度" class="headerlink" title="4.8 二叉树的最小深度"></a>4.8 二叉树的最小深度</h4><h5 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h5><ul><li><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根结点到最近叶子结点的最短路径上的结点数量。</p><p><strong>说明：</strong>叶子结点是指没有子结点的结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></li></ul><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><ul><li><p>相对于 <code>4.7 二叉树的最大深度</code>，本题还也可以使用层序遍历的方式来解决，思路是一样的。</p><ul><li><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                <span class="comment">// 左右子结点都为空，表示已经到最小深度处了</span></span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    deque.addLast(node.right);</span><br><span class="line">                }</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">                    result++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        getDepth(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">            result = Math.min(result, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) {</span><br><span class="line">            getDepth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) {</span><br><span class="line">            getDepth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-翻转二叉树"><a href="#5-翻转二叉树" class="headerlink" title="5.翻转二叉树"></a>5.翻转二叉树</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一棵二叉树的根结点 <code>root</code> ，翻转这棵二叉树，并返回其根结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></li></ul><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li><p>想要翻转二叉树，其实就把每一个结点的左右孩子交换一下就可以了。遍历的过程中去翻转每一个结点的左右孩子就可以达到整体翻转的效果。</p><ul><li>关键在于遍历顺序，前中后序或层序应该选哪一种遍历顺序？</li><li><strong>这道题目使用前序遍历、后序遍历、层序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些结点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong>。</li></ul><p>我这里用的是层序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 用于判断树是否遍历完了</span></span><br><span class="line">        deque.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                left = node.left;</span><br><span class="line">                deque.addLast(left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                right = node.right;</span><br><span class="line">                deque.addLast(right);</span><br><span class="line">            }</span><br><span class="line">            node.left = right;</span><br><span class="line">            node.right = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>用递归也能做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 递归三要素：</span></span><br><span class="line">        <span class="comment">//  1.确定传入的参数和返回值</span></span><br><span class="line">        <span class="comment">//  2.确定递归终止条件</span></span><br><span class="line">        <span class="comment">//  3.确定单层业务逻辑</span></span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这里用的是后序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>但是递归比较玄学，我还是喜欢用迭代。</li></ul></li></ul></li></ul><h3 id="6-对称二叉树"><a href="#6-对称二叉树" class="headerlink" title="6.对称二叉树"></a>6.对称二叉树</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个二叉树的根结点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p></li></ul><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ul><li><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个结点，要比较的可不是父结点的左右子结点！</strong></p><p>对于二叉树是否对称，要比较的是根结点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根结点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><ul><li><p>因此我们要通过递归函数的返回值来判断两个子树的<strong>内侧结点</strong>和<strong>外侧结点</strong>是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode leftNode, TreeNode rightNode)</span> {</span><br><span class="line">        <span class="comment">// 1.确定传入参数和返回值</span></span><br><span class="line">        <span class="comment">// 2.确定递归终止的条件</span></span><br><span class="line">        <span class="comment">// 3.确定单次递归的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode.val != rightNode.val) { <span class="comment">// 左右两个结点都不为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 左右两个结点都不为空且值相等</span></span><br><span class="line">            <span class="type">boolean</span> compareIn, compareOut;</span><br><span class="line">            compareIn = compare(leftNode.right, rightNode.left); <span class="comment">// 比较内侧</span></span><br><span class="line">            compareOut = compare(leftNode.left, rightNode.right); <span class="comment">// 比较外侧</span></span><br><span class="line">            <span class="keyword">return</span> compareIn &amp;&amp; compareOut;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这题也可以用迭代来做。</p><ul><li><p>可以考虑用层序遍历的思想来做，对每一层都判断其是否对称，遍历到其中一层不对称就结束循环，或者直到遍历完整棵树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (leftNode.val != rightNode.val) { <span class="comment">// 两个结点都不为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 两个结点都不为空且值相同</span></span><br><span class="line">                <span class="comment">// 外侧结点</span></span><br><span class="line">                queue.offer(leftNode.left);</span><br><span class="line">                queue.offer(rightNode.right);</span><br><span class="line">                <span class="comment">// 内侧结点</span></span><br><span class="line">                queue.offer(leftNode.right);</span><br><span class="line">                queue.offer(rightNode.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7-平衡二叉树"><a href="#7-平衡二叉树" class="headerlink" title="7.平衡二叉树"></a>7.平衡二叉树</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个二叉树，判断它是否是平衡二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的结点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></li></ul><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li><p>这里强调一波概念：</p><ul><li><strong>二叉树结点的深度</strong>：指从根结点到该结点的最长简单路径边的条数。</li><li><strong>二叉树结点的高度</strong>：指从该结点到叶子结点的最长简单路径边的条数。</li></ul><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155515650.png" alt="110.平衡二叉树2"></p><ul><li><p>因为<strong>求深度</strong>可以<strong>从上到下去查</strong>，所以需要前序遍历（中左右）</p><p>而<strong>求高度</strong>只能<strong>从下到上去查</strong>，所以只能后序遍历（左右中）</p></li></ul></li><li><p>递归三步曲分析：</p><ol><li><p>明确递归函数的参数和返回值</p><ul><li><p>参数：当前传入结点、当前传入结点的深度。返回值：以当前传入结点为根结点的树的深度。</p><p>那么如何标记左右子树是否差值大于 1 呢？</p><p><strong>如果当前传入结点为根结点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了</strong>。</p><p><strong>所以如果已经不是二叉平衡树了，可以返回 -1 来标记已经不符合平衡树的规则了</strong>。</p></li></ul></li><li><p>明确终止条件</p><ul><li>递归的过程中如果左右子结点都为 null，表示当前结点是叶子结点，就返回当前结点的深度。</li></ul></li><li><p>明确单层递归的逻辑</p><ul><li><p>如何判断以当前传入结点为根结点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于 1，则返回当前二叉树的高度，否则返回 -1，表示已经不是二叉平衡树了。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> getDepth(root, <span class="number">1</span>) != -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> {</span><br><span class="line">        <span class="type">int</span> leftDepth, rightDepth;</span><br><span class="line">        leftDepth = rightDepth = depth;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">            leftDepth = getDepth(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">            rightDepth = getDepth(node.right, depth + <span class="number">1</span>);   </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &gt; <span class="number">1</span>) { <span class="comment">// 用-1表示已经不是平衡二叉树了</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-二叉树的所有路径"><a href="#8-二叉树的所有路径" class="headerlink" title="8.二叉树的所有路径"></a>8.二叉树的所有路径</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个二叉树的根结点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根结点到叶子结点的路径。</p><p><strong>叶子结点</strong> 是指没有子结点的结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：["1-&gt;2-&gt;5","1-&gt;3"]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：["1"]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></li></ul><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul><li><p>这道题目要求从根结点到叶子的路径，所以需要前序遍历，这样才方便让父结点指向孩子结点，找到对应的路径。</p><p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</p><p>前序遍历以及回溯的过程如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151702443.png" alt="257.二叉树的所有路径"></p><p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 递归三步走：</span></span><br><span class="line"> <span class="comment">// 1.确定传入的参数和返回的值</span></span><br><span class="line"> <span class="comment">// 2.确定递归终止的条件</span></span><br><span class="line"> <span class="comment">// 3.确定递归的单层逻辑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// path用于记录当前已经走过的结点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        searchTreePath(root, path);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历来遍历路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchTreePath</span><span class="params">(TreeNode node, List&lt;Integer&gt; path)</span> {</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size() - <span class="number">1</span>; i++) {</span><br><span class="line">                sb.append(path.get(i)).append(<span class="string">"-&gt;"</span>);</span><br><span class="line">            }</span><br><span class="line">            sb.append(path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">            searchTreePath(node.left, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">            searchTreePath(node.right, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>迭代法也可以做，但是明显性能不如递归+回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        Deque&lt;Object&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结点和路径同时入栈</span></span><br><span class="line">        deque.push(root);</span><br><span class="line">        deque.push(root.val + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="comment">// 结点和路径同时出栈</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String) deque.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode) deque.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">                result.add(path);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.left);</span><br><span class="line">                deque.push(path + <span class="string">"-&gt;"</span> + node.left.val);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                deque.push(node.right);</span><br><span class="line">                deque.push(path + <span class="string">"-&gt;"</span> + node.right.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>注意这里<strong>结点和路径同时入栈出栈</strong>。</li></ul></li></ul><h3 id="9-二叉搜索树中的搜索"><a href="#9-二叉搜索树中的搜索" class="headerlink" title="9.二叉搜索树中的搜索"></a>9.二叉搜索树中的搜索</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定二叉搜索树（BST）的根结点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到结点值等于 <code>val</code> 的结点。 返回以该结点为根的子树。 如果结点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul></li></ul><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li><p>根据二叉搜索树的特性解题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (node.val == val) {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node = node.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-验证二叉搜索树"><a href="#10-验证二叉搜索树" class="headerlink" title="10.验证二叉搜索树"></a>10.验证二叉搜索树</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个二叉树的根结点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>结点的左子树只包含 <strong>小于</strong> 当前结点的数。</li><li>结点的右子树只包含 <strong>大于</strong> 当前结点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根结点的值是 5 ，但是右子结点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数目范围在<code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul></li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ul><li><p><strong>中序遍历下，输出的二叉搜索树结点的数值是有序序列</strong>。有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p><ul><li>可以递归中序遍历将二叉搜索树转变成一个数组，然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) &gt;= list.get(i + <span class="number">1</span>)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        inOrderTraversal(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inOrderTraversal(node.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>这题也可以用递归来做：</p><ul><li><p>这道题目比较容易陷入一个陷阱：</p><p><strong>不能单纯的比较左结点小于中间结点，右结点大于中间结点就完事了</strong>。然后写出这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>我们要比较的是 左子树所有结点小于中间结点，右子树所有结点大于中间结点</strong>。所以以上代码的判断逻辑是错误的。例如： <code>[10,5,15,null,null,6,20]</code> 这个 case，结点 10 大于左结点 5，小于右结点 15，但右子树里出现了一个 6，这就不符合了：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000824.png" alt="二叉搜索树"></p></li></ul><p>正确的递归代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MAX_VALUE, Long.MIN_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> upper, <span class="type">long</span> low)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.val &gt;= upper || node.val &lt;= low) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 左子树所有结点小于中间结点，右子树所有结点大于中间结点</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, node.val, low) &amp;&amp; isValidBST(node.right, upper, node.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-二叉搜索树中的插入操作"><a href="#11-二叉搜索树中的插入操作" class="headerlink" title="11.二叉搜索树中的插入操作"></a>11.二叉搜索树中的插入操作</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定二叉搜索树（BST）的根结点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根结点。 输入数据 <strong>保证</strong> 新值和原始二叉搜索树中的任意结点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的结点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-10^8 &lt;= Node.val &lt;= 10^8</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li><strong>保证</strong> <code>val</code> 在原始 BST 中不存在。</li></ul></li></ul><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ul><li><p>就是利用搜索树的特性，找到要插入的地方，当然别忘了记录父结点的位置，否则无法实现插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        TreeNode node, parent; <span class="comment">// parent用于记录node的上一个位置</span></span><br><span class="line">        parent = node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            parent = node;</span><br><span class="line">            <span class="keyword">if</span> (node.val &lt; val) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (parent.val &lt; val) {</span><br><span class="line">            parent.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (parent.val &gt; val) {</span><br><span class="line">            parent.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) {</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) {</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-二叉搜索树中的删除操作"><a href="#12-二叉搜索树中的删除操作" class="headerlink" title="12.二叉搜索树中的删除操作"></a>12.二叉搜索树中的删除操作</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个二叉搜索树的根结点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的结点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根结点的引用。</p><p>一般来说，删除结点可分为两个步骤：</p><ol><li>首先找到需要删除的结点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的结点值是 3，所以我们首先找到 3 这个结点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7],</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的结点</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>结点数的范围 <code>[0, 104]</code>.</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li>结点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-10^5 &lt;= key &lt;= 10^5</code></li></ul></li></ul><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ul><li><p>递归三部曲：</p><ul><li><p><strong>确定递归函数参数以及返回值</strong>：通过递归返回值删除结点。</p></li><li><p><strong>确定终止条件</strong>：遇到空返回，其实这也说明没找到删除的结点，遍历到空结点直接返回了</p></li><li><p><strong>确定单层递归的逻辑</strong>：这里就需要把二叉搜索树中删除结点遇到的情况都搞清楚。有以下五种情况：</p><ul><li><p>第一种情况：没找到删除的结点，遍历到空结点直接返回了</p></li><li><p>找到删除的结点</p><ul><li><p>第二种情况：左右孩子都为空（叶子结点），直接删除结点， 返回 NULL 为根结点</p></li><li><p>第三种情况：删除结点的左孩子为空，右孩子不为空，删除结点，右孩子补位，返回右孩子为根结点</p></li><li><p>第四种情况：删除结点的右孩子为空，左孩子不为空，删除结点，左孩子补位，返回左孩子为根结点</p></li><li><p>第五种情况：左右孩子结点都不为空，则将删除结点的左子树头结点（左孩子）放到删除结点的右子树的最左面结点的左孩子上，返回删除结点右孩子为新的根结点。</p><ul><li><p>第五种情况有点难以理解，看下面动画：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="450.删除二叉搜索树中的结点"></p></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="comment">// 情况1：要删除的结点不存在</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) { <span class="comment">// 找到要删除的结点</span></span><br><span class="line">            <span class="comment">// 情况2：要删除的结点为叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 情况3：要删除的结点的左子树为null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 情况4：要删除的结点的右子树为null</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 情况5：要删除的结点的左右子树都不为null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) {</span><br><span class="line">                TreeNode node, parent;</span><br><span class="line">                parent = node = root.right;</span><br><span class="line">                <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                    parent = node;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                }</span><br><span class="line">                parent.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key){</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>二叉搜索树删除结点比增加结点复杂的多。<strong>因为二叉搜索树添加结点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除结点操作涉及到结构的调整。</strong></p></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/03/20/%E4%BA%8C%E5%8F%89%E6%A0%91Tag/" title="二叉树Tag">https://running-noob.github.io/2024/03/20/二叉树Tag/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/20/Redis%E5%8E%9F%E7%90%86%E7%AF%87/" rel="prev" title="Redis原理篇"><i class="fa fa-chevron-left"></i> Redis原理篇</a></div><div class="post-nav-item"><a href="/2024/03/27/RabbitMQ%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="next" title="RabbitMQ基础篇">RabbitMQ基础篇 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-text">二叉树理论基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">二叉树的种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">二叉树的遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">二叉树的定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-text">1.二叉树的递归遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-text">★递归三部曲</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86-%E6%A0%88"><span class="nav-text">2.二叉树的迭代遍历(栈)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-text">3.二叉树的统一迭代法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%98%9F%E5%88%97"><span class="nav-text">4.二叉树的层序遍历(队列)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%87%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-text">层序遍历的万用模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II"><span class="nav-text">4.1 二叉树的层次遍历II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">4.2 二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-text">4.3 二叉树的层平均值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">4.4 N叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">4.5 在每个树行中找最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88II"><span class="nav-text">4.6 填充每个结点的下一个右侧结点指针II</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">4.7 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-text">4.8 二叉树的最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-text">思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6.对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">7.平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-text">8.二叉树的所有路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-text">9.二叉搜索树中的搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">10.验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">11.二叉搜索树中的插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">12.二叉搜索树中的删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="nav-text">思路</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">244</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">471k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:32</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="dfs 是往一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。 bfs 是先把本结点所连接的所有结点遍历一遍，走到下一个结点的时候，再把连接结点所连接的所有结点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。"><meta property="og:type" content="article"><meta property="og:title" content="图论Tag"><meta property="og:url" content="https://running-noob.github.io/2024/04/14/%E5%9B%BE%E8%AE%BATag/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="dfs 是往一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。 bfs 是先把本结点所连接的所有结点遍历一遍，走到下一个结点的时候，再把连接结点所连接的所有结点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220726094200.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220727100846.png"><meta property="article:published_time" content="2024-04-14T13:13:28.000Z"><meta property="article:modified_time" content="2024-04-29T13:26:06.389Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg"><link rel="canonical" href="https://running-noob.github.io/2024/04/14/%E5%9B%BE%E8%AE%BATag/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>图论Tag | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">24</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">245</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/04/14/%E5%9B%BE%E8%AE%BATag/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">图论Tag</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-04-14 21:13:28" itemprop="dateCreated datePublished" datetime="2024-04-14T21:13:28+08:00">2024-04-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-29 21:26:06" itemprop="dateModified" datetime="2024-04-29T21:26:06+08:00">2024-04-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LeetCode刷题笔记</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>dfs 是往一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</li><li>bfs 是先把本结点所连接的所有结点遍历一遍，走到下一个结点的时候，再把连接结点所连接的所有结点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul></blockquote><span id="more"></span><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="深度优先搜索理论基础"><a href="#深度优先搜索理论基础" class="headerlink" title="深度优先搜索理论基础"></a>深度优先搜索理论基础</h3><ul><li>dfs 是往一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</li></ul><h4 id="★DFS代码框架（递归-回溯）"><a href="#★DFS代码框架（递归-回溯）" class="headerlink" title="★DFS代码框架（递归+回溯）"></a>★DFS代码框架（递归+回溯）</h4><ul><li><p>因为 dfs 搜索往一个方向，并需要回溯，所以用递归的方式来实现是最方便的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(参数)</span> {</span><br><span class="line">    <span class="keyword">if</span> (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本结点所连接的其他结点) {</span><br><span class="line">        处理结点;</span><br><span class="line">        dfs(图，选择的结点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>可以发现 dfs 的代码框架和回溯算法的代码框架是差不多的。</li></ul></li><li><p>深搜三部曲如下：</p><ol><li><p><strong>确认递归函数，参数</strong>。</p><p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。一般情况，深搜需要 <strong>二维数组结构保存所有路径，需要一维数组保存单一路径</strong>，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。例如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 保存符合条件的所有路径</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; path; <span class="comment">// 起点到终点的路径</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span> <span class="params">(图，目前搜索的结点)</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong>确认终止条件</strong>。</p><p>终止条件很重要，很多同学写 dfs 的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。</p><p>终止不仅是结束本层递归的时候，同时也是我们收获结果的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) {</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p><strong>处理目前搜索结点出发的路径</strong>。</p><p>一般这里就是一个 for 循环的操作，去遍历目前搜索结点所能到的所有结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本结点所连接的其他结点) {</span><br><span class="line">    处理结点;</span><br><span class="line">    dfs(图，选择的结点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="广度优先搜索理论基础"><a href="#广度优先搜索理论基础" class="headerlink" title="广度优先搜索理论基础"></a>广度优先搜索理论基础</h3><ul><li>bfs 是先把本结点所连接的所有结点遍历一遍，走到下一个结点的时候，再把连接结点所连接的所有结点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul><h4 id="★BFS代码框架（队列）"><a href="#★BFS代码框架（队列）" class="headerlink" title="★BFS代码框架（队列）"></a>★BFS代码框架（队列）</h4><ul><li><p>我们需要一个容器，能保存我们要遍历过的元素，<strong>用队列，用栈，甚至用数组，都是可以的</strong>。</p><ul><li><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</li><li><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</li></ul><p>那么广搜需要注意转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以后面都用队列来实现</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(参数)</span> {</span><br><span class="line">    Queue&lt;?&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(结点);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        结点 = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (结点：本结点所连接的其他结点) {</span><br><span class="line">            处理结点;</span><br><span class="line">            queue.offer(结点);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-所有可能的路径"><a href="#1-所有可能的路径" class="headerlink" title="1.所有可能的路径"></a>1.所有可能的路径</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个有 <code>n</code> 个结点的 <strong>有向无环图（DAG）</strong>，请你找出所有从结点 <code>0</code> 到结点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p><code>graph[i]</code> 是一个从结点 <code>i</code> 可以访问的所有结点的列表（即从结点 <code>i</code> 到结点 <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>使用深搜三部曲来分析题目：</p><ol><li><p><strong>确认递归函数，参数</strong>：</p><ul><li>首先我们 dfs 函数一定要存一个图，用来遍历的，还要存一个目前我们遍历的结点，定义为 x。至于单一路径，和路径集合则可以放在全局变量，那么代码是这样的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">List&lt;Integer&gt; path; <span class="comment">// 0结点到终点的路径</span></span><br><span class="line"><span class="comment">// node：目前遍历的结点</span></span><br><span class="line"><span class="comment">// graph：存当前的图</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span> <span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> node)</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>确认终止条件</strong>：</p><ul><li>什么时候我们就找到一条路径了？-&gt; 当目前遍历的结点为最后一个结点的时候，就找到了一条从出发点到终止点的路径。</li><li>当前遍历的结点，我们定义为 node，最后一点结点，就是 <code>graph.size() - 1</code>（因为题目描述是找出所有从结点 0 到结点 n-1 的路径并输出）。所以当 node 等于 <code>graph.size() - 1</code> 的时候就找到一条有效路径。 代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求从结点 0 到结点 n-1 的路径并输出，所以是 graph.size() - 1</span></span><br><span class="line"><span class="keyword">if</span> (node == graph.size() - <span class="number">1</span>) { <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 收集有效路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p><strong>处理目前搜索结点出发的路径</strong>：</p><ul><li>接下来是走当前遍历结点 node 的下一个结点。</li><li>首先是要找到 node 结点连接了哪些结点，然后就是将选中的 node 所连接的结点加入到单一路径中来，最后就是回溯的过程，撤销本次添加结点的操作。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = graph[node];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) { <span class="comment">// 遍历结点n链接的所有结点</span></span><br><span class="line">    path.add(graph[node][i]); <span class="comment">// 遍历到的结点加入到路径中来</span></span><br><span class="line">    dfs(graph, graph[node][i]); <span class="comment">// 进入下一层递归</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，撤销本结点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol><p>最后整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> {</span><br><span class="line">        path.add(<span class="number">0</span>);</span><br><span class="line">        dfs(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == graph.length - <span class="number">1</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] array = graph[node];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) {</span><br><span class="line">            path.add(array[i]);</span><br><span class="line">            dfs(graph, array[i]);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-岛屿数量-dfs"><a href="#2-岛屿数量-dfs" class="headerlink" title="2.岛屿数量(dfs)"></a>2.岛屿数量(dfs)</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","1","1","0"],</span><br><span class="line">  ["1","1","0","1","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","0","0","0"]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","1","0","0"],</span><br><span class="line">  ["0","0","0","1","1"]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li><p>注意题目中每座岛屿只能由<strong>水平方向和/或竖直方向上</strong>相邻的陆地连接形成。</p></li><li><p>也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220726094200.png" alt="图一"></p><p>这道题题目是 DFS，BFS，并查集，基础题目。</p><p>本题思路，是用遇到一个没有遍历过的结点陆地，计数器就加一，然后把该结点陆地所能遍历到的陆地都标记上。</p><p>在遇到标记过的陆地结点和海洋结点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p><p>那么如何把结点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集。</p></li><li><p>DFS 解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = {</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>}, <span class="comment">// 右</span></span><br><span class="line">        {<span class="number">1</span>, <span class="number">0</span>}, <span class="comment">// 下</span></span><br><span class="line">        {<span class="number">0</span>, -<span class="number">1</span>}, <span class="comment">// 左</span></span><br><span class="line">        {-<span class="number">1</span>, <span class="number">0</span>} <span class="comment">// 上</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于判断是否遍历过</span></span><br><span class="line">        <span class="type">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) {</span><br><span class="line">                <span class="comment">// 遇到还没遍历过的陆地</span></span><br><span class="line">                <span class="keyword">if</span> (!isVisited[i][j] &amp;&amp; grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="comment">// 将陆地和与之相连的陆地都遍历过去</span></span><br><span class="line">                    dfs(grid, isVisited, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">boolean</span>[][] isVisited, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isVisited[x][y] || grid[x][y] == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        isVisited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 遍历四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= grid.length || nextY &lt; <span class="number">0</span> || nextY &gt;= grid[<span class="number">0</span>].length) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            dfs(grid, isVisited, nextX, nextY);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>因为上面创建了一个 <code>isVisited</code> 数组，所以执行时间会更久一点，其实我们完全可以根据 <code>grid</code> 本身来判断是否遍历过陆地：</p><p>为了统计岛屿数量同时不重复记录，每当我们搜索到一个岛后，就将这个岛 “淹没” —— 将这个岛所占的地方从 “1” 改为 “0”，这样就不用担心后续会重复记录这个岛屿了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) {</span><br><span class="line">                <span class="comment">// 遇到还没遍历过的陆地</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="comment">// 将陆地和与之相连的陆地都遍历过去</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.length || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || grid[x][y] == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        grid[x][y] = <span class="string">'0'</span>; <span class="comment">// 淹没</span></span><br><span class="line">        dfs(grid, x - <span class="number">1</span>, y); <span class="comment">// 上</span></span><br><span class="line">        dfs(grid, x, y + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        dfs(grid, x + <span class="number">1</span>, y); <span class="comment">// 下</span></span><br><span class="line">        dfs(grid, x, y - <span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-岛屿数量-bfs"><a href="#3-岛屿数量-bfs" class="headerlink" title="3.岛屿数量(bfs)"></a>3.岛屿数量(bfs)</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","1","1","0"],</span><br><span class="line">  ["1","1","0","1","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","0","0","0"]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["1","1","0","0","0"],</span><br><span class="line">  ["0","0","1","0","0"],</span><br><span class="line">  ["0","0","0","1","1"]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul></li></ul><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><p>BFS 解法：</p><ul><li><p>这里有一个广搜中很重要的细节：<strong>只要加入队列就代表走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p><p>很多同学可能感觉这有区别吗？如果从队列拿出结点，再去标记这个结点走过，就会发生下图所示的结果，会导致很多结点重复加入队列。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220727100846.png" alt="图二"></p></li></ul><p>BFS 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = {</span><br><span class="line">        {-<span class="number">1</span>, <span class="number">0</span>}, <span class="comment">// 上 </span></span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>}, <span class="comment">// 右</span></span><br><span class="line">        {<span class="number">1</span>, <span class="number">0</span>}, <span class="comment">// 下</span></span><br><span class="line">        {<span class="number">0</span>, -<span class="number">1</span>} <span class="comment">// 左</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    result++;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{x, y});</span><br><span class="line">        grid[x][y] = <span class="string">'0'</span>; <span class="comment">// 淹没</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span>[] loc = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> loc[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> loc[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> m + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> n + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= grid.length || nextY &lt; <span class="number">0</span> || nextY &gt;= grid[<span class="number">0</span>].length || grid[nextX][nextY] == <span class="string">'0'</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 将与之连接的陆地也淹没</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{nextX, nextY});</span><br><span class="line">                grid[nextX][nextY] = <span class="string">'0'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/04/14/%E5%9B%BE%E8%AE%BATag/" title="图论Tag">https://running-noob.github.io/2024/04/14/图论Tag/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/04/12/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" rel="prev" title="JVM的垃圾回收机制"><i class="fa fa-chevron-left"></i> JVM的垃圾回收机制</a></div><div class="post-nav-item"><a href="/2024/04/29/%E6%8E%92%E5%BA%8FTag/" rel="next" title="排序Tag">排序Tag <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">深度优先搜索理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85DFS%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%EF%BC%88%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="nav-text">★DFS代码框架（递归+回溯）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">广度优先搜索理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85BFS%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%EF%BC%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-text">★BFS代码框架（队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">1.所有可能的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-dfs"><span class="nav-text">2.岛屿数量(dfs)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-bfs"><span class="nav-text">3.岛屿数量(bfs)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-text">思路</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">245</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">473k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:39</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="回溯三部曲： 回溯函数模板返回值以及参数 回溯函数终止条件 回溯搜索的遍历过程"><meta property="og:type" content="article"><meta property="og:title" content="回溯算法Tag"><meta property="og:url" content="https://running-noob.github.io/2024/04/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95Tag/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="回溯三部曲： 回溯函数模板返回值以及参数 回溯函数终止条件 回溯搜索的遍历过程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975-20230310113546003.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png"><meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png"><meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png"><meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg"><meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201115180537865.png"><meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg"><meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131816104.png"><meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131822254.png"><meta property="article:published_time" content="2024-04-01T13:13:07.000Z"><meta property="article:modified_time" content="2024-07-17T02:07:45.490Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png"><link rel="canonical" href="https://running-noob.github.io/2024/04/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95Tag/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>回溯算法Tag | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">24</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">245</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2024/04/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95Tag/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">回溯算法Tag</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-04-01 21:13:07" itemprop="dateCreated datePublished" datetime="2024-04-01T21:13:07+08:00">2024-04-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-07-17 10:07:45" itemprop="dateModified" datetime="2024-07-17T10:07:45+08:00">2024-07-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">LeetCode刷题笔记</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>31 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>回溯三部曲：<ul><li><strong>回溯函数模板返回值以及参数</strong></li><li><strong>回溯函数终止条件</strong></li><li><strong>回溯搜索的遍历过程</strong></li></ul></li></ul></blockquote><span id="more"></span><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。<strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p></li><li><p>回溯法，一般可以解决如下几种问题：</p><ul><li><strong>组合问题</strong>：N 个数里面按一定规则找出 k 个数的集合</li><li><strong>切割问题</strong>：一个字符串按一定规则有几种切割方式</li><li><strong>子集问题</strong>：一个 N 个数的集合里有多少符合条件的子集</li><li><strong>排列问题</strong>：N 个数按一定规则全排列，有几种排列方式</li><li><strong>棋盘问题</strong>：N 皇后，解数独等等</li></ul></li><li><p>回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）</strong>。</p></li></ul><h3 id="★回溯三部曲"><a href="#★回溯三部曲" class="headerlink" title="★回溯三部曲"></a>★回溯三部曲</h3><ul><li><p>回溯三部曲：</p><ul><li><p><strong>回溯函数模板返回值以及参数</strong>：</p><ul><li><p>在回溯算法中，我的习惯是函数起名字为 backtracking，这个起名大家随意。</p><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。回溯函数伪代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>回溯函数终止条件</strong>：</p><ul><li>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子结点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。所以回溯函数终止条件伪代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) {</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p><strong>回溯搜索的遍历过程</strong>：</p><ul><li><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础"></p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中结点孩子的数量就是集合的大小）) {</span><br><span class="line">    处理结点;</span><br><span class="line">    backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>for 循环就是遍历集合区间，可以理解一个结点有多少个孩子，这个 for 循环就执行多少次。</li><li>backtracking 这里自己调用自己，实现递归。</li><li>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子结点就是找的其中一个结果了。</li></ul></li></ul></li></ul><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> {</span><br><span class="line">    <span class="keyword">if</span> (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中结点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理结点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p></li></ul><h3 id="1-组合问题"><a href="#1-组合问题" class="headerlink" title="1.组合问题"></a>1.组合问题</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>本题是回溯法的经典题目。直接的解法当然是使用 for 循环，例如示例中 k 为 2，很容易想到用两个 for 循环，这样就可以输出和示例中一样的结果。输入：n = 100, k = 3 那么就三层 for 循环。</p><p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。此时就会发现虽然想暴力搜索，但是用 for 循环嵌套连暴力都写不出来！</p></li><li><p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><ul><li>上面我们说了要解决 n 为 100，k 为 50 的情况，暴力写法需要嵌套 50 层 for 循环，那么回溯法就用递归来解决嵌套层数的问题。<strong>用递归来做层叠嵌套（可以理解是开 k 层 for 循环），每一次的递归中嵌套一个 for 循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</li></ul></li><li><p>把组合问题抽象为如下树形结构：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合"></p><ul><li>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</li><li><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。<ul><li><strong>图中可以发现 n 相当于树的宽度，k 相当于树的深度</strong>。</li></ul></li><li>那么如何在这个树上遍历，然后收集到我们要的结果集呢？<ul><li><strong>图中每次搜索到了叶子结点，我们就找到了一个结果</strong>。相当于只需要把达到叶子结点的结果收集起来，就可以求得 n 个数中 k 个数的组合集合。</li></ul></li></ul></li><li><p>回溯法三部曲：</p><ul><li><p><strong>递归函数的返回值以及参数</strong></p><ul><li><p>函数里一定有两个参数，既然是集合 n 里面取 k 个数，那么 n 和 k 是两个 int 型的参数。</p></li><li><p>然后还需要一个参数，为 int 型变量 startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p><ul><li><p>为什么要有这个 startIndex 呢？</p><p><strong>startIndex 就是防止出现重复的组合</strong>。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">List&lt;Integer&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>回溯函数终止条件</strong></p><ul><li>什么时候到达所谓的叶子结点了呢？<ul><li>path 这个数组的大小如果达到 k，说明我们找到了一个子集大小为 k 的组合了，path 存的就是根结点到叶子结点的路径。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">    result.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p><strong>单层搜索的过程</strong></p><ul><li><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出 for 循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png" alt="77.组合1"></p><p>如此我们才遍历完图中的这棵树。</p><ul><li>for 循环每次从 startIndex 开始遍历，然后用 path 保存取到的结点 i。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) { <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.add(i); <span class="comment">// 处理结点</span></span><br><span class="line">    backtracking(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.remove(Integer.valueOf(i)); <span class="comment">// 回溯，撤销处理的结点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>可以看出 backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子结点，遇到了叶子结点就要返回。</li><li>backtracking 的下面部分就是回溯的操作了，撤销本次处理的结果。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// startIndex用于标识从哪里开始迭代，避免元素重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>上面的代码耗时很长，所以用剪枝对其进行优化，怎么优化呢？</p><ul><li><p>来举一个例子，n = 4，k = 4 的话，那么第一层 for 循环的时候，从元素 2 开始的遍历都没有意义了。 在第二层 for 循环，从元素 3 开始的遍历都没有意义了。</p><p>这么说有点抽象，如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png" alt="77.组合4"></p><ul><li><strong>可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</li><li><strong>如果 for 循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// n - startIndex + 1是剩余的还可以被添加到路径中的元素个数</span></span><br><span class="line">        <span class="comment">// k - path.size()是还需要被添加到路径中的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> ((n - startIndex + <span class="number">1</span>) &lt; (k - path.size())) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// startIndex用于标识从哪里开始迭代，避免元素重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) {</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-组合总和-III"><a href="#2-组合总和-III" class="headerlink" title="2.组合总和 III"></a>2.组合总和 III</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ul><li><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li><p>回溯三部曲：</p><ul><li><p><strong>确定递归函数参数及返回值：</strong></p><ul><li>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">组合问题</a> 一样，依然需要一维数组 path 来存放符合条件的结果，二维数组 result 来存放结果集。</li><li>接下来还需要如下参数：<ul><li>targetSum（int）目标和，也就是题目中的n。</li><li>k（int）就是题目中要求 k 个数的集合。</li><li>sum（int）为已经收集的元素的总和，也就是 path 里元素的总和。</li><li>startIndex（int）为下一层 for 循环搜索的起始位置。</li></ul></li></ul></li><li><p><strong>确定终止条件：</strong></p><ul><li>什么时候终止呢？<ul><li>k 其实就已经限制树的深度，因为就取 k 个元素，树再往下深了没有意义。</li><li>所以如果 path.size() 和 k 相等了，就终止。如果此时 path 里收集到的元素和（sum） 和 targetSum（就是题目描述的 n）相同了，就用 result 收集当前的结果。</li></ul></li></ul></li><li><p><strong>确定单层递归逻辑：</strong></p><ul><li><p>处理过程就是 path 收集每次选取的元素，相当于树型结构里的边，sum 来统计 path 里元素的总和。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975-20230310113546003.png" alt="216.组合总和III"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">    sum += i;</span><br><span class="line">    path.add(i);</span><br><span class="line">    backtracking(n, k, sum, i + <span class="number">1</span>);</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    sum -= i;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="keyword">if</span> (sum == n) {</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            sum += i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n, k, sum, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>剪枝优化：</p><ul><li>已选元素总和如果已经大于 n 了，那么往后遍历就没有意义了，直接剪掉。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> {</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) {</span><br><span class="line">            <span class="keyword">if</span> (sum == n) {</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            sum += i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n, k, sum, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-组合总和"><a href="#2-1-组合总和" class="headerlink" title="2.1 组合总和"></a>2.1 组合总和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul></li></ul><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li><p>因为同一个数字可以被重复选取，所以相比于 <code>2.组合总和 III</code>，传入递归函数的不是 i + 1，而是 i。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum == target) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) {</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates, target, sum, i); <span class="comment">// 传入 i 表示可以重复读取当前元素</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            sum -= candidates[i]; <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-组合总和-II-去重"><a href="#2-2-组合总和-II-去重" class="headerlink" title="2.2 组合总和 II(去重)"></a>2.2 组合总和 II(去重)</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul></li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li><p><strong>本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><ul><li>一些同学可能想了：我把所有组合求出来，再用 set 或者 map 去重，这么做很容易超时！</li><li>所以要在搜索的过程中就去掉重复组合。</li></ul></li><li><p><strong>所谓去重，其实就是使用过的元素不能重复选取。</strong></p><ul><li>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></li><li>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？<ul><li>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</li><li><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</li></ul></li></ul><p>为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）</p><ul><li><p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p></li><li><p>选择过程树形结构如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png" alt="40.组合总和II"></p></li></ul></li><li><p>回溯三部曲：</p><ol><li><p><strong>确定递归函数参数和返回值</strong>：</p><ul><li>与 <a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和 (opens new window)</a> 套路相同，此题还需要加一个 bool 型数组 <code>used</code>，用来记录同一树枝上的元素是否使用过。这个集合去重的重任就是 <code>used</code> 来完成的。</li></ul></li><li><p><strong>确定递归终止条件</strong>：</p><ul><li>与 <a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和 (opens new window)</a> 相同，终止条件为 <code>sum &gt; target</code> 和 <code>sum == target</code>。</li></ul></li><li><p><strong>确定单层递归逻辑</strong>：</p><ul><li><p>这里与 <a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">39.组合总和 (opens new window)</a> 最大的不同就是要去重了。</p></li><li><p>前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><ul><li><p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。此时for循环里就应该做continue的操作。这块比较抽象，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png" alt="40.组合总和II1"></p><p>在图中将 used 的变化用橘黄色标注上，可以看出在 candidates[i] == candidates[i - 1] 相同的情况下：</p><ul><li>used[i - 1] == true，说明<strong>同一树枝</strong>candidates[i - 1]使用过</li><li>used[i - 1] == false，说明<strong>同一树层</strong>candidates[i - 1]使用过</li></ul><p>为什么 used[i - 1] == false 就是同一树层呢，因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。而 used[i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img"></p></li></ul></li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(candidates);  <span class="comment">// 首先把candidates排序，让其相同的元素都挨在一起</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex, <span class="type">boolean</span>[] used)</span> {</span><br><span class="line">        <span class="comment">// for循环中的sum + candidates[i] &lt;= target用于剪枝，来代替</span></span><br><span class="line">        <span class="comment">// if (sum &gt; target) {</span></span><br><span class="line">        <span class="comment">// 	   return;</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) {</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(candidates, target, sum, i + <span class="number">1</span>, used);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            sum -= candidates[i]; <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-电话号码的字母组合"><a href="#3-电话号码的字母组合" class="headerlink" title="3.电话号码的字母组合"></a>3.电话号码的字母组合</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = "23"</span><br><span class="line">输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = ""</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = "2"</span><br><span class="line">输出：["a","b","c"]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul></li></ul><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li><p>本题要解决如下三个问题：</p><ol><li><p>数字和字母如何映射</p><ul><li>可以使用 map 来做映射</li></ul></li><li><p>两个字母就两个 for 循环，三个字符我就三个 for 循环，以此类推，然后发现代码根本写不出来</p><ul><li><p>用回溯来解决 n 个 for 循环的问题。例如：输入：”23”，抽象为树形结构，如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png" alt="17. 电话号码的字母组合"></p><ul><li>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</li><li><strong>写回溯的时候一定要注意横向遍历的是什么，纵向遍历的是什么。</strong></li></ul></li></ul></li><li><p>输入 1 * # 按键等等异常情况</p><ul><li>题目中已经限制了，就不用考虑了，但是正常情况下是要考虑的。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> String[] strs = {<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>};</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) { <span class="comment">// 排除特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span>[] charArray = digits.toCharArray();</span><br><span class="line">        backtracking(charArray, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[] charArray, <span class="type">int</span> cur)</span> {</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur == charArray.length) {</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> strs[charArray[cur] - <span class="string">'0'</span>];</span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            backtracking(charArray, cur + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-分割回文串-切割问题"><a href="#4-分割回文串-切割问题" class="headerlink" title="4.分割回文串(切割问题)"></a>4.分割回文串(切割问题)</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，<strong>使每个子串都是回文串</strong>。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "aab"</span><br><span class="line">输出：[["a","a","b"],["aa","b"]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "a"</span><br><span class="line">输出：[["a"]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul></li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul><li><p>本题涉及到两个关键问题：</p><ol><li><p>切割问题，有不同的切割方式</p><ul><li><p>这里的切割，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p></li><li><p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li></ul><p>所以切割问题，也可以抽象为一棵树形结构，如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><ul><li><strong>递归用于增加切割线，for 循环用于移动切割线的位置</strong>。</li></ul><p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p></li></ul></li><li><p>判断回文</p><ul><li>判断一个字符串是否是回文。可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex就是切割线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="comment">// 找到了一组切割方案</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.length()) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, startIndex, i)) { <span class="comment">// 如果是回文串，就保存</span></span><br><span class="line">                path.add(s.substring(startIndex, i + <span class="number">1</span>));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>); <span class="comment">// 继续向下切割</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是回文串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="5-复原IP地址"><a href="#5-复原IP地址" class="headerlink" title="5.复原IP地址"></a>5.复原IP地址</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><ul><li><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是 <strong>有效</strong> IP 地址，但是 <code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和 <code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "25525511135"</span><br><span class="line">输出：["255.255.11.135","255.255.111.35"]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "0000"</span><br><span class="line">输出：["0.0.0.0"]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "101023"</span><br><span class="line">输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul></li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li><p>只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>就十分类似了。切割问题可以抽象为树型结构，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png" alt="93.复原IP地址"></p></li><li><p>回溯三部曲：</p><ol><li><p><strong>确定递归函数参数及返回值：</strong></p><ul><li><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中我们就提到切割问题类似组合问题。</p><p><code>startIndex</code> 一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p><p>本题我们还需要一个变量 <code>depth</code>，记录已经分段的次数。</p></li></ul></li><li><p><strong>确定递归终止条件：</strong></p><ul><li><p>终止条件和<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>情况就不同了，本题明确要求只会分成 4 段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p><p>depth 表示分段数量，depth 为 4 说明字符串分成了 4 段了。</p><p>然后验证一下第四段是否合法，如果合法就加入到结果集里。</p></li></ul></li><li><p><strong>确定单层递归逻辑：</strong></p><ul><li><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中已经讲过在循环遍历中如何截取子串：</p><ul><li><p>在<code>for (int i = startIndex; i &lt; s.length(); i++)</code>循环中 [startIndex, i] 这个区间就是截取的子串，需要判断这个子串是否合法。</p><ul><li><p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p></li><li><p>如果不合法就结束本层循环，如图中剪掉的分支：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png" alt="93.复原IP地址"></p></li></ul></li></ul></li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">12</span>) { <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        backtracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> depth)</span> {</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">4</span>) { <span class="comment">// 已经分成四段了</span></span><br><span class="line">            <span class="keyword">if</span> (startIndex == s.length()) {</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 判断是否合法</span></span><br><span class="line">            <span class="keyword">if</span> ((temp.length() &gt; <span class="number">1</span> &amp;&amp; temp.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) </span><br><span class="line">                || temp.length() &gt; <span class="number">3</span> </span><br><span class="line">                || Integer.parseInt(temp) &gt; <span class="number">255</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            sb.append(temp);</span><br><span class="line">            <span class="keyword">if</span> (depth &lt; <span class="number">3</span>) {</span><br><span class="line">                sb.append(<span class="string">"."</span>);</span><br><span class="line">            }</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (depth &lt; <span class="number">3</span>) {</span><br><span class="line">                sb.delete(sb.length() - (i + <span class="number">2</span> - startIndex), sb.length()); <span class="comment">// 回溯，要把"."考虑进来</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sb.delete(sb.length() - (i + <span class="number">1</span> - startIndex), sb.length()); <span class="comment">// 回溯</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-子集问题"><a href="#6-子集问题" class="headerlink" title="6.子集问题"></a>6.子集问题</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul></li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul><li><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>以示例中 nums = [1,2,3] 为例把求子集抽象为树型结构，如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p></li><li><p>回溯三部曲：</p><ol><li><p><strong>确定递归函数参数及返回值：</strong></p><ul><li><p>子集也是一种组合问题，因为它的集合是无序的，子集 {1,2} 和子集 {2,1} 是一样的。</p><p>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for 就要从 startIndex 开始，而不是从 0 开始。所以需要传入参数 startIndex。</p></li></ul></li><li><p><strong>确定递归终止条件：</strong></p><ul><li>从上图可以看出，剩余集合为空的时候，就是叶子节点。那么什么时候剩余集合为空呢？<ul><li>就是 startIndex 已经大于数组的长度了，就终止了，因为没有元素可取了。</li></ul></li></ul></li><li><p><strong>确定单层递归逻辑：</strong></p><ul><li><strong>求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树</strong>。</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 收集树上的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p><strong>收集树上所有的节点，那就在进入回溯函数的时候就 <code>add</code>。</strong></p><p><strong>收集树中的叶子结点，那就在终止条件满足时才 <code>add</code>。</strong></p></li></ul><h3 id="6-1-子集-II-去重"><a href="#6-1-子集-II-去重" class="headerlink" title="6.1 子集 II(去重)"></a>6.1 子集 II(去重)</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul></li></ul><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul><li><p>关于回溯算法中的去重问题，<strong>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>中已经详细讲解过了，和本题是一个套路</strong>。用示例中的[1, 2, 2] 来举例，如图所示： （<strong>注意去重需要先对集合排序</strong>）</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png" alt="90.子集II"></p><p>从图中可以看出，<strong>同一树层上重复取 2 就要过滤掉，同一树枝上就可以重复取 2</strong>，因为同一树枝上元素的集合才是唯一子集。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序让相同的元素挨在一起</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex, <span class="type">boolean</span>[] used)</span> {</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="comment">// 保存树上的各个节点</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="7-递增子序列"><a href="#7-递增子序列" class="headerlink" title="7.递增子序列"></a>7.递增子序列</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul></li></ul><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ul><li><p>这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。</p><ul><li>这又是子集，又是去重，让人不由自主的想起了刚刚讲过的 <a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>。</li></ul><p>就是因为太像了，更要注意差别所在，要不就掉坑里了！</p></li><li><p>在 <a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a> 中我们是<strong>通过排序，先让原数组中相同的元素挨在一起，再加一个标记数组来达到去重的目的</strong>。而本题求自增子序列，是不能对原数组进行排序的，因为排完序的数组都是自增子序列了。</p><ul><li><strong>所以不能使用之前的去重逻辑！</strong>本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。为了有鲜明的对比，用 [4, 7, 6, 7] 这个数组来举例，抽象为树形结构如图：</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png" alt="491. 递增子序列1"></p><ul><li>在图中可以看出，<strong>同一父节点下的同层上使用过的元素就不能再使用了</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">201</span>]; <span class="comment">// 因为题目限制-100 &lt;= nums[i] &lt;= 100</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> ((!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; nums[i])</span><br><span class="line">                || used[nums[i] + <span class="number">100</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 用于限制同一父节点下的同层上使用过的元素不能再被使用</span></span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>注意这题和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a> 的关系：</p><ol><li><p>这题要求递增子序列，那么就不能对原数据进行修改，即不能对原数组进行排序。</p></li><li><p>由于求递增子序列这个要求，潜在地把一些重复的子集给过滤掉了，例如有子集 [1, 4]，而不会有子集 [4, 1]，所以用上面的代码是可以对本题进行求解的。同时，上面的方法同样可以求解 <a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>，因为<strong>上面的代码可以保证同一父节点下的同层上使用过的元素不能再被使用</strong>，但是需要注意，在用上面的代码求解 <a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a> 问题时，<strong>同样需要先对原数组进行排序</strong>，如果没有对数组提前进行排序，例如对于数组 [4, 1, 4]，如果没有排序，那么用上面的代码，子集 [4, 1] 和子集 [1, 4] 都会出现，就出现子集重复的问题。</p><ul><li><p>从效率来看，还是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>的效率要高于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">if</span> (set.contains(nums[i])) { <span class="comment">// 用set集合代替used数组进行判断</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>因为方法一中 <code>used</code> 数组是全局变量，方法二中 set 集合是局部变量，前者空间复杂度为 O(n)，后者空间复杂度为 O(n^2)。另外，判断元素是否在集合中，需要频繁地使用哈希函数进行映射，也会增加执行时间。</p></li></ul></li></ol></li></ul><h3 id="8-全排列"><a href="#8-全排列" class="headerlink" title="8.全排列"></a>8.全排列</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 所有可能的全排列 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></li></ul><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul><li><p>回溯法三部曲：</p><ul><li><p><strong>递归函数的返回值以及参数</strong></p><ul><li><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p></li><li><p>可以看出元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要在使用一次 1，所以处理排列问题就不用使用 startIndex 了。</p><p>但排列问题需要一个 used 数组，标记已经选择的元素，如图橘黄色部分所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">List&lt;Integer&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>回溯函数终止条件</strong></p><ul><li>什么时候到达所谓的叶子结点了呢？<ul><li>当收集元素的数组 path 的大小达到和 nums 数组一样大的时候，说明找到了一个全排列，也表示到达了叶子结点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">    result.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p><strong>单层搜索的过程</strong></p><ul><li>因为排列问题，每次都要从头开始搜索，例如元素 1 在 [1,2] 中已经使用过了，但是在 [2,1] 中还要再使用一次 1。<strong>而 used 数组，其实就是记录此时 path 里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    path.add(nums[i]);</span><br><span class="line">    backtracking(nums, used);</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">    used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">// 初始化used数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; used.length; i++) {</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        backTracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (used[i]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, used);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>不用 used 数组，用 contains 方法判断元素是不是在 path 中就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (path.contains(nums[i])) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-1-全排列-II-去重"><a href="#8-1-全排列-II-去重" class="headerlink" title="8.1 全排列 II(去重)"></a>8.1 全排列 II(去重)</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul></li></ul><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul><li><p>这道题目和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a> 的区别在于<strong>给定一个可包含重复数字的序列</strong>，要返回<strong>所有不重复的全排列</strong>。这里又涉及到去重了。</p><ul><li>在 <a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a> 中详细讲解了组合问题和子集问题如何去重。那么排列问题其实也是一样的套路。</li><li><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</li></ul></li><li><p>以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png" alt="47.全排列II1"></p><ul><li>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</li></ul><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 去重问题一定要对数组元素进行排序,使得相同值的元素挨在一起</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> {</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span></span><br><span class="line">        <span class="comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">        <span class="comment">// 如果同⼀树层nums[i - 1]使⽤过(used[i - 1] == false)则直接跳过</span></span><br><span class="line">        <span class="comment">// 如果当前元素使用过也直接跳过(used[i] == true)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-重新安排行程"><a href="#9-重新安排行程" class="headerlink" title="9.重新安排行程"></a>9.重新安排行程</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>["JFK", "LGA"]</code> 与 <code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</li></ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]</span><br><span class="line">输出：["JFK","MUC","LHR","SFO","SJC"]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]</span><br><span class="line">输出：["JFK","ATL","JFK","SFO","ATL","SFO"]</span><br><span class="line">解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tickets.length &lt;= 300</code></li><li><code>tickets[i].length == 2</code></li><li><code>fromi.length == 3</code></li><li><code>toi.length == 3</code></li><li><code>fromi</code> 和 <code>toi</code> 由大写英文字母组成</li><li><code>fromi != toi</code></li></ul></li></ul><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul><li><p>这道题目有几个难点：</p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li><li>如何按字典排序返回最小的行程组合？</li></ol></li><li><p>对于死循环，举一个有重复机场的例子：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201115180537865.png" alt="332.重新安排行程"></p><ul><li><p><strong>如果在解题的过程中没有对集合元素处理好，就会死循环。</strong>可能出现下面的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"JFK"</span>,<span class="string">"NRT"</span>,<span class="string">"JFK"</span>,<span class="string">"NRT"</span>,<span class="string">"JFK"</span>,<span class="string">"NRT"</span>,<span class="string">"JFK"</span>......]</span><br></pre></td></tr></table></figure></li><li><p>所以需要定义一个 <code>used</code> 数组，来判断机票是否已经使用过。</p></li></ul></li><li><p>使用回溯法的话，那么终止条件是什么呢？</p><ul><li>以题目中的示例 1 为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有 4 个航班，那么只要找出一种行程，行程里的机场个数是 5 就可以了。</li><li>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量 +1），那么我们就找到了一个行程，把所有航班串在一起了。</li></ul></li><li><p>如何按字典排序返回最小的行程组合？</p><ul><li>直观的想法，对所有的机票，按降落的机场地点进行排序，然后在递归函数的单层逻辑中使用 for 循环即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> {</span><br><span class="line">        Collections.sort(tickets, (a, b) -&gt; a.get(<span class="number">1</span>).compareTo(b.get(<span class="number">1</span>))); <span class="comment">// 来满足字典排序</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[tickets.size()]; <span class="comment">// used数组用于判断机票是否使用过</span></span><br><span class="line">        res.add(<span class="string">"JFK"</span>);</span><br><span class="line">        backtracking(tickets, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets, <span class="type">boolean</span>[] used)</span> {</span><br><span class="line">        <span class="keyword">if</span> (res.size() == tickets.size() + <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tickets.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (!used[i] &amp;&amp; tickets.get(i).get(<span class="number">0</span>).equals(res.get(res.size() - <span class="number">1</span>))) {</span><br><span class="line">                res.add(tickets.get(i).get(<span class="number">1</span>));</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (backtracking(tickets, used)) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到了解就不断return true退出递归，而不是往下回溯</span></span><br><span class="line">                };</span><br><span class="line">                res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>结果发现超时了，原因在于使用 sort 方法对机票进行排序时，消耗时间过长。</li></ul></li><li><p>为了减少执行时间，考虑用空间换时间，不使用 <code>List&lt;List&lt;String&gt;&gt; tickets</code> 直接进行处理，而是使用 Map 来存储机票信息：</p><ul><li><code>map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt;</code>，注意相同的机票是可能有多张的，比如从 <code>JFK</code> 到 <code>NRT</code> 的机票有两张这种。</li><li>具体来说，是 <code>HashMap&lt;出发机场, TreeMap&lt;到达机场, 航班次数&gt;&gt;</code>，用 <code>TreeMap</code> 来满足字典排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> {</span><br><span class="line">        <span class="comment">// 初始化map</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; t : tickets) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> t.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> t.get(<span class="number">1</span>);</span><br><span class="line">            Map&lt;String, Integer&gt; temp;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(from)) {</span><br><span class="line">                temp = map.get(from);</span><br><span class="line">                temp.put(to, temp.getOrDefault(to, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 默认升序</span></span><br><span class="line">                temp.put(to, <span class="number">1</span>);</span><br><span class="line">                map.put(from, temp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(<span class="string">"JFK"</span>);</span><br><span class="line">        backtracking(tickets.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> ticketsNum)</span> {</span><br><span class="line">        <span class="keyword">if</span> (res.size() == ticketsNum + <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> res.peekLast();</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(last)) {</span><br><span class="line">            Map&lt;String, Integer&gt; temp = map.get(last); <span class="comment">// 得到下一个要飞向的机场的集合</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : temp.entrySet()) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> e.getKey(); <span class="comment">// 通过TreeMap来保证取出的到达机场是按字典排序的</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                    res.add(to);</span><br><span class="line">                    temp.put(to, count - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (backtracking(ticketsNum)) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    res.removeLast(); <span class="comment">// 回溯</span></span><br><span class="line">                    temp.put(to, count); <span class="comment">// 回溯，注意这里回溯是将count设置回原来的值，而不是count + 1</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-N皇后"><a href="#10-N皇后" class="headerlink" title="10.N皇后"></a>10.N皇后</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><ul><li><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[["Q"]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul></li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ul><li><p>N 皇后问题是经典的用回溯算法解决的问题。</p></li><li><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>以一个 3 * 3 的棋盘为例，将搜索过程抽象为一棵树，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg" alt="51.N皇后"></p><p>从图中，可以看出，<strong>二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度</strong>。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                chessboard[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        backtracking(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="keyword">if</span> (row == n) {</span><br><span class="line">            res.add(arrayToList(n, chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(n, row, i, chessboard)) {</span><br><span class="line">                chessboard[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                backtracking(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">                chessboard[row][i] = <span class="string">'.'</span>; <span class="comment">// 回溯</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断皇后的位置是否可行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="comment">// 隐含的已经不可能在同一行了</span></span><br><span class="line">        <span class="comment">// 判断是否在同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) {</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 判断是否在45度角的斜线上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) {</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 判断是否在135度角的斜线上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            temp.add(<span class="keyword">new</span> <span class="title class_">String</span>(chessboard[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="11-解数独"><a href="#11-解数独" class="headerlink" title="11.解数独"></a>11.解数独</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><ul><li><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]</span><br><span class="line">输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul></li></ul><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ul><li><p>棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是<strong>二维递归</strong>。</p><ul><li>我们之前做的题目例如：<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合（组合问题） (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串（分割问题） (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集（子集问题） (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列（排列问题） (opens new window)</a>，以及<a target="_blank" rel="noopener" href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">51.N皇后（N皇后问题） (opens new window)</a>，其实这些题目都是一维递归。</li></ul><p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong>。如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131816104.png" alt="37.解数独"></p></li><li><p>回溯三部曲：</p><ol><li><p><strong>确定回溯函数及参数</strong>：</p><ul><li>本题递归函数的返回值需要是 boolean 类型，为什么呢？<ul><li>因为解数独找到一个符合的条件（就在树的叶子节点上）就立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用 boolean 返回值。如果返回为 true 就不需要再执行后续的回溯代码了。</li></ul></li></ul></li><li><p><strong>确定递归终止条件</strong></p><ul><li>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</li><li>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</li></ul></li><li><p><strong>确定单层递归逻辑</strong></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131822254.png" alt="37.解数独"></p><ul><li>在树形图中可以看出我们需要的是一个二维的递归 （一行一列）</li><li><strong>一个 for 循环遍历棋盘的行，一个 for 循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放 9 个数字的可能性！</strong></li></ul></li></ol></li><li><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        backtracking(board);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; board.length; row++) { <span class="comment">// 遍历行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board[row].length; col++) { <span class="comment">// 遍历列</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">'1'</span>; k &lt;= <span class="string">'9'</span>; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (isValid(board, k, row, col)) {</span><br><span class="line">                        board[row][col] = k;</span><br><span class="line">                        <span class="keyword">if</span> (backtracking(board)) {</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 表明已经找到了解，直接返回，不需要再回溯了</span></span><br><span class="line">                        }</span><br><span class="line">                        board[row][col] = <span class="string">'.'</span>; <span class="comment">// 回溯</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果数字1-9试过都不可以，就返回false</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 表明表格已经填满，则返回true</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span> k, <span class="type">int</span> row, <span class="type">int</span> col)</span> {</span><br><span class="line">        <span class="comment">// 判断行合法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == k) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 判断列合法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == k) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 判断3x3宫内合法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow; i &lt; startRow + <span class="number">3</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol; j &lt; startCol + <span class="number">3</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == k) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2024/04/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95Tag/" title="回溯算法Tag">https://running-noob.github.io/2024/04/01/回溯算法Tag/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/03/29/RabbitMQ%E9%AB%98%E7%BA%A7%E7%AF%87/" rel="prev" title="RabbitMQ高级篇"><i class="fa fa-chevron-left"></i> RabbitMQ高级篇</a></div><div class="post-nav-item"><a href="/2024/04/02/JVM%E5%9F%BA%E7%A1%80/" rel="next" title="JVM基础">JVM基础 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-text">回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-text">★回溯三部曲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-text">1.组合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="nav-text">2.组合总和 III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text">2.1 组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-%E5%8E%BB%E9%87%8D"><span class="nav-text">2.2 组合总和 II(去重)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text">3.电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98"><span class="nav-text">4.分割回文串(切割问题)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="nav-text">5.复原IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="nav-text">6.子集问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%AD%90%E9%9B%86-II-%E5%8E%BB%E9%87%8D"><span class="nav-text">6.1 子集 II(去重)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">7.递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">8.全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%85%A8%E6%8E%92%E5%88%97-II-%E5%8E%BB%E9%87%8D"><span class="nav-text">8.1 全排列 II(去重)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="nav-text">9.重新安排行程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-N%E7%9A%87%E5%90%8E"><span class="nav-text">10.N皇后</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-text">11.解数独</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="nav-text">思路</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">245</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">473k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:39</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
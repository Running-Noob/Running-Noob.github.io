<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="正则表达式"><meta property="og:type" content="article"><meta property="og:title" content="正则表达式"><meta property="og:url" content="https://running-noob.github.io/2023/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="正则表达式"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-07-29T13:22:54.000Z"><meta property="article:modified_time" content="2023-12-14T13:51:24.609Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://running-noob.github.io/2023/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>正则表达式 | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">24</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">247</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2023/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">正则表达式</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-07-29 21:22:54" itemprop="dateCreated datePublished" datetime="2023-07-29T21:22:54+08:00">2023-07-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-14 21:51:24" itemprop="dateModified" datetime="2023-12-14T21:51:24+08:00">2023-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>正则表达式</p></blockquote><span id="more"></span><h3 id="★第二十二章-正则表达式"><a href="#★第二十二章-正则表达式" class="headerlink" title="★第二十二章 正则表达式"></a>★第二十二章 正则表达式</h3><ul><li><code>Regular Expression</code>：正则表达式，是对字符串执行模式匹配的技术。</li></ul><h4 id="正则表达式快速入门"><a href="#正则表达式快速入门" class="headerlink" title="正则表达式快速入门"></a>正则表达式快速入门</h4><ul><li><p>下面是正则表达式快速入门的例子，对字符串文本中的英文单词进行匹配输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/15 19:08</span></span><br><span class="line"><span class="comment"> * 正则表达式快速入门例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//要处理的字符串文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态网页能够“灵活”起来，"</span> +</span><br><span class="line">                <span class="string">"急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。"</span> +</span><br><span class="line">                <span class="string">"于是，世界各大IT企业为此纷纷投入了大量的人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的Oak，"</span> +</span><br><span class="line">                <span class="string">"并且重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结构进行编写的，所以非常小，"</span> +</span><br><span class="line">                <span class="string">"特别适用于网络上的传输系统，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。"</span> +</span><br><span class="line">                <span class="string">"Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的Applet"</span> +</span><br><span class="line">                <span class="string">"（Applet是一种将小程序嵌入到网页中进行执行的技术），并将Oak更名为Java。"</span> +</span><br><span class="line">                <span class="string">"5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。"</span> +</span><br><span class="line">                <span class="string">"IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和微软等各大公司都纷纷停止了自己的相关开发项目，"</span> +</span><br><span class="line">                <span class="string">"竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台。"</span>;</span><br><span class="line">        <span class="comment">//1.先创建一个Pattern对象, 即模式对象, 可以理解为就是一个正则表达式对象, 传入的参数为正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">"[a-zA-Z]+"</span>); <span class="comment">//要匹配英文单词</span></span><br><span class="line">        <span class="comment">//2.创建一个匹配器对象, 传入要处理的字符串</span></span><br><span class="line">        <span class="comment">//  matcher 匹配器按照 pattern(模式/样式) 到 content 文本中去匹配。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.开始循环匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {    <span class="comment">//如果找到就返回 true，否则返回 false。</span></span><br><span class="line">            <span class="comment">//匹配到的内容可以通过 matcher.group 得到</span></span><br><span class="line">            System.out.println(<span class="string">"找到: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="★正则表达式底层原理"><a href="#★正则表达式底层原理" class="headerlink" title="★正则表达式底层原理"></a>★正则表达式底层原理</h4><h5 id="matcher-find"><a href="#matcher-find" class="headerlink" title="matcher.find()"></a>matcher.find()</h5><ul><li><p><code>matcher.find()</code> 完成的任务：</p><ol><li><p>根据指定的正则表达式，定位满足规则的子字符串。</p></li><li><p>找到后，将子字符串 “开始的索引位置” 记录到 <code>matcher</code> 对象的属性 <code>int[] groups</code> 中。</p><p><strong>“开始的索引位置” 记录到 <code>groups[0]</code> 中</strong>。</p><p>同时将子字符串 “结束的索引位置 + 1” 记录到 <code>gropus</code> 中。</p><p><strong>“结束的索引位置 + 1” 记录到 <code>groups[1]</code> 中</strong>。</p></li><li><p>同时记录 <code>oldLast</code> 的值为 “结束的索引位置 + 1”，即下次执行 <code>find</code> 方法时，就从 <code>oldLast</code> 开始继续向下匹配。</p></li></ol></li></ul><h5 id="matcher-group-0"><a href="#matcher-group-0" class="headerlink" title="matcher.group(0)"></a>matcher.group(0)</h5><ul><li><p><code>matcher.group(0)</code> 用来返回匹配到的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span> {</span><br><span class="line">    <span class="keyword">if</span> (first &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No match found"</span>);</span><br><span class="line">    <span class="keyword">if</span> (group &lt; <span class="number">0</span> || group &gt; groupCount())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">"No group "</span> + group);</span><br><span class="line">    <span class="keyword">if</span> ((groups[group*<span class="number">2</span>] == -<span class="number">1</span>) || (groups[group*<span class="number">2</span>+<span class="number">1</span>] == -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> getSubSequence(groups[group * <span class="number">2</span>], groups[group * <span class="number">2</span> + <span class="number">1</span>]).toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>根据 <code>groups[0]</code> 和 <code>groups[1]</code> 记录的位置，从字符文本中截取子字符串 (截取规则为左闭右开的规则) 并返回。</p></li><li><p>以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/15 19:29</span></span><br><span class="line"><span class="comment"> * 分析Java正则表达式的底层实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExpTheory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//给定一段字符串，找出所有四个数字连在一起的子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了Apple公司Mac OS X的工业标准的支持。"</span> +</span><br><span class="line">                <span class="string">"2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，与J2SE1.3相比，"</span> +</span><br><span class="line">                <span class="string">"其多了近62%的类和接口。在这些新特性当中，还提供了广泛的XML支持、安全套接字（Socket）支持（通过SSL与TLS协议）、"</span> +</span><br><span class="line">                <span class="string">"全新的I/OAPI、正则表达式、日志与断言。2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。"</span> +</span><br><span class="line">                <span class="string">"为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0），代号为“Tiger”，"</span> +</span><br><span class="line">                <span class="string">"Tiger包含了从1996年发布1.0版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、"</span> +</span><br><span class="line">                <span class="string">"格式化I/O及可变参数。"</span>;</span><br><span class="line">        <span class="comment">//正则表达式, 匹配四个数字连在一起的子串</span></span><br><span class="line">        <span class="comment">//说明: \\d 表示一个任意的数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"\\d\\d\\d\\d"</span>;</span><br><span class="line">        <span class="comment">//1.先创建一个Pattern对象, 即模式对象, 可以理解为就是一个正则表达式对象, 传入的参数为正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="comment">//2.创建一个匹配器对象, 传入要处理的字符串</span></span><br><span class="line">        <span class="comment">//  matcher 匹配器按照 pattern(模式/样式) 到 content 文本中去匹配。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.开始循环匹配</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * matcher.find() 完成的任务</span></span><br><span class="line"><span class="comment">         * (1)根据指定的正则表达式，定位满足规则的子字符串</span></span><br><span class="line"><span class="comment">         * (2)找到后，将子字符串 “开始的索引位置” 记录到 matcher 对象的属性 int[] groups 中</span></span><br><span class="line"><span class="comment">         *       以第一个找到的 2000 为例，groups[0] = 0 (因为2的索引位置为0)</span></span><br><span class="line"><span class="comment">         *       同时将子字符串 “结束的索引位置 + 1” 记录到 groups 中</span></span><br><span class="line"><span class="comment">         *       以第一个找到的 2000 为例，groups[1] = 4 (因为最后一个0的索引位置为3，3+1=4)</span></span><br><span class="line"><span class="comment">         * (3)同时记录 oldLast 的值为 “结束的索引位置 + 1”，即下次执行 find 方法时，就从 oldLast 开始继续向下匹配</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {    <span class="comment">//如果找到就返回 true，否则返回 false。</span></span><br><span class="line">            <span class="comment">//匹配到的内容可以通过 matcher.group 得到</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *    public String group(int group) {</span></span><br><span class="line"><span class="comment">             *         if (first &lt; 0)</span></span><br><span class="line"><span class="comment">             *             throw new IllegalStateException("No match found");</span></span><br><span class="line"><span class="comment">             *         if (group &lt; 0 || group &gt; groupCount())</span></span><br><span class="line"><span class="comment">             *             throw new IndexOutOfBoundsException("No group " + group);</span></span><br><span class="line"><span class="comment">             *         if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">             *             return null;</span></span><br><span class="line"><span class="comment">             *         return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">             *     }</span></span><br><span class="line"><span class="comment">             *     (1)根据 groups[0] 和 groups[1] 记录的位置，从 content 中截取子字符串(截取规则为左闭右开的规则)并返回</span></span><br><span class="line"><span class="comment">             *          以第一个找到的 2000 为例，groups[0] = 0，groups[1] = 4，所以返回的就是 "2000"</span></span><br><span class="line"><span class="comment">             *     (2)然后继续向下匹配，将会匹配到 2001，此时会更新 groups[0] 和 groups[1] 的值，即更新后</span></span><br><span class="line"><span class="comment">             *          groups[0] = 65，groups[1] = 69，所以返回的就是 "2001"</span></span><br><span class="line"><span class="comment">             *          同样的，oldLast 的值也会进行更新</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"找到: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h5 id="★matcher-group-i"><a href="#★matcher-group-i" class="headerlink" title="★matcher.group(i)"></a>★matcher.group(i)</h5><ul><li><p>正则表达式另外还有<strong>分组</strong>的概念。将上面的代码改写一下，以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/15 21:56</span></span><br><span class="line"><span class="comment"> * 分析Java正则表达式的底层实现(引入分组)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExpTheory2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了Apple公司Mac OS X的工业标准的支持。"</span> +</span><br><span class="line">                <span class="string">"2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，与J2SE1.3相比，"</span> +</span><br><span class="line">                <span class="string">"其多了近62%的类和接口。在这些新特性当中，还提供了广泛的XML支持、安全套接字（Socket）支持（通过SSL与TLS协议）、"</span> +</span><br><span class="line">                <span class="string">"全新的I/OAPI、正则表达式、日志与断言。2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。"</span> +</span><br><span class="line">                <span class="string">"为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0），代号为“Tiger”，"</span> +</span><br><span class="line">                <span class="string">"Tiger包含了从1996年发布1.0版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、"</span> +</span><br><span class="line">                <span class="string">"格式化I/O及可变参数。"</span>;</span><br><span class="line">        <span class="comment">//分组：例如下面的 (\\d\\d)(\\d\\d)，正则表达式中有 () 就表示分组，第一个 () 代表第一组，第二个 () 代表第二组</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"(\\d\\d)(\\d\\d)"</span>;</span><br><span class="line">        <span class="comment">//1.先创建一个Pattern对象, 即模式对象, 可以理解为就是一个正则表达式对象, 传入的参数为正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="comment">//2.创建一个匹配器对象, 传入要处理的字符串</span></span><br><span class="line">        <span class="comment">//  matcher 匹配器按照 pattern(模式/样式) 到 content 文本中去匹配。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.开始循环匹配</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * matcher.find() 完成的任务 (考虑分组)</span></span><br><span class="line"><span class="comment">         * (1)根据指定的正则表达式，定位满足规则的子字符串</span></span><br><span class="line"><span class="comment">         * (2)找到后，将子字符串 “开始的索引位置” 记录到 matcher 对象的属性 int[] groups 中</span></span><br><span class="line"><span class="comment">         *       同时将子字符串 “结束的索引位置 + 1” 记录到 groups 中</span></span><br><span class="line"><span class="comment">         *      (2.1)仍以第一个找到的 2000 为例，groups[0] = 0 (因为2的索引位置为0)，groups[1] = 4 (因为最后一个0的索引位置为3，3+1=4)</span></span><br><span class="line"><span class="comment">         *          但是因为引入了分组，所以还会将第一组 (对应20)、第二组 (对应00) 的开始和结束索引位置也记录下来</span></span><br><span class="line"><span class="comment">         *      (2.2)第一组匹配到的字符串 (20)，groups[2] = 0 (因为2的索引位置为0)，groups[3] = 2 (因为20的最后一个0的索引位置为1，1+1=2)</span></span><br><span class="line"><span class="comment">         *      (2.3)第二组匹配到的字符串 (00)，groups[4] = 2 (因为第一个0的索引位置为2)，groups[5] = 4 (因为第二个0的索引位置为4，3+1=4)</span></span><br><span class="line"><span class="comment">         *          如果有更多的分组，以此类推...</span></span><br><span class="line"><span class="comment">         * (3)同时记录 oldLast 的值为 “结束的索引位置 + 1”，即下次执行 find 方法时，就从 oldLast 开始继续向下匹配</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {    <span class="comment">//如果找到就返回 true，否则返回 false。</span></span><br><span class="line">            <span class="comment">//匹配到的内容可以通过 matcher.group 得到</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *    public String group(int group) {</span></span><br><span class="line"><span class="comment">             *         if (first &lt; 0)</span></span><br><span class="line"><span class="comment">             *             throw new IllegalStateException("No match found");</span></span><br><span class="line"><span class="comment">             *         if (group &lt; 0 || group &gt; groupCount())</span></span><br><span class="line"><span class="comment">             *             throw new IndexOutOfBoundsException("No group " + group);</span></span><br><span class="line"><span class="comment">             *         if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">             *             return null;</span></span><br><span class="line"><span class="comment">             *         return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">             *     }</span></span><br><span class="line"><span class="comment">             *     (1)根据 groups[0] 和 groups[1] 记录的位置，从 content 中截取子字符串(截取规则为左闭右开的规则)并返回</span></span><br><span class="line"><span class="comment">             *          以第一个找到的 2000 为例，groups[0] = 0，groups[1] = 4，所以返回的就是 "2000"</span></span><br><span class="line"><span class="comment">             *          因为引入了分组，所以还可以得到匹配到的子字符串的分组的内容</span></span><br><span class="line"><span class="comment">             *          matcher.group(0) 表示得到 groups[0] 和 groups[1] 所对应的子字符串，即表示返回匹配到的子字符串的所有内容。</span></span><br><span class="line"><span class="comment">             *          matcher.group(1) 表示得到 groups[2] 和 groups[3] 所对应的子字符串，即表示返回匹配到的子字符串的第 `1` 个分组的内容。</span></span><br><span class="line"><span class="comment">             *          matcher.group(2) 表示得到 groups[4] 和 groups[5] 所对应的子字符串，即表示返回匹配到的子字符串的第 `2` 个分组的内容。</span></span><br><span class="line"><span class="comment">             *          以此类推...</span></span><br><span class="line"><span class="comment">             *          从 return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString(); 也可以看出来</span></span><br><span class="line"><span class="comment">             *     (2)然后继续向下匹配，将会匹配到 2001，此时会更新 groups[0] 和 groups[1] 的值，即更新后</span></span><br><span class="line"><span class="comment">             *          groups[0] = 65，groups[1] = 69，所以返回的就是 "2001"，其分组也和上面类似</span></span><br><span class="line"><span class="comment">             *          同样的，oldLast 的值也会进行更新</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.print(<span class="string">"找到匹配内容: "</span> + matcher.group(<span class="number">0</span>) + <span class="string">"\t"</span>);</span><br><span class="line">            System.out.print(<span class="string">"匹配内容的第一组: "</span> + matcher.group(<span class="number">1</span>) + <span class="string">"\t"</span>);</span><br><span class="line">            System.out.println(<span class="string">"匹配内容的第二组: "</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>上面代码注释中比较重要的一句话：<code>但是因为引入了分组，所以还会将第一组 (对应20)、第二组 (对应00) 的开始和结束索引位置也记录下来</code>。</li><li>从上面的代码可以看出来，<code>matcher.group(i)</code> 表示<strong>返回匹配到的子字符串的第 <code>i</code> 个分组的内容</strong>。<ul><li><code>matcher.group(0)</code> 表示返回匹配到的子字符串的所有内容。</li><li><code>matcher.group(1)</code> 表示返回匹配到的子字符串的第 <code>1</code> 个分组的内容。</li><li><code>matcher.group(2)</code> 表示返回匹配到的子字符串的第 <code>2</code> 个分组的内容。</li><li>……</li></ul></li></ul></li></ul><h4 id="★★★正则表达式语法"><a href="#★★★正则表达式语法" class="headerlink" title="★★★正则表达式语法"></a>★★★正则表达式语法</h4><ul><li>如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：<ol><li>特殊字符。</li><li>字符匹配符。</li><li>选择匹配符。</li><li>限定符。</li><li>定位符。</li><li>分组组合和反向引用符。</li></ol></li></ul><h5 id="★转义符"><a href="#★转义符" class="headerlink" title="★转义符 \"></a>★转义符 \</h5><ul><li><strong>注意</strong>：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号 <code>"\"</code>，否则检索不到结果，甚至报错。例如，用 <code>"\("</code> 匹配左括号而不是 <code>"("</code>。<ul><li>同时，**在 <code>Java</code> 的正则表达式中，用两个 <code>"\\"</code> 代表其他语言的一个 <code>"\"</code>**，所以在 <code>Java</code> 中，用 <code>"\\("</code> 匹配左括号。</li><li>需要用到转义符号的字符有以下：<code>. * + ( ) $ / \ ? [ ] ^ { } |</code> ，当<strong>要找到这些字符它们 “本身” 时，需要用到转义符号</strong>。</li></ul></li><li><strong>注意：在 <code>[]</code> 中匹配特殊字符时，不需要用到转义符号</strong>，例如 <code>[.]</code> 表示要匹配的就是 <code>.</code> 字符本身。</li></ul><h5 id="★字符匹配符"><a href="#★字符匹配符" class="headerlink" title="★字符匹配符"></a>★字符匹配符</h5><table><thead><tr><th align="center">符号</th><th align="center">符号</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><strong><code>[]</code></strong></td><td align="center"><strong>可接收的字符列表</strong></td><td align="center"><code>[efgh]</code></td><td align="center">e、f、g、h中的任意一个字符</td></tr><tr><td align="center"><strong><code>[^]</code></strong></td><td align="center"><strong>不可接收的字符列表</strong></td><td align="center"><code>[^abc]</code></td><td align="center">除a、b、c之外的任意一个字符，包括数字和特殊符号</td></tr><tr><td align="center"><strong><code>-</code></strong></td><td align="center"><strong>连字符</strong></td><td align="center"><code>A-Z</code></td><td align="center">任意单个大写字母</td></tr><tr><td align="center"><strong><code>.</code></strong></td><td align="center"><strong>匹配除 <code>\n</code> 以外的任何字符</strong></td><td align="center"><code>a..b</code></td><td align="center">以a开头，b结尾，中间包括2个任意字符的长度为4的字符串</td></tr><tr><td align="center"><strong><code>\\d</code></strong></td><td align="center"><strong>匹配单个数字字符，相当于<code>[0-9]</code></strong></td><td align="center"><code>\\d{3}(\\d)?</code></td><td align="center">包含3个或4个数字的字符串</td></tr><tr><td align="center"><code>\\D</code></td><td align="center">匹配单个非数字字符，相当于<code>[^0-9]</code></td><td align="center"><code>\\D(\\d)*</code></td><td align="center">以单个非数字字符开头，后接任意个数字字符串</td></tr><tr><td align="center"><strong><code>\\w</code></strong></td><td align="center"><strong>匹配单个数字、大小写字母字符和下划线，相当于<code>[0-9a-zA-Z_]</code></strong></td><td align="center"><code>\\d{3}\\w{4}</code></td><td align="center">以3个数字字符开头的长度为7的数字字母下划线字符串</td></tr><tr><td align="center"><code>\\W</code></td><td align="center">匹配单个非数字、大小写字母字符、下划线，相当于<code>[^0-9a-zA-Z_]</code></td><td align="center"><code>\\W+\\d{2}</code></td><td align="center">以至少1个非数字字母下划线字符开头，2个数字字符结尾的字符串</td></tr><tr><td align="center"><code>\\s</code></td><td align="center">匹配任何空白字符（空格、制表符等）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><code>\\S</code></td><td align="center">匹配任何非空白字符，和 <code>\\s</code> 刚好相反</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li><p><strong><code>Java</code> 正则表达式默认是区分字母大小写的</strong>，可以通过<strong>使用 <code>(?i)</code> 的方式实现不区分大小写</strong>：</p><ul><li><code>(?i)abc</code> 表示 <code>abc</code> 都不区分大小写。</li><li><code>a(?i)bc</code> 表示 <code>bc</code> 不区分大小写。</li><li><code>a((?i)b)c</code> 表示只有 <code>b</code> 不区分大小写。</li></ul><p>也可以<strong>通过在创建<code>Pattern</code> 对象时，指定 <code>Pattern.CASE_INSENSITIVE</code> 实现不区分大小写</strong>：</p><ul><li><code>Pattern pattern = Pattern.compile(regExp, Pattern.CASE_INSENSITIVE);</code></li></ul></li></ul><h5 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符 |"></a>选择匹配符 |</h5><ul><li>在匹配某个字符串的时候是选择性的，即：既可以匹配这个，又可以匹配那个，这时你需要用到选择匹配符号 <code>|</code> 。</li></ul><table><thead><tr><th align="center">符号</th><th align="center">符号</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">**`</td><td align="center">`**</td><td align="center">**匹配 `”</td><td align="center">“` 之前或之后的表达式**</td></tr></tbody></table><h5 id="★限定符"><a href="#★限定符" class="headerlink" title="★限定符"></a>★限定符</h5><ul><li>用于指定其前面的字符和组合项连续出现多少次。</li></ul><table><thead><tr><th align="center">符号</th><th align="center">符号</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><strong><code>*</code></strong></td><td align="center"><strong>指定字符重复0次或n次(无要求)</strong></td><td align="center">(abc)*</td><td align="center">仅包含任意个abc的字符串</td></tr><tr><td align="center"><strong><code>+</code></strong></td><td align="center"><strong>指定字符重复1次或n次(至少一次)</strong></td><td align="center">m+(abc)*</td><td align="center">以至少1个m开头，后接任意个abc的字符串</td></tr><tr><td align="center"><strong><code>?</code></strong></td><td align="center"><strong>指定字符重复0次或1次(最多一次)</strong></td><td align="center">m+abc?</td><td align="center">以至少1个m开头，后接ab或abc的字符串</td></tr><tr><td align="center"><strong><code>{n}</code></strong></td><td align="center"><strong>只能输入n个字符</strong></td><td align="center">[abcd]{3}</td><td align="center">由abcd中字母组成的任意长度为3的字符串</td></tr><tr><td align="center"><strong><code>{n,}</code></strong></td><td align="center"><strong>指定至少n个匹配</strong></td><td align="center">[abcd]{3,}</td><td align="center">由abcd中字母组成的任意长度不小于3的字符串</td></tr><tr><td align="center"><strong><code>{n,m}</code></strong></td><td align="center"><strong>指定至少n个但不多于m个匹配</strong></td><td align="center">[abcd]{3,5}</td><td align="center">由abcd中字母组成的任意长度不小于3，不大于5的字符串</td></tr></tbody></table><ul><li>★<strong>注意：<code>Java</code> 正则表达式匹配默认是贪婪匹配，会尽可能多地匹配</strong>。例如：<ul><li>对于正则表达式 <code>1*</code> 和要匹配的字符串 <code>11111</code>，在匹配时，会优先匹配 <code>11111</code> 而不是其他的，比如 <code>空</code>、<code>1</code>、<code>11</code>等。</li><li>对于正则表达式 <code>1+</code> 和要匹配的字符串 <code>11111</code>，在匹配时，会优先匹配 <code>11111</code> 而不是其他的，比如 <code>1</code>、<code>11</code>等。</li><li>对于正则表达式 <code>a1?</code> 和要匹配的字符串 <code>a11111</code>，在匹配时，会优先匹配 <code>a1</code> 而不是 <code>a</code>。</li><li>对于正则表达式 <code>a{3,5}</code> 和要匹配的字符串 <code>aaaaa</code>，在匹配时，会优先匹配 <code>aaaaa</code> 而不是 <code>aaa</code> 或者 <code>aaaa</code>。</li></ul></li></ul><h5 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h5><ul><li>定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置。</li></ul><table><thead><tr><th align="center">符号</th><th align="center">符号</th><th align="center">示例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><strong><code>^</code></strong></td><td align="center"><strong>指定起始字符</strong></td><td align="center">^[0-9]+[a-z]*</td><td align="center">以至少1个数字开头，后接任意个小写字母的字符串</td></tr><tr><td align="center"><strong><code>$</code></strong></td><td align="center"><strong>指定结束字符</strong></td><td align="center">^[0-9]<span>\</span>-[a-z]+$</td><td align="center">以1个数字开头后接连字符 “-“，并以至少1个小写字母结尾的字符串</td></tr><tr><td align="center"><code>\\b</code></td><td align="center">匹配目标字符串的边界</td><td align="center">han<span>\</span>b</td><td align="center">这里说的<strong>字符串的边界指的是子串间有空格的地方，或者是字符串的开始或结束位置</strong></td></tr><tr><td align="center"><code>\\B</code></td><td align="center">匹配目标字符串的非边界</td><td align="center">han<span>\</span>B</td><td align="center">和 <span>\</span>b 的含义相反</td></tr></tbody></table><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><h6 id="捕获分组"><a href="#捕获分组" class="headerlink" title="捕获分组"></a>捕获分组</h6><table><thead><tr><th align="center">常用分组构造形式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong><code>(pattern)</code></strong></td><td align="center"><strong>非命名捕获</strong>。捕获匹配的子字符串。<strong>编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据<em>左括号的顺序</em>从1开始自动编号。</strong></td></tr><tr><td align="center"><strong><code>(?&lt;name&gt;pattern)</code></strong></td><td align="center"><strong>命名捕获</strong>。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如 <code>(?'name')</code> 代替 <code>(?&lt;name&gt;)</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/17 19:08</span></span><br><span class="line"><span class="comment"> * 正则表达式捕获分组例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//给定的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"s7788 nn1145java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非命名捕获</span></span><br><span class="line"><span class="comment">         *   (1)通过 matcher.group(0) 得到匹配到的字符串</span></span><br><span class="line"><span class="comment">         *   (2)通过 matcher.group(1) 得到匹配到的字符串的第一个分组的内容</span></span><br><span class="line"><span class="comment">         *   (3)通过 matcher.group(2) 得到匹配到的字符串的第二个分组的内容</span></span><br><span class="line"><span class="comment">         *   ......</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//String regExp = "(\\d\\d)(\\d\\d)";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 命名捕获</span></span><br><span class="line"><span class="comment">         *   (1)通过 matcher.group(0) 得到匹配到的字符串</span></span><br><span class="line"><span class="comment">         *   (2)通过 matcher.group(1) 或 matcher.group("g1") 得到匹配到的字符串的第一个分组的内容</span></span><br><span class="line"><span class="comment">         *   (3)通过 matcher.group(2) 或 matcher.group("g2") 得到匹配到的字符串的第二个分组的内容</span></span><br><span class="line"><span class="comment">         *   ......</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.先创建一个Pattern对象, 即模式对象, 可以理解为就是一个正则表达式对象, 传入的参数为正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="comment">//2.创建一个匹配器对象, 传入要处理的字符串</span></span><br><span class="line">        <span class="comment">//  matcher 匹配器按照 pattern(模式/样式) 到 content 文本中去匹配。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.开始循环匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {    <span class="comment">//如果找到就返回 true，否则返回 false。</span></span><br><span class="line">            <span class="comment">////非命名捕获</span></span><br><span class="line">            <span class="comment">//System.out.println("找到: " + matcher.group(0));</span></span><br><span class="line">            <span class="comment">//System.out.println("第一个分组的内容: " + matcher.group(1));</span></span><br><span class="line">            <span class="comment">//System.out.println("第二个分组的内容: " + matcher.group(2));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//命名捕获(既可以用上面非命名捕获的方法，也可以用自己独有的方法)</span></span><br><span class="line">            System.out.println(<span class="string">"找到: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">"第一个分组的内容(编号获取): "</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"第一个分组的内容(命名获取): "</span> + matcher.group(<span class="string">"g1"</span>));</span><br><span class="line">            System.out.println(<span class="string">"第二个分组的内容(编号获取): "</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">"第二个分组的内容(命名获取): "</span> + matcher.group(<span class="string">"g2"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h6><table><thead><tr><th align="center">常用分组构造形式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>(?:pattern)</code></td><td align="center">匹配 <code>pattern</code> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这**对于用 <code>"or"</code> 字符 (`”</td></tr><tr><td align="center"><code>(?=pattern)</code></td><td align="center">它是一个非捕获匹配。例如，`’Windows (?=95</td></tr><tr><td align="center"><code>(?!pattern)</code></td><td align="center">该表达式匹配不处于匹配 <code>pattern</code> 的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，`’Windows (?!95</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/17 19:19</span></span><br><span class="line"><span class="comment"> * 正则表达式非捕获分组例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp03</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//给定的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"hello小白狗 world小白猫 小白鸽! 小白"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 给定的非捕获正则表达式(?:pattern)</span></span><br><span class="line"><span class="comment">         * 匹配 `pattern` 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。</span></span><br><span class="line"><span class="comment">         * 这对于用 `"or"` 字符 (`"|"`) 组合模式部件的情况很有用。</span></span><br><span class="line"><span class="comment">         * 例如，`'industr(?:y|ies)'` 是比 `'industry|industries'` 更经济的表达式。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//传统的方式: String regExp = "小白狗|小白猫|小白鸽";</span></span><br><span class="line">        <span class="comment">//String regExp = "小白(?:狗|猫|鸽)";  //String regExp = "小白(狗|猫|鸽)"; 好像也行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 给定的非捕获正则表达式(?=pattern)</span></span><br><span class="line"><span class="comment">         * 它是一个非捕获匹配。例如，`'Windows (?=95|98|NT|2000)'` 匹配 `"Windows 2000"` 中的 `"Windows"`，</span></span><br><span class="line"><span class="comment">         * 但不匹配 `"Windows 3.1"` 中的 `"Windows"`。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//找到“小白”关键字，但是只匹配“小白狗”或者“小白猫”中的“小白”</span></span><br><span class="line">        <span class="comment">//String regExp = "小白(?=狗|猫)";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 给定的非捕获正则表达式(?!pattern)</span></span><br><span class="line"><span class="comment">         * 该表达式匹配不处于匹配 `pattern` 的字符串的起始点的搜索字符串。它是一个非捕获匹配。</span></span><br><span class="line"><span class="comment">         * 例如，`'Windows (?!95|98|NT|2000)'` 匹配 `"Windows 3.1"` 中的 `"Windows"`，</span></span><br><span class="line"><span class="comment">         * 但不匹配 `"Windows 2000"` 中的 `"Windows"`。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//找到“小白”关键字，但是不匹配“小白狗”或者“小白猫”中的“小白”，匹配其他小白</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"小白(?!狗|猫)"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.先创建一个Pattern对象, 即模式对象, 可以理解为就是一个正则表达式对象, 传入的参数为正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="comment">//2.创建一个匹配器对象, 传入要处理的字符串</span></span><br><span class="line">        <span class="comment">//  matcher 匹配器按照 pattern(模式/样式) 到 content 文本中去匹配。</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.开始循环匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {    <span class="comment">//如果找到就返回 true，否则返回 false。</span></span><br><span class="line">            System.out.println(<span class="string">"找到: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="★反向引用"><a href="#★反向引用" class="headerlink" title="★反向引用"></a>★反向引用</h5><ul><li><p>反向引用和分组、捕获之间是有关系的，所以下面再重述一次分组和捕获的概念：</p><ul><li><strong>分组</strong>：我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式 / 一个分组。</li><li><strong>捕获</strong>：把正则表达式中的子表达式 / 分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1 ，第二个为 2 ，以此类推。组 0 代表的是整个正则式。</li><li><strong>反向引用</strong>：<strong>圆括号的内容被捕获后，可以在这个括号后被使用</strong>，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，**内部反向引用 <code>\\分组号</code>，外部反向引用 <code>$分组号</code>**。</li></ul></li><li><p>反向引用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/18 11:59</span></span><br><span class="line"><span class="comment"> * 反向引用例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp04</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"hello, world123443222221!"</span>;</span><br><span class="line">        <span class="comment">//String regExp = "(\\d)\\1"; //要匹配两个连续的相同数字</span></span><br><span class="line">        <span class="comment">//String regExp = "(\\d)\\1{4}";  //要匹配五个连续的相同数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"(\\d)(\\d)\\2\\1"</span>; <span class="comment">//要匹配个位与千位相同、十位与百位相同的数字</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {</span><br><span class="line">            System.out.println(<span class="string">"找到: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h5 id="★非贪婪匹配"><a href="#★非贪婪匹配" class="headerlink" title="★非贪婪匹配 ?"></a>★非贪婪匹配 ?</h5><ul><li>当<strong>此字符 <code>?</code> 紧随任何其他限定符<code>（*、+、?、{n}、{n,}、{n,m}）</code>之后</strong>时，匹配模式是 “非贪心的”。**”非贪心的” 模式匹配搜索到尽可能短的匹配的字符串，而默认的 “贪心的” 模式匹配搜索到尽可能长的匹配字符串。**例如，在字符串 <code>"oooo"</code> 中，<code>"o+?"</code> 只匹配单个 <code>"o"</code>，而 <code>"o+"</code> 匹配所有 <code>"o"</code>。</li></ul><h4 id="正则表达式常用类"><a href="#正则表达式常用类" class="headerlink" title="正则表达式常用类"></a>正则表达式常用类</h4><h5 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h5><ul><li><p><code>pattern</code> 对象是一个正则表达式对象。<code>Pattern</code> 类没有公共构造方法。<strong>要创建一个 <code>Pattern</code> 对象需要调用其公共静态方法 <code>compile</code>，它返回一个 <code>Pattern</code> 对象</strong>。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><code>Pattern</code> 的常用方法如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/18 10:45</span></span><br><span class="line"><span class="comment"> * Pattern类的常用方法演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternMethod</span> {</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//1.matches方法，用于整体匹配，在验证输入的字符串是否满足条件时使用，</span></span><br><span class="line">    <span class="comment">//      满足时返回true，否则返回false</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     public static boolean matches(String regex, CharSequence input) {</span></span><br><span class="line"><span class="comment">     *         Pattern p = Pattern.compile(regex);</span></span><br><span class="line"><span class="comment">     *         Matcher m = p.matcher(input);</span></span><br><span class="line"><span class="comment">     *         return m.matches();</span></span><br><span class="line"><span class="comment">     *     }</span></span><br><span class="line"><span class="comment">     *     底层调用的是 Matcher 类的 matches 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">patternMatches</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"hello, world!"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"hello.*"</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> Pattern.matches(regExp, content);</span><br><span class="line">        System.out.println(<span class="string">"整体匹配为: "</span> + matches);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h5 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h5><ul><li><p><code>Matcher</code> 对象是对输入字符串进行解释和匹配的引擎。与 <code>Pattern</code> 类一样，<code>Matcher</code> 也没有公共构造方法。你<strong>需要调用 <code>Pattern</code> 对象的 <code>matcher</code> 方法来获得一个 <code>Matcher</code> 对象</strong>。</p></li><li><p><code>Matcher</code> 类的常用方法如下所示：</p><table><thead><tr><th>方法及说明</th></tr></thead><tbody><tr><td><strong><code>public int start()</code>：返回以前匹配的初始索引。</strong></td></tr><tr><td><code>public int start(int group)</code>：返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引。</td></tr><tr><td><strong><code>public int end()</code>：返回最后匹配字符之后的偏移量。</strong></td></tr><tr><td><code>public int end(int group)</code>：返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr><tr><td><code>public boolean lookingAt()</code>：尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td><code>public boolean find()</code>：尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td><code>public boolean find(int start)</code>：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td><code>public boolean matches()</code>：尝试将整个区域与模式匹配。</td></tr><tr><td><strong><code>public String replaceAll(String replacement)</code>：将与给定模式相匹配的输入序列的每个子序列替换为给定的字符串。方法返回的才是替换后的结果。</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/18 11:00</span></span><br><span class="line"><span class="comment"> * Matcher类的常用方法演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatcherMethod</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//要匹配的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"hello, world! hello smith"</span>;</span><br><span class="line">        <span class="comment">//指定的正则表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line">        <span class="comment">//1.创建pattern对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regExp);</span><br><span class="line">        <span class="comment">//2.创建matcher对象</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3.得到匹配结果</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) {</span><br><span class="line">            System.out.println(<span class="string">"============"</span>);</span><br><span class="line">            <span class="comment">//(1)`public int start()`：返回以前匹配的初始索引。</span></span><br><span class="line">            System.out.println(<span class="string">"匹配的内容的开始索引 = "</span> + matcher.start());</span><br><span class="line">            <span class="comment">//(2)`public int end()`：返回最后匹配字符之后的偏移量。</span></span><br><span class="line">            System.out.println(<span class="string">"匹配的内容的结束索引 + 1 = "</span> + matcher.end());</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3)`public String replaceAll(String replacement)`：将与给定模式相匹配的输入序列的每个子序列替换为给定的字符串。方法返回的才是替换后的结果。</span></span><br><span class="line">        <span class="comment">// 将上面内容中的 hello 替换为 hi</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newContent</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">"hi"</span>);</span><br><span class="line">        System.out.println(content);    <span class="comment">//hello, world! hello smith</span></span><br><span class="line">        System.out.println(newContent); <span class="comment">//hi, world! hi smith</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="String类中使用正则表达式"><a href="#String类中使用正则表达式" class="headerlink" title="String类中使用正则表达式"></a>String类中使用正则表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.f.chapter22.regexp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/18 15:28</span></span><br><span class="line"><span class="comment"> * String类中使用正则表达式</span></span><br><span class="line"><span class="comment"> * 替换、分割、匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReg</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//1.替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了Apple公司Mac OS X的工业标准的支持。"</span>;</span><br><span class="line">        <span class="comment">//使用正则表达式将 JDK1.3、JDK1.4 替换为 JDK</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regExp</span> <span class="operator">=</span> <span class="string">"JDK1\\.[34]"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newContent</span> <span class="operator">=</span> content.replaceAll(regExp, <span class="string">"JDK"</span>);</span><br><span class="line">        System.out.println(newContent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.分割</span></span><br><span class="line">        content = <span class="string">"hello#abc-jack12smith~北京"</span>;</span><br><span class="line">        <span class="comment">//使用正则表达式按照 #、-、~、数字 来进行分割</span></span><br><span class="line">        regExp = <span class="string">"#|-|~|\\d+"</span>;</span><br><span class="line">        String[] split = content.split(regExp);</span><br><span class="line">        <span class="keyword">for</span> (String substring : split) {</span><br><span class="line">            System.out.println(<span class="string">"分割: "</span> + substring);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.匹配</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="string">"13988888888"</span>;</span><br><span class="line">        <span class="comment">//使用正则表达式判断手机号是否为 138、139 开头</span></span><br><span class="line">        regExp = <span class="string">"13[89]\\d{8}"</span>;</span><br><span class="line">        System.out.println(<span class="string">"手机号是否为 138、139 开头: "</span> + phone.matches(regExp));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2023/07/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">https://running-noob.github.io/2023/07/29/正则表达式/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2023/07/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" rel="prev" title="数据库连接池"><i class="fa fa-chevron-left"></i> 数据库连接池</a></div><div class="post-nav-item"><a href="/2023/08/03/Invasive-Weed-Optimization-algorithm/" rel="next" title="Invasive Weed Optimization algorithm">Invasive Weed Optimization algorithm <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">★第二十二章 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-text">正则表达式快速入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">★正则表达式底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#matcher-find"><span class="nav-text">matcher.find()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#matcher-group-0"><span class="nav-text">matcher.group(0)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85matcher-group-i"><span class="nav-text">★matcher.group(i)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85%E2%98%85%E2%98%85%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">★★★正则表达式语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E8%BD%AC%E4%B9%89%E7%AC%A6"><span class="nav-text">★转义符 \</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="nav-text">★字符匹配符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="nav-text">选择匹配符 |</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-text">★限定符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="nav-text">定位符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%BB%84"><span class="nav-text">分组</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84"><span class="nav-text">捕获分组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84"><span class="nav-text">非捕获分组</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="nav-text">★反向引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D"><span class="nav-text">★非贪婪匹配 ?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-text">正则表达式常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pattern"><span class="nav-text">Pattern</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Matcher"><span class="nav-text">Matcher</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">String类中使用正则表达式</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算、边缘计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">247</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">474k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:44</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
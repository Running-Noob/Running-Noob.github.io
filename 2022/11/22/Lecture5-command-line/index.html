<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。 我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。 我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于"><meta property="og:type" content="article"><meta property="og:title" content="Lecture5-command-line"><meta property="og:url" content="https://running-noob.github.io/2022/11/22/Lecture5-command-line/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="当您使用 shell 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。 我们已经使用 shell 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。 我们还将学习一些能够改善您的 shell 及其他工具的工作流的方法，这主要是通过定义别名或基于"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://running-noob.github.io/Running%20Noob/%E8%AE%A1%E7%AE%97%E6%9C%BA/Typora%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-git%E4%BB%93%E5%BA%93/The-Missing-Semester-of-Your-CS-Education/img/apt%E5%91%BD%E4%BB%A4.png"><meta property="article:published_time" content="2022-11-22T12:45:39.000Z"><meta property="article:modified_time" content="2023-12-14T12:54:52.718Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://running-noob.github.io/Running%20Noob/%E8%AE%A1%E7%AE%97%E6%9C%BA/Typora%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-git%E4%BB%93%E5%BA%93/The-Missing-Semester-of-Your-CS-Education/img/apt%E5%91%BD%E4%BB%A4.png"><link rel="canonical" href="https://running-noob.github.io/2022/11/22/Lecture5-command-line/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Lecture5-command-line | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">241</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2022/11/22/Lecture5-command-line/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Lecture5-command-line</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-22 20:45:39" itemprop="dateCreated datePublished" datetime="2022-11-22T20:45:39+08:00">2022-11-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-14 20:54:52" itemprop="dateModified" datetime="2023-12-14T20:54:52+08:00">2023-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/The-Missing-Semester-of-Your-CS-Education/" itemprop="url" rel="index"><span itemprop="name">The Missing Semester of Your CS Education</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li><p>当您使用 <code>shell</code> 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p><p>我们已经使用 <code>shell</code> 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会<strong>学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行</strong>。</p><p>我们还将学习一些能够改善您的 <code>shell</code> 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p></li></ul></blockquote><span id="more"></span><h2 id="Lecture-5-Command-line-Environment"><a href="#Lecture-5-Command-line-Environment" class="headerlink" title="Lecture 5 Command-line Environment"></a>Lecture 5 Command-line Environment</h2><ul><li><p>当您使用 <code>shell</code> 进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p><p>我们已经使用 <code>shell</code> 一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会<strong>学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行</strong>。</p><p>我们还将学习一些能够改善您的 <code>shell</code> 及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用 SSH 操作远端机器。</p></li></ul><h3 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h3><ul><li>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。<strong>大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行</strong>。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</li></ul><h4 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h4><h5 id="ctrl-c、ctrl-、★kill、★ps、top"><a href="#ctrl-c、ctrl-、★kill、★ps、top" class="headerlink" title="ctrl+c、ctrl+\、★kill、★ps、top"></a>ctrl+c、ctrl+\、★kill、★ps、top</h5><ul><li><p>您的 <code>shell</code> 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。-&gt; 就这一点而言，信号是一种软件<strong>中断</strong>。</p><p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> （Signal Interrupt）信号到进程。</p><p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> （Signal Quit）信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> signal, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">signum, time</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nI got a SIGINT, but I am not stopping"</span>)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\r{}"</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次 <code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code> 是我们在终端输入<code>Ctrl</code> 时的表示形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ python sigint.py </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">^\退出 (核心已转储)</span><br></pre></td></tr></table></figure><p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <code>kill</code> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p><ul><li><p><strong><code>kill</code><strong>：</strong>用于删除执行中的程序或工作</strong>。<code>kill</code> 可<strong>将指定的信息送至程序</strong>，预设的信息为 <code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用 <code>SIGKILL(9)</code> 信息尝试强制删除程序。程序或工作的编号可利用 <code>ps</code> 指令或 <code>jobs</code> 指令查看。</p><p><code>kill</code> 命令的基本格式如下：<code>kill [-s 信号声明 | -n 信号编号 | -信号声明] 进程号(PID)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死指定用户所有进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -KILL $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -u hnlinux //方法二</span></span><br></pre></td></tr></table></figure><ul><li>最常用的信号是：<ul><li><code>1 (HUP)</code>：重新加载进程，如果想要更改配置而不需停止并重新启动服务，请使用该命令。 -&gt; HangUP</li><li><code>9 (KILL)</code>：杀死一个进程。<ul><li><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</li></ul></li><li><code>15 (TERM)</code>：正常停止一个进程。 -&gt; Terminate</li></ul></li></ul></li><li><p><strong><code>ps</code><strong>：用于</strong>显示当前进程的状态</strong>，类似于 windows 的任务管理器。 -&gt; （process status）</p><p><code>ps</code> 命令的基本格式如下：<code>ps [选项]</code></p><ul><li><code>-a</code>：显示现行终端机下的所有程序，包括其他用户的程序</li><li><code>-A</code>：显示所有进程</li><li><code>-u</code>：以用户为主的格式来显示程序状况</li><li><code>-x</code>：显示所有程序，不以终端机来区分</li><li><code>-e</code>：显示所有进程，同<code>“-A”</code></li><li><code>-f</code>：显示进程之间的关系</li></ul><p>注意：一般 <code>-ef</code> 、<code>-aux</code> 联合起来使用，即 <code>ps -ef</code> 、<code>ps -aux</code> 来查看进程信息。</p></li><li><p><code>top</code>：用于实时显示 process 的动态。</p><p>显示指定 pid 的进程的信息：<code>top -p pid</code></p></li></ul></li></ul><h4 id="暂停和后台执行进程"><a href="#暂停和后台执行进程" class="headerlink" title="暂停和后台执行进程"></a>暂停和后台执行进程</h4><h5 id="ctrl-z、fg、bg、-、★jobs"><a href="#ctrl-z、fg、bg、-、★jobs" class="headerlink" title="ctrl+z、fg、bg、&、★jobs"></a>ctrl+z、fg、bg、&amp;、★jobs</h5><ul><li><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p><p>我们可以使用 <code>fg</code> 或 <code>bg</code> 命令恢复暂停的工作。它们分别表示在<strong>前台</strong>继续或在<strong>后台</strong>继续。</p><ul><li><p><strong><code>fg</code><strong>：用于</strong>把后台工作恢复到前台执行</strong>。 -&gt; foreground</p><p>该命令的基本格式如下：<code>[root@localhost ~]#fg %工作号</code></p><p>注意，在使用此命令时，<code>％</code> 可以省略，但若将 <code>% 工作号</code> 全部省略，则此命令会将带有 + 号的工作恢复到前台。</p></li><li><p><strong><code>bg</code><strong>：用于</strong>把后台暂停的工作恢复到后台执行</strong>。 -&gt; background</p><p>该命令的基本格式如下：<code>[root@localhost ~]#bg %工作号</code></p></li></ul></li><li><p><code>jobs</code> 命令会<strong>列出当前终端会话中尚未完成的全部任务</strong>。您可以使用 pid 引用这些任务。更加符合直觉的操作是您可以使用<code>百分号 + 任务编号</code>（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p><ul><li><p><strong><code>jobs</code><strong>：用来</strong>查看当前终端放入后台的工作</strong>。</p><p><code>jobs</code> 命令的基本格式如下：<code>[root@localhost ~]#jobs [选项]</code></p><ul><li><code>-l</code>：列出进程的 PID 号。</li><li><code>-r</code>：只列出运行中的进程。</li><li><code>-s</code>：只列出已停止的进程。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#jobs -l</span><br><span class="line">[1]- 2023 Stopped top</span><br><span class="line">[2]+ 2034 Stopped tar -zcf etc.tar.gz /etc</span><br></pre></td></tr></table></figure><p>在上面的例子中，当前终端有两个后台工作：一个是 <code>top</code> 命令，工作号为 1，状态是暂停，标志是<code>"-"</code>；另一个是 <code>tar</code> 命令，工作号为 2，状态是暂停，标志是<code>"+"</code>。**<code>"+"</code>号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作<strong>。</strong><code>"-"</code>号代表倒数第二个放入后台的工作**，而第三个以后的工作就没有<code>"+-"</code>标志了。</p><p>一旦当前的默认工作处理完成，则带减号的工作就会自动成为新的默认工作，换句话说，不管此时有多少正在运行的工作，任何时间都会有且仅有一个带加号的工作和一个带减号的工作。</p></li></ul></li><li><p>还有一件事情需要掌握，那就是<strong>命令中的 <code>&amp;</code> 后缀可以让命令直接在后台运行</strong>，这使得您可以直接在 <code>shell</code> 中继续做其他操作，不过它此时还是会使用 <code>shell</code> 的标准输出，这一点有时会比较恼人（这种情况可以使用 <code>shell</code> 重定向处理）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ sleep 1000 &amp;</span><br><span class="line">[1] 2945</span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br><span class="line">[1]+  2945 运行中               sleep 1000 &amp;</span><br></pre></td></tr></table></figure><p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <code>nohup</code> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p></li><li><p>下面这个简单的会话中展示了这些概念的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]+  已停止               sleep 1000</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 2984</span><br><span class="line">忽略输入并把输出追加到'nohup.out'</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs</span><br><span class="line">[1]+  已停止               sleep 1000</span><br><span class="line">[2]-  运行中               nohup sleep 2000 &amp;</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ bg %1</span><br><span class="line">[1]+ sleep 1000 &amp;</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br><span class="line">[1]-  2983 运行中               sleep 1000 &amp;</span><br><span class="line">[2]+  2984 运行中               nohup sleep 2000 &amp;</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ kill -STOP %1</span><br><span class="line">[1]+  已停止               sleep 1000</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br><span class="line">[1]+  2983 停止 (信号)         sleep 1000</span><br><span class="line">[2]-  2984 运行中               nohup sleep 2000 &amp;</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ kill -SIGHUP %1</span><br><span class="line">[1]+  挂起                  sleep 1000</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br><span class="line">[2]+  2984 运行中               nohup sleep 2000 &amp;</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ kill -SIGHUP %2</span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br><span class="line">[2]+  2984 运行中               nohup sleep 2000 &amp;				#因为是nohup，所以 kill -SIGHUP 对该进程无效</span><br><span class="line"></span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ kill %2</span><br><span class="line">[2]+  已终止               nohup sleep 2000</span><br><span class="line">god@god-virtual-machine:~/桌面/missing-semester/command-line environment$ jobs -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h4 id="★apt"><a href="#★apt" class="headerlink" title="★apt"></a>★apt</h4><ul><li><p>软件包：通常指的是一个应用程序，它可以是一个 GUI 应用程序、命令行工具或（其他软件程序需要的）软件库。</p></li><li><p>软件包管理：</p><ul><li>底层工具：主要用来处理安装和删除软件包文件等任务：DPKG，RPM</li><li>上层工具：主要用于数据的搜索任务和依赖解析任务：<strong>APT</strong>，<strong>YUM</strong>，DNF</li></ul><p>![](../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/软件包管理.png)</p></li><li><p>以 Ubuntu 操作系统为例，我们通过使用 <code>apt</code> 工具来进行软件包的管理。</p><img src="../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/apt命令.png" style="zoom:80%"></li></ul><h3 id="★终端多路复用"><a href="#★终端多路复用" class="headerlink" title="★终端多路复用"></a>★终端多路复用</h3><h4 id="★tmux"><a href="#★tmux" class="headerlink" title="★tmux"></a>★tmux</h4><ul><li><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可能想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p><p>像 <code>tmux</code> （terminal multiplexer）这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p><p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接，这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p></li><li><p>现在最流行的终端多路器是 <code>tmux</code>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p><ul><li><strong>会话</strong>：每个会话都是一个独立的工作区，其中包含一个或多个窗口。<ul><li><strong><code>tmux</code> 开始一个新的会话</strong></li><li><strong><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</strong></li><li><strong><code>tmux ls</code> 列出当前所有会话</strong></li><li><strong>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</strong></li><li><strong><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话，如 <code>tmux a -t foobar</code></strong></li></ul></li><li><strong>窗口</strong> ：相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul><li><strong><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</strong></li><li><strong><code>&lt;C-b&gt; N</code> 跳转到第 N 个窗口，注意每个窗口都是有编号的</strong></li><li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li><li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li><li><strong><code>&lt;C-b&gt; ,</code> 重命名当前窗口</strong></li><li><strong><code>&lt;C-b&gt; w</code> 列出当前所有窗口</strong></li></ul></li><li><strong>面板</strong> ：像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 <code>shell</code><ul><li><strong><code>&lt;C-b&gt; "</code> 水平分割</strong></li><li><strong><code>&lt;C-b&gt; %</code> 垂直分割</strong></li><li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li><li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放，按一次 <code>ctrl+b z</code>最大化当前面板，再按一次恢复原来大小</li><li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li></ul></li></ul></li></ul><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><ul><li><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 <code>shell</code> 都支持设置别名。<code>shell</code> 的别名相当于一个长命令的缩写，<code>shell</code> 会自动将其替换成原本的命令。例如，<code>bash</code> 中的别名语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias alias_name="command_to_alias arg1 arg2"</span><br></pre></td></tr></table></figure><p>注意， <code>=</code>两边是没有空格的，因为 <code>alias</code> 是一个 <code>shell</code> 命令，它只接受一个参数。</p><p>值得注意的是，在默认情况下 <code>shell</code> 并不会保存别名。为了让别名持续生效，您需要将配置放进 <code>shell</code> 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p><p>别名有许多很方便的特性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建常用命令的缩写</span></span><br><span class="line">alias ll="ls -lh"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">能够少输入很多</span></span><br><span class="line">alias gs="git status"</span><br><span class="line">alias gc="git commit"</span><br><span class="line">alias v="vim"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手误打错命令也没关系</span></span><br><span class="line">alias sl=ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新定义一些命令行的默认行为</span></span><br><span class="line">alias mv="mv -i"           # -i prompts before overwrite</span><br><span class="line">alias mkdir="mkdir -p"     # -p make parent dirs as needed</span><br><span class="line">alias df="df -h"           # -h prints human readable format</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">别名可以组合使用</span></span><br><span class="line">alias la="ls -A"</span><br><span class="line">alias lla="la -l"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在忽略某个别名</span></span><br><span class="line">\ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者禁用别名</span></span><br><span class="line">unalias la</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取别名的定义</span></span><br><span class="line">alias ll</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会打印 ll=<span class="string">'ls -lh'</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>alias</code><strong>：</strong>用于设置指令的别名</strong>。用户可利用<code>alias</code>，自定指令的别名。若仅输入<code>alias</code>，则可列出目前所有的别名设置。<code>alias</code>的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在<code>.profile</code>或<code>.cshrc</code>中设定指令的别名。</p><p>该命令的基本格式如下：<code>[root@localhost ~]#alias [别名]=[指令名称]</code></p></li></ul></li></ul><h3 id="★配置文件-Dotfiles"><a href="#★配置文件-Dotfiles" class="headerlink" title="★配置文件(Dotfiles)"></a>★配置文件(Dotfiles)</h3><ul><li><p>很多程序的配置都是通过纯文本格式的被称作<strong>点文件</strong>的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p><p><code>shell</code> 的配置也是通过这类文件完成的。在启动时，您的 <code>shell</code> 程序会读取很多文件以加载其配置项。根据 <code>shell</code> 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。</p><p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p><p>实际上，很多程序都要求您在 <code>shell</code> 的配置文件中包含一行类似 <code>export PATH="$PATH:/path/to/program/bin"</code> 的命令，这样才能确保这些程序能够被 <code>shell</code> 找到。</p><p>还有一些其他的工具也可以通过点文件进行配置：</p><ul><li><strong><code>bash</code> ： <code>~/.bashrc</code>, <code>~/.bash_profile</code></strong></li><li><strong><code>git</code> ： <code>~/.gitconfig</code></strong></li><li><strong><code>vim</code> ： <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</strong></li><li><strong><code>ssh</code> ： <code>~/.ssh/config</code></strong></li><li><strong><code>tmux</code> ： <code>~/.tmux.conf</code></strong></li></ul></li><li><p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong>（symlinks） 到需要的地方。这么做有如下好处：</p><ul><li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li><li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li><li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li><li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul></li></ul><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><ul><li><p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 <code>shell</code> 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [[ "$(uname)" == "Linux" ]]; then {do_something}; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用和 shell 相关的配置时先检查当前 shell 类型</span></span><br><span class="line">if [[ "$SHELL" == "zsh" ]]; then {do_something}; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">您也可以针对特定的设备进行配置</span></span><br><span class="line">if [[ "$(hostname)" == "myServer" ]]; then {do_something}; fi</span><br></pre></td></tr></table></figure><p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure><p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test <span class="keyword">if</span> ~/.aliases exists and <span class="built_in">source</span> it</span></span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><h3 id="★远端设备"><a href="#★远端设备" class="headerlink" title="★远端设备"></a>★远端设备</h3><h5 id="★ssh、ssh-keygen、★scp"><a href="#★ssh、ssh-keygen、★scp" class="headerlink" title="★ssh、ssh-keygen、★scp"></a>★ssh、ssh-keygen、★scp</h5><ul><li><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到 <code>secure shell</code>（<code>SSH</code>）。和其他工具一样，<code>SSH</code> 也是可以高度定制的，也值得我们花时间学习它。</p><p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh foo@bar.mit.edu</span></span><br></pre></td></tr></table></figure><p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 <code>ssh</code> 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p><ul><li><p><strong><code>ssh</code><strong>：用于</strong>登录远程机器并在远程机器上执行命令</strong>。 -&gt; （secure shell）</p><p>该命令的基本格式如下：<code>[root@localhost ~]#ssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND]</code></p></li></ul></li></ul><h4 id="★执行命令"><a href="#★执行命令" class="headerlink" title="★执行命令"></a>★执行命令</h4><ul><li><code>ssh</code> 的一个经常被忽视的特性是它<strong>可以直接远程执行命令</strong>。 <code>ssh foobar@server ls</code> 可以直接用 <code>foobar</code> 的用户身份在服务器上执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</li></ul><h4 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h4><ul><li>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</li></ul><h5 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h5><ul><li><p>使用 <code>ssh-keygen</code> 命令可以生成一对密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <code>ssh-agent</code> 或 <code>gpg-agent</code> ，这样就不需要每次都输入该密码了。</p><ul><li><p>**<code>ssh-keygen</code>**：用于 <code>OpenSSH</code> 身份验证密钥的生成、管理和转换，它支持 RSA 和 DSA 两种认证密钥。-&gt;（ssh key generate）</p><p>该命令的基本格式如下：<code>[root@localhost ~]#ssh-keygen [OPTIONS] &lt;file&gt;...</code></p><ul><li><code>-a</code> ：rounds，保存私钥时，此选项指定使用的 KDF（密钥派生函数）轮数。</li><li><code>-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | RSA</code> ：指定要创建的密钥类型，可能的值为“dsa”、“ecdsa”、“ecdsa-sk”、“ed25519”、“ed25519-sk”或“rsa”。</li><li><code>-f</code> ：指定密钥文件的文件名。</li></ul></li></ul></li></ul><h5 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h5><ul><li><p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将前面生成的公钥拷贝到服务器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .ssh/id_ed25519.pub | ssh foobar@remote <span class="string">'cat &gt;&gt; ~/.ssh/authorized_keys'</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通过-SSH-复制文件"><a href="#通过-SSH-复制文件" class="headerlink" title="通过 SSH 复制文件"></a>通过 SSH 复制文件</h4><ul><li>使用 <code>ssh</code> 复制文件有很多方法：<ul><li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。</li><li><code>scp</code> ：当需要拷贝大量的文件或目录时，使用 <code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file user@remote_host:path/to/remote_file</code>。</li><li><code>rsync</code> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code>标记实现断点续传。<code>rsync</code> 的语法和<code>scp</code>类似。</li></ul></li></ul><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><ul><li><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p><p>此时就需要进行端口转发。端口转发有两种：本地端口转发和远程端口转发。</p></li></ul><h5 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h5><ul><li>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</li></ul><h4 id="★SSH-配置"><a href="#★SSH-配置" class="headerlink" title="★SSH 配置"></a>★SSH 配置</h4><ul><li><p>我们可以使用 <code>~/.ssh/config</code> 来进行 <code>ssh</code> 配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"></span><br><span class="line"># 在配置文件中也可以使用通配符</span><br><span class="line">#Host *.mit.edu</span><br><span class="line">#    User foobaz</span><br></pre></td></tr></table></figure><p>这时我们就不需要使用 <code>ssh foobar@172.16.174.141</code> 来访问远端设备了，而只需要使用命令 <code>ssh vm</code> 即可。</p><p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，<strong>类似 <code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项</strong>。</p><p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p><p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2022/11/22/Lecture5-command-line/" title="Lecture5-command-line">https://running-noob.github.io/2022/11/22/Lecture5-command-line/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/11/21/Lecture4-data-wrangling/" rel="prev" title="Lecture4-data wrangling"><i class="fa fa-chevron-left"></i> Lecture4-data wrangling</a></div><div class="post-nav-item"><a href="/2022/11/25/Lecture6-version-control-git/" rel="next" title="Lecture6-version control - git">Lecture6-version control - git <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-5-Command-line-Environment"><span class="nav-text">Lecture 5 Command-line Environment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">任务控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="nav-text">结束进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ctrl-c%E3%80%81ctrl-%E3%80%81%E2%98%85kill%E3%80%81%E2%98%85ps%E3%80%81top"><span class="nav-text">ctrl+c、ctrl+\、★kill、★ps、top</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E5%81%9C%E5%92%8C%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B"><span class="nav-text">暂停和后台执行进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ctrl-z%E3%80%81fg%E3%80%81bg%E3%80%81-%E3%80%81%E2%98%85jobs"><span class="nav-text">ctrl+z、fg、bg、&amp;、★jobs</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86"><span class="nav-text">软件包管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85apt"><span class="nav-text">★apt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E7%BB%88%E7%AB%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">★终端多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85tmux"><span class="nav-text">★tmux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%AB%E5%90%8D"><span class="nav-text">别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-Dotfiles"><span class="nav-text">★配置文件(Dotfiles)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-text">可移植性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E8%BF%9C%E7%AB%AF%E8%AE%BE%E5%A4%87"><span class="nav-text">★远端设备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%98%85ssh%E3%80%81ssh-keygen%E3%80%81%E2%98%85scp"><span class="nav-text">★ssh、ssh-keygen、★scp</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-text">★执行命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSH-%E5%AF%86%E9%92%A5"><span class="nav-text">SSH 密钥</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="nav-text">密钥生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="nav-text">基于密钥的认证机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-SSH-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-text">通过 SSH 复制文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="nav-text">端口转发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="nav-text">本地端口转发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85SSH-%E9%85%8D%E7%BD%AE"><span class="nav-text">★SSH 配置</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">241</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">466k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:15</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
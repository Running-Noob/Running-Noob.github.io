<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="数据处理"><meta property="og:type" content="article"><meta property="og:title" content="Lecture4-data wrangling"><meta property="og:url" content="https://running-noob.github.io/2022/11/21/Lecture4-data-wrangling/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="数据处理"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-11-21T12:45:22.000Z"><meta property="article:modified_time" content="2023-12-14T12:56:31.095Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://running-noob.github.io/2022/11/21/Lecture4-data-wrangling/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Lecture4-data wrangling | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">242</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2022/11/21/Lecture4-data-wrangling/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Lecture4-data wrangling</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-21 20:45:22" itemprop="dateCreated datePublished" datetime="2022-11-21T20:45:22+08:00">2022-11-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-14 20:56:31" itemprop="dateModified" datetime="2023-12-14T20:56:31+08:00">2023-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/The-Missing-Semester-of-Your-CS-Education/" itemprop="url" rel="index"><span itemprop="name">The Missing Semester of Your CS Education</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>数据处理</li></ul></blockquote><span id="more"></span><h2 id="Lecture-4-Data-Wrangling"><a href="#Lecture-4-Data-Wrangling" class="headerlink" title="Lecture 4 Data Wrangling"></a>Lecture 4 Data Wrangling</h2><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><h4 id="less、★sed、★grep"><a href="#less、★sed、★grep" class="headerlink" title="less、★sed、★grep"></a>less、★sed、★grep</h4><ul><li><p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p><p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p><p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p></li><li><p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：<strong>用来整理的数据以及相关的应用场景</strong>。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br></pre></td></tr></table></figure><p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl | grep sshd</span><br></pre></td></tr></table></figure><p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！ <code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' | less</span><br></pre></td></tr></table></figure><p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们<strong>先在远端机器上过滤文本内容，然后再将结果传输到本机</strong>。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。</p><ul><li><p><strong><code>less</code><strong>：less 命令的作用和 more 十分类似，都</strong>用来浏览文本文件中的内容</strong>，不同之处在于，使用 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。</p><p><code>less</code> 命令的基本格式如下：<code>less [参数] 文件</code></p></li></ul><p>为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh myserver <span class="string">'journalctl | grep sshd | grep "Disconnected from"'</span> &gt; ssh.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ssh.log</span></span><br></pre></td></tr></table></figure><p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p></li><li><p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的”流编辑器” 。在 <code>sed</code> 中，您基本上是<strong>利用一些简短的命令来修改文件，而不是直接操作文件的内容</strong>（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即替换命令，例如我们可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed 's/.*Disconnected from //'</span><br></pre></td></tr></table></figure><p>上面这段命令中，我们使用了一段简单的正则表达式，对于过滤出来的信息，把一行中匹配正则表达式<code>“.*Disconnected from ”</code>的文本替换为空格。</p><p>正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。</p><ul><li><p><strong><code>sed</code><strong>：sed 命令可依照脚本的指令来处理、编辑文本文件，可以对文本文件进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，</strong>特别适合于大文件的编辑，同时在脚本中运用</strong>。</p><p>例如 <code>sed -i 's/hello/nihao/' test.txt</code> 是将 <code>test.txt</code> 文件的所有 “hello” 字符串转换为 “nihao” 字符串。</p><ul><li><code>-i</code>是直接修改要处理的文件，默认为预览。</li></ul><p><code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p></li><li><p>**<code>grep</code>**：很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 grep 命令。 -&gt; （Globally search a Regular Expression and Print）</p><p>grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。</p><p>grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p><p><strong>grep 命令的基本格式如下：<code>[root@localhost ~]# grep [选项] 模式(正则表达式) 文件名</code></strong></p><ul><li><code>-E</code>：支持使用扩展的正则表达式</li><li><code>-i</code>：ignorecase，搜索时忽略字符的大小写</li><li><code>-v</code>：–invert-match，显示不能被模式匹配到的行</li></ul></li></ul></li></ul><h3 id="★正则表达式"><a href="#★正则表达式" class="headerlink" title="★正则表达式"></a>★正则表达式</h3><ul><li><p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code> 开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化。常见的模式有：</p><ul><li><code>.</code> 除换行符之外的”任意<strong>单个</strong>字符”</li><li><code>*</code> 匹配前面字符零次或多次</li><li><code>+</code> 匹配前面字符一次或多次</li><li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li><li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li><li><code>^</code> 行首</li><li><code>$</code> 行尾</li></ul></li><li><p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure><p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是<strong>贪婪模式</strong>，也就是说，它们会<strong>尽可能多的匹配文本</strong>。因此对上述字符串的处理结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure><p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以<strong>给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式</strong>，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe 's/.*?Disconnected from //'</span><br></pre></td></tr></table></figure></li><li><p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p><p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p><p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [0-9.]+ port [0-9]+( \[preauth\])?$//'</span><br></pre></td></tr></table></figure><p>让我们借助正则表达式在线调试工具 <a target="_blank" rel="noopener" href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user” （<code>(invalid | authenticating )?</code>，在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符 （<code>.*</code>） 。接着，再匹配 ip（<code>[0-9.]+</code> ）。紧接着后面匹配单词<code>“port”</code>和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾 <code>$</code> 。</p><p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“<strong>捕获组（capture groups）</strong>”来完成。<strong>被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中</strong>。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、 <code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from" </span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [0-9.]+ port [0-9]+( \[preauth\])?$/\2/'</span><br></pre></td></tr></table></figure><ul><li><p>相较于上面，这里把匹配用户名的 <code>.*</code> 用圆括号括起来了 <code>(.*)</code> ，并且捕获后用 <code>\2</code> 存储。</p><p><code>\1</code> 存储捕获的 <code>(invalid |authenticating )?</code></p><p><code>\2</code> 存储捕获的 <code>(.*)</code></p><p><code>\3</code> 存储捕获的 <code>( \[preauth\])?</code></p></li></ul></li></ul><h3 id="回到数据整理"><a href="#回到数据整理" class="headerlink" title="回到数据整理"></a>回到数据整理</h3><h4 id="sort、uniq、paste、wc"><a href="#sort、uniq、paste、wc" class="headerlink" title="sort、uniq、paste、wc"></a>sort、uniq、paste、wc</h4><ul><li><p>OK，现在我们有如下表达式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br></pre></td></tr></table></figure><p>现在，我们已经<strong>得到了一个包含用户名的列表</strong>，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br><span class="line"> | sort | uniq -c</span><br></pre></td></tr></table></figure><p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br></pre></td></tr></table></figure><p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序），<code>-k1,1</code> 则表示“仅基于以空格分割的第一列进行排序”。<code>,1</code> 部分表示“仅排序到第1个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p><ul><li><p><strong><code>sort</code><strong>：Linux sort 命令</strong>用于将文本文件内容加以排序</strong>，sort 可针对文本文件的内容，以行为单位来排序。</p><p><code>sort</code> 命令的基本格式如下：<code>sort [选项] 文件</code></p><ul><li><code>-n</code>：依照数值的大小排序。</li><li><code>[-k field1[,field2]]</code>：按指定的列进行排序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sort</span> testfile	<span class="comment">#以默认的方式将文本文件的第一列以 ASCII 码的次序排列，并将结果输出到标准输出</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sort</span> -k2 testfile	<span class="comment">#使用 -k 参数设置对第二列的值进行重排</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>uniq</code><strong>：用于</strong>检查及删除文本文件中重复出现的行列</strong>，一般与 sort 命令结合使用。 -&gt; （unique）</p><p><code>uniq</code> 命令的基本格式如下：<code>uniq [选项] 文件</code></p><ul><li><code>-c</code>：在每列旁边显示该行重复出现的次数。</li></ul></li></ul><p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code> 来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p><p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | awk '{print $2}' | paste -sd,</span><br></pre></td></tr></table></figure><p>我们可以利用 <code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，这里指定的分隔符是 <code>“,”</code>。</p><ul><li><p>**<code>paste</code>**：用于合并文件的列，<code>paste</code> 指令会把每个文件以列对列的方式，一列列地加以合并。</p><p><code>paste</code> 命令的基本格式如下：<code>paste [选项] 文件</code></p><ul><li><code>-s</code>：串列进行而非平行处理。</li><li><code>-d&lt;间隔字符&gt;</code>：用指定的间隔字符取代跳格字符。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">paste</span> file testfile testfile1		<span class="comment">#合并指定文件的内容</span></span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">paste</span> -s file		<span class="comment">#合并指定文件的多行数据</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>wc</code><strong>：</strong>用于计算字数</strong>。利用 <code>wc</code> 指令我们可以计算文件的 Byte 数、字数、或是行数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 -&gt; （word count）</p><p><code>wc</code> 命令的基本格式如下：<code>wc [选项] 文件</code></p><ul><li><code>-c</code>：显示Bytes数。</li><li><code>-l</code>：显示行数。</li><li><code>-w</code>：显示字数。</li></ul></li></ul><p>那<code>awk</code>的作用又是什么呢？</p></li></ul><h3 id="★awk-–-另外一种编辑器"><a href="#★awk-–-另外一种编辑器" class="headerlink" title="★awk – 另外一种编辑器"></a>★awk – 另外一种编辑器</h3><h4 id="★awk"><a href="#★awk" class="headerlink" title="★awk"></a>★awk</h4><ul><li><p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p><p>和 sed 命令类似，awk 命令也是<strong>逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理</strong>。</p><ul><li><p><strong><code>awk</code></strong> 命令的基本格式为：<code>[root@localhost ~]# awk [选项] '匹配规则{执行命令}' 文件名</code></p><ul><li><code>-F fs</code>：指定以 fs 作为输入行的分隔符，<code>awk</code> 命令默认分隔符为空格或制表符。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">god@god-virtual-machine:~/桌面/missing-semester/data wrangling$ awk -F, '/nihao/{print "foo"}' 1.txt </span><br></pre></td></tr></table></figure><p>在上面的例子中，以<code>","</code>为分隔符分割 <code>1.txt</code> 文件的每一行，当 <code>awk</code> 搜索到 <code>1.txt</code> 文件中有匹配正则表达式 <code>"/nihao/"</code> 的文本时，就输出打印 <code>“foo”</code> 。</p></li></ul><p><code>awk</code> 非常擅长于处理列数据。</p></li><li><p>首先， <code>{print $2}</code> 的作用是什么？ <strong><code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。</strong>默认当模式串即匹配所有行（上面命令中当用法）。 <strong>在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）</strong>。在上面的例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p><p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1</span><br><span class="line"> | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l</span><br></pre></td></tr></table></figure><p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式 <code>/^c[^ ]*e$/</code> 。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p></li><li><p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep "Disconnected from"</span><br><span class="line"> | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1</span><br><span class="line"> | awk 'BEGIN { rows = 0 } $1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 } END { print rows }'</span><br></pre></td></tr></table></figure><p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。</p></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2022/11/21/Lecture4-data-wrangling/" title="Lecture4-data wrangling">https://running-noob.github.io/2022/11/21/Lecture4-data-wrangling/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/11/18/Lecture3-vim/" rel="prev" title="Lecture3-vim"><i class="fa fa-chevron-left"></i> Lecture3-vim</a></div><div class="post-nav-item"><a href="/2022/11/22/Lecture5-command-line/" rel="next" title="Lecture5-command-line">Lecture5-command-line <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-4-Data-Wrangling"><span class="nav-text">Lecture 4 Data Wrangling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86"><span class="nav-text">日志处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#less%E3%80%81%E2%98%85sed%E3%80%81%E2%98%85grep"><span class="nav-text">less、★sed、★grep</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">★正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86"><span class="nav-text">回到数据整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sort%E3%80%81uniq%E3%80%81paste%E3%80%81wc"><span class="nav-text">sort、uniq、paste、wc</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85awk-%E2%80%93-%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BC%96%E8%BE%91%E5%99%A8"><span class="nav-text">★awk – 另外一种编辑器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%98%85awk"><span class="nav-text">★awk</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">242</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">469k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:24</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>
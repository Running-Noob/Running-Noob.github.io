<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Code, Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"running-noob.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_body:"slideDownIn",sidebar:"slideDownIn"}},path:"search.xml"}</script><meta name="description" content="版本控制系统 (VCSs，Version Control System) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。"><meta property="og:type" content="article"><meta property="og:title" content="Lecture6-version control - git"><meta property="og:url" content="https://running-noob.github.io/2022/11/25/Lecture6-version-control-git/index.html"><meta property="og:site_name" content="Running Noob"><meta property="og:description" content="版本控制系统 (VCSs，Version Control System) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-11-25T12:45:59.000Z"><meta property="article:modified_time" content="2023-12-14T12:55:03.329Z"><meta property="article:author" content="Fzy"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://running-noob.github.io/2022/11/25/Lecture6-version-control-git/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Lecture6-version control - git | Running Noob</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Running Noob</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Do Something Meaningful</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-book fa-fw"></i>文章<span class="badge">238</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Running-Noob" class="github-corner" title="访问我的GitHub" aria-label="访问我的GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://running-noob.github.io/2022/11/25/Lecture6-version-control-git/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Fzy"><meta itemprop="description" content="华东理工大学 - 计算机硕士在读<br>研究方向：云计算"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Running Noob"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Lecture6-version control - git</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-25 20:45:59" itemprop="dateCreated datePublished" datetime="2022-11-25T20:45:59+08:00">2022-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-14 20:55:03" itemprop="dateModified" datetime="2023-12-14T20:55:03+08:00">2023-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/The-Missing-Semester-of-Your-CS-Education/" itemprop="url" rel="index"><span itemprop="name">The Missing Semester of Your CS Education</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><ul><li>版本控制系统 (VCSs，Version Control System) 是一类用于<strong>追踪源代码（或其他文件、文件夹）改动</strong>的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</li></ul></blockquote><span id="more"></span><h2 id="★Lecture-6-Version-Control（git）"><a href="#★Lecture-6-Version-Control（git）" class="headerlink" title="★Lecture 6 Version Control（git）"></a>★Lecture 6 Version Control（git）</h2><p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a> ：Git 详细的学习资料</p><ul><li><p>版本控制系统 (VCSs，Version Control System) 是一类用于<strong>追踪源代码（或其他文件、文件夹）改动</strong>的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p><p>Git 把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，<strong>如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件</strong>。 Git 对待数据更像是一个 <strong>快照流</strong>。</p></li><li><p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p><ul><li>当前模块是谁编写的？</li><li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>最近的1000个版本中，何时/为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多， 其事实上的标准则是 <strong>Git</strong> 。</p></li><li><p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p><p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种<strong>自底向上</strong>的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p></li></ul><h3 id="★Git-的数据模型"><a href="#★Git-的数据模型" class="headerlink" title="★Git 的数据模型"></a>★Git 的数据模型</h3><ul><li>进行版本控制的方法很多。<code>Git</code> 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</li></ul><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><ul><li><p><code>Git</code> 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在 <code>Git</code> 的术语里，<strong>文件（file）被称作 Blob 对象（数据对象），也就是一组数据。目录（folder）则被称之为“树”（tree），它将名字与 Blob 对象或树对象（使得目录中可以包含其他目录）进行映射。快照则是被追踪的最顶层的树</strong>。例如，一个树看起来可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = "hello world")</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = "git is wonderful")</span><br></pre></td></tr></table></figure><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p></li></ul><h4 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h4><ul><li><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，<code>Git</code> 并没有采用这样的模型。</p><p><strong>在 <code>Git</code> 中，历史记录是一个由快照组成的有向无环图</strong>。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 <code>Git</code> 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p><p>在 <code>Git</code> 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p>上面是一个 ASCII 码构成的简图，其中的 <strong><code>o</code> 表示一次提交（快照）</strong>。</p><p><strong>箭头指向了当前提交的父辈</strong>（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p><code>Git</code> 中的提交是不可改变的。但这并不代表错误不能被修改，只不过<strong>这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</strong></p></li></ul><h4 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h4><ul><li><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;	//string 代表了文件夹名或文件名</span><br><span class="line"></span><br><span class="line">// 每个提交都包含父辈，元数据和顶层树</span><br><span class="line">type commit = struct {</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree		//最顶层的树 -&gt; root</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h4><h5 id="git-cat-file-p-SHA-1"><a href="#git-cat-file-p-SHA-1" class="headerlink" title="git cat-file -p SHA-1"></a>git cat-file -p SHA-1</h5><ul><li><p><code>Git</code> 中的对象可以是 <strong>blob</strong>、<strong>树</strong>或<strong>提交</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure><p><code>Git</code> 在储存数据时，所有的对象都会基于它们的 SHA-1（Secure Hash Algorithm - 1） 哈希进行寻址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure></li><li><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p><strong>提交（<code>commit</code>）、树（<code>tree</code>）和文件（<code>blob</code>）的关系为：</strong></p><ol><li><p><strong>我们先通过 <code>commit</code> 寻找到 <code>tree</code> 的信息，每个 <code>commit</code> 都会存储对应的 <code>tree ID</code>；</strong></p><p>![](../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/git commit.png)</p></li><li><p><strong>通过 <code>tree</code> 存储的信息，获取到对应的目录树信息；</strong></p><p>![](../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/git tree.png)</p></li><li><p><strong>根据从 <code>tree</code> 中获得的 <code>blob</code> 的 <code>ID</code>，通过 <code>blob ID</code> 获取对应的文件内容。</strong></p><p>![](../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/git blob.png)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = "hello world")</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = "git is wonderful")</span><br></pre></td></tr></table></figure><p>例如，上面例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化（<code>-p</code> ： print），<code>698281bc680d1995c5f4caaf3359721a5a58d48d</code> 是 <code>&lt;root&gt; (tree)</code> 的 sha1 值），看上去是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure><p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code> (树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 <code>baz.txt</code> 的内容，会得到以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h5 id="master、HEAD"><a href="#master、HEAD" class="headerlink" title="master、HEAD"></a>master、HEAD</h5><ul><li><p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p><p>针对这一问题，<code>Git</code> 的解决方法是给这些哈希值赋予人类可读的名字，也就是<strong>引用（references）。引用是指向提交的指针</strong>。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，**<code>master</code> 引用通常会指向主分支的最新一次提交**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></table></figure><p>这样，<code>Git</code> 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要再使用一长串十六进制字符了。</p></li><li><p>有一个细节需要我们注意， 通常情况下，我们会想要知道“<strong>我们当前所在位置</strong>”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 <code>Git</code> 中，我们当前的位置有一个特殊的索引，它就是 “<strong>HEAD</strong>”。</p></li></ul><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><ul><li><p>最后，我们可以粗略地给出 <code>Git</code> 仓库的定义了：**<code>对象</code> 和 <code>引用</code>**。</p><p><strong>在硬盘上，<code>Git</code> 仅存储对象和引用</strong>：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象（不存在说删除对象或修改对象），增加或删除引用。</p><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。</p><p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p></li></ul><h3 id="★暂存区"><a href="#★暂存区" class="headerlink" title="★暂存区"></a>★暂存区</h3><ul><li><p><code>Git</code> 中还包括一个和数据模型完全不相关的概念，但它却是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 <code>Git</code> 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p><p><code>Git</code> 处理这些场景的方法是使用一种叫做 “<strong>暂存区（staging area）</strong>”的机制，它<strong>允许您指定下次快照中要包括哪些改动</strong>。</p></li><li><p>Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li><strong>已修改</strong>表示修改了文件，但还没保存到数据库中。</li><li><strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，<strong>使之包含在下次提交的快照中</strong>。</li><li><strong>已提交</strong>表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git 项目拥有三个阶段：<strong>工作区</strong>、<strong>暂存区</strong>以及 <strong>Git 目录</strong>。</p><p>![](../../../../../Running Noob/计算机/Typora笔记/笔记-git仓库/The-Missing-Semester-of-Your-CS-Education/img/git三种状态.png)</p><ul><li><strong>工作区</strong>是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li><li><strong>暂存区</strong>是一个文件，<strong>保存了下次将要提交的文件列表信息</strong>，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li><li><strong>Git 仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li></ul></li><li><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol></li></ul><h3 id="★Git-的命令行接口"><a href="#★Git-的命令行接口" class="headerlink" title="★Git 的命令行接口"></a>★Git 的命令行接口</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="git-init、git-status、git-add、git-rm、git-commit、git-log、git-diff、git-checkout、git-mv"><a href="#git-init、git-status、git-add、git-rm、git-commit、git-log、git-diff、git-checkout、git-mv" class="headerlink" title="git init、git status、git add、git rm、git commit、git log、git diff、git checkout、git mv"></a>git init、git status、git add、git rm、git commit、git log、git diff、git checkout、git mv</h5><ul><li><p><code>git help &lt;command&gt;</code>: 获取 <code>git</code> 命令的帮助信息，如 <code>git help init</code></p></li><li><p><code>git init</code>: 创建一个新的 <code>git</code> 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</p></li><li><p><strong><code>git status</code>: 显示当前的仓库状态</strong></p></li><li><p><strong><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</strong></p><ul><li><p><code>git add</code> 命令使用文件或目录的路径作为参数；<strong>如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件</strong>。</p></li><li><p><code>git add</code> 是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为 “精确地将内容添加到下一次提交中” 而不是 “将一个文件添加到项目中” 要更加合适。</p></li></ul></li><li><p><strong><code>git rm &lt;filename&gt;</code>：从 Git 中移除某个文件，并连带从工作目录中删除指定的文件</strong>，下一次提交时，该文件就不再纳入版本管理了。</p><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。</p><ul><li><code>-f</code> ：如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</li><li><strong><code>-cached</code>：另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。</strong></li></ul></li><li><p><strong><code>git commit</code>：创建一个新的提交，并启动你选择的文本编辑器来输入提交说明。</strong></p><ul><li><code>git commit -m "message"</code>：将提交信息与命令放在同一行，而不必打开文本编辑器来输入说明提交</li><li><code>git commit -a</code> ：Git 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</li><li>如何编写 <a target="_blank" rel="noopener" href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>为何要 <a target="_blank" rel="noopener" href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li><p><strong><code>git log</code>: 显示历史日志</strong></p><ul><li><code>git log -p</code>：显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出（p -&gt; patch））。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：<code>git log -p -2</code></li><li><code>git log --all --graph --decorate</code>： 可视化历史记录（有向无环图）</li><li><code>git log --all --graph --decorate --oneline</code>： 以简洁的方式可视化历史记录（有向无环图）</li></ul></li><li><p><strong><code>git diff &lt;filename&gt;</code>: 显示当前文件与暂存区文件的差异，也就是修改之后还没有暂存起来的变化内容。</strong></p><p>注意：**<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动**。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><ul><li><p><code>git diff --staged</code> ：这条命令将比对已暂存文件与最后一次提交的文件差异。（<code>git diff --staged</code> == <code>git diff --cached</code>）</p></li><li><p><code>git diff &lt;v1&gt; &lt;v2&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异（v2 相对于 v1 来说，有哪些差异）</p></li></ul></li><li><p><strong><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git log --all --graph --decorate</span><br><span class="line">* commit 5704a02ff48a8c6ad19f6d753c4868dae2f7ab13 (HEAD -&gt; master)</span><br><span class="line">| Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">| Date:   Wed Feb 22 20:17:20 2023 +0800</span><br><span class="line">| </span><br><span class="line">|     add new directory "new dir"</span><br><span class="line">| </span><br><span class="line">* commit 831daf5a811b23398317fa2de9a079abe6f1bc2a</span><br><span class="line">  Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">  Date:   Wed Feb 22 20:06:21 2023 +0800</span><br><span class="line">  </span><br><span class="line">      this is my hello.txt file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子中，有两次 <code>commit</code>，对应于 <code>Git的数据模型</code> 中的 <code>commit</code> 对象，此时，<code>HEAD</code> 和 <code>master</code> 都指向最新的 <code>commit</code> 。</p><p><strong>注意：最新的一次 <code>commit</code> 在最上面</strong>。</p><p>但是如果执行下面的命令，然后再次 <code>git log --all --graph --decorate</code>，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git checkout 831daf5a811b23398317fa2de9a079abe6f1bc2a</span><br><span class="line">注意：正在切换到 '831daf5a811b23398317fa2de9a079abe6f1bc2a'。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 831daf5 this is my hello.txt file</span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git log --all --graph --decorate</span><br><span class="line">* commit 5704a02ff48a8c6ad19f6d753c4868dae2f7ab13 (master)</span><br><span class="line">| Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">| Date:   Wed Feb 22 20:17:20 2023 +0800</span><br><span class="line">| </span><br><span class="line">|     add new directory "new dir"</span><br><span class="line">| </span><br><span class="line">* commit 831daf5a811b23398317fa2de9a079abe6f1bc2a (HEAD)</span><br><span class="line">  Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">  Date:   Wed Feb 22 20:06:21 2023 +0800</span><br><span class="line">  </span><br><span class="line">      this is my hello.txt file</span><br></pre></td></tr></table></figure><p>发现由于使用 <code>git checkout 831daf5a811b23398317fa2de9a079abe6f1bc2a</code> ，使得当前位置 “HEAD” 指向了第一次 <code>commit</code> 的地方，<strong>此时进行的操作就都是基于第一次 <code>commit</code> 时的状态了</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ ls</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure><p>此时没有了 “<code>new dir</code>“ 文件夹，当再次回到最新的 <code>commit</code> 时，”<code>new dir</code>“ 文件夹又出现了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git checkout 5704a02ff48a8c6a</span><br><span class="line">之前的 HEAD 位置是 831daf5 this is my hello.txt file</span><br><span class="line">HEAD 目前位于 5704a02 add new directory "new dir"</span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ ls</span><br><span class="line"> hello.txt  'new dir'</span><br></pre></td></tr></table></figure></li><li><p><code>git mv file_from file_to</code>：Git 并不显式跟踪文件移动操作，但会推断出究竟发生了什么，如文件重命名或移动文件。</p><p>看下面例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with 'origin/master'.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于，<code>git mv</code> 是一条命令而非三条命令，直接使用 <code>git mv</code> 方便得多。 不过<strong>在使用其他工具重命名文件时，记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</strong></p></li></ul><h4 id="分支和合并"><a href="#分支和合并" class="headerlink" title="分支和合并"></a>分支和合并</h4><h5 id="git-branch、git-checkout-b、git-merge"><a href="#git-branch、git-checkout-b、git-merge" class="headerlink" title="git branch、git checkout -b、git merge"></a>git branch、git checkout -b、git merge</h5><ul><li><p><code>git branch</code>: 显示分支</p></li><li><p><code>git branch &lt;name&gt;</code>: 创建分支</p></li><li><p><strong><code>git checkout -b &lt;name&gt;</code>：创建分支并切换到该分支</strong></p><ul><li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li><p><strong><code>git merge &lt;revision&gt;</code>: 合并到当前分支</strong></p><ul><li><strong><code>git merge --abort</code>：会抛弃合并过程并且尝试重建合并前的状态</strong></li><li><code>git merge --continue</code>：该命令在首先验证是否有合并要完成后，只运行<code>git commit</code>。</li></ul></li><li><p><code>git mergetool</code>: 使用工具来处理合并冲突</p></li><li><p><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</p></li><li><p>为了方便演示 <code>git</code> 的分支和合并命令，我们用 <code>.py</code> 程序而不是 <code>.txt</code> 文件来进行演示过程：</p><ul><li><p>分支过程：</p><p>首先创建 <code>hello.py</code> 文件，其内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">	default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后 <code>git checkout -b cat</code> 创建 ”cat“ 分支并进入这个分支，对 <code>hello.py</code> 文件进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"cat!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'cat'</span>:</span><br><span class="line">        cat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后提交，再 <code>git log --all --graph --decorate</code> ，显示目前 <code>git</code> 结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* commit da87499922490632ccb62bf64b138722c4908ec5 (HEAD -&gt; cat)</span><br><span class="line">| Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">| Date:   Thu Feb 23 14:33:23 2023 +0800</span><br><span class="line">| </span><br><span class="line">|     add branch cat</span><br><span class="line">| </span><br><span class="line">* commit 9b3194f792b0bad3f837209842fdcf2bdb6d0494 (master)</span><br><span class="line">| Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">| Date:   Thu Feb 23 14:25:43 2023 +0800</span><br><span class="line">| </span><br><span class="line">|     add hello.py</span><br><span class="line">| </span><br><span class="line">* commit c006e500746f9956b1e47a60d95867d0ee03d9aa</span><br><span class="line">| Author: Running-Noob &lt;fang_zhuoyue@163.com&gt;</span><br><span class="line">| Date:   Wed Feb 22 21:43:41 2023 +0800</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>回到 <code>master</code> 分支： <code>git checkout master</code> ，并创建新的分支 ”dog“ 并进入：<code>git checkout -b dog</code> ，同样对 <code>hello.py</code> 文件进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dog</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"dog!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span>(sys.argv[<span class="number">1</span>] == <span class="string">'dog'</span>):</span><br><span class="line">        dog()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后提交，再 <code>git log --all --graph --decorate --oneline</code> ，显示目前 <code>git</code> 结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* aa43e4b (HEAD -&gt; dog) add dog func</span><br><span class="line">| * da87499 (cat) add branch cat</span><br><span class="line">|/  </span><br><span class="line">* 9b3194f (master) add hello.py</span><br><span class="line">* c006e50 add new thing to hello.txt</span><br><span class="line">* 5704a02 add new directory "new dir"</span><br><span class="line">* 831daf5 this is my hello.txt file</span><br></pre></td></tr></table></figure><p>现在我们有两个分支：”cat“ 和 ”dog“，”cat“ 分支实现了 <code>cat</code> 函数，”dog“ 分支实现了 <code>dog</code> 函数，接下来我们要把这两个分支中的函数合并起来。</p></li><li><p>合并过程：</p><p>首先回到 <code>master</code> ：<code>git checkout master</code>，<code>git</code> 结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* aa43e4b (dog) add dog func</span><br><span class="line">| * da87499 (cat) add branch cat</span><br><span class="line">|/  </span><br><span class="line">* 9b3194f (HEAD -&gt; master) add hello.py</span><br><span class="line">* c006e50 add new thing to hello.txt</span><br><span class="line">* 5704a02 add new directory "new dir"</span><br><span class="line">* 831daf5 this is my hello.txt file</span><br></pre></td></tr></table></figure><p>我们先将 “cat” 分支合并：<code>git merge cat</code>，然后 <code>git</code> 此时结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git merge cat </span><br><span class="line">更新 9b3194f..da87499</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.py | 8 +++++++-</span><br><span class="line"> 1 file changed, 7 insertions(+), 1 deletion(-)</span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git log --all --graph --decorate --oneline</span><br><span class="line">* aa43e4b (dog) add dog func</span><br><span class="line">| * da87499 (HEAD -&gt; master, cat) add branch cat</span><br><span class="line">|/  </span><br><span class="line">* 9b3194f add hello.py</span><br><span class="line">* c006e50 add new thing to hello.txt</span><br><span class="line">* 5704a02 add new directory "new dir"</span><br><span class="line">* 831daf5 this is my hello.txt file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再将 ”dog“ 分支合并：<code>git merge dog</code>，会发现出现合并冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git merge dog</span><br><span class="line">自动合并 hello.py</span><br><span class="line">冲突（内容）：合并冲突于 hello.py</span><br><span class="line">自动合并失败，修正冲突然后提交修正的结果。</span><br></pre></td></tr></table></figure><p>浏览此时的 <code>hello.py</code> 文件，发现文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"cat!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'cat'</span>:</span><br><span class="line">        cat()</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dog</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"dog!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span>(sys.argv[<span class="number">1</span>] == <span class="string">'dog'</span>):</span><br><span class="line">        dog()</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dog</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>”=======“ 上面的部分表示 ”HEAD“ 分支中 <code>hello.py</code> 的内容，下面的部分表示 ”dog“ 分支中 <code>hello.py</code> 的内容，正是这里起了合并冲突。</p><ul><li><p>针对合并冲突，我们可以选择放弃此次合并：<code>git merge --abort</code>，回到合并前的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git merge --abort</span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git log --all --graph --decorate --oneline</span><br><span class="line">* aa43e4b (dog) add dog func</span><br><span class="line">| * da87499 (HEAD -&gt; master, cat) add branch cat</span><br><span class="line">|/  </span><br><span class="line">* 9b3194f add hello.py</span><br><span class="line">* c006e50 add new thing to hello.txt</span><br><span class="line">* 5704a02 add new directory "new dir"</span><br><span class="line">* 831daf5 this is my hello.txt file</span><br></pre></td></tr></table></figure></li><li><p>也可以对冲突的内容进行人工修改，然后完成合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ vim hello.py </span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git add hello.py </span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git merge --continue</span><br><span class="line">[master 0536c80] Merge branch 'dog'</span><br><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/git_$ git log --all --graph --decorate --oneline</span><br><span class="line">*   0536c80 (HEAD -&gt; master) Merge branch 'dog'</span><br><span class="line">|\  </span><br><span class="line">| * aa43e4b (dog) add dog func</span><br><span class="line">* | da87499 (cat) add branch cat</span><br><span class="line">|/  </span><br><span class="line">* 9b3194f add hello.py</span><br><span class="line">* c006e50 add new thing to hello.txt</span><br><span class="line">* 5704a02 add new directory "new dir"</span><br><span class="line">* 831daf5 this is my hello.txt file</span><br></pre></td></tr></table></figure><p>人工修改的 <code>hello.py</code> 的内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"cat!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dog</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"dog!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'cat'</span>:</span><br><span class="line">        cat()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">'dog'</span>:</span><br><span class="line">        dog()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        default()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h4><ul><li>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</li></ul><h5 id="git-remote、git-push、git-fetch、git-pull、git-remote-rename、git-remote-remove、git-clone"><a href="#git-remote、git-push、git-fetch、git-pull、git-remote-rename、git-remote-remove、git-clone" class="headerlink" title="git remote、git push、git fetch、git pull、git remote rename、git remote remove、git clone"></a>git remote、git push、git fetch、git pull、git remote rename、git remote remove、git clone</h5><ul><li><p><code>git remote</code>: 列出远端，查看你已经配置的远程仓库服务器</p><ul><li><p><code>git remote -v</code> ：你也可以指定选项 <code>-v</code>，该命令会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running_noob@RNoob-VM:~/桌面/the missing semester/test$ git remote -v</span><br><span class="line">origin	https://github.com/Running-Noob/test.git (fetch)</span><br><span class="line">origin	https://github.com/Running-Noob/test.git (push)</span><br></pre></td></tr></table></figure></li><li><p><code>git remote add &lt;shortName&gt; &lt;url&gt;</code>：添加一个新的远程 Git 仓库，同时指定一个方便使用的简写，由此就可以在命令行中使用简写来代替整个 URL。</p></li><li><p><code>git remote show &lt;remote&gt;</code>：查看某一个远程仓库的更多信息，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1@Running-Noob MINGW64 ~/Desktop/test (main)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/Running-Noob/test.git/</span><br><span class="line">  Push  URL: https://github.com/Running-Noob/test.git/</span><br><span class="line">  HEAD branch: main</span><br><span class="line">  Remote branch:</span><br><span class="line">    main tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    main merges with remote main</span><br><span class="line">  Local ref configured for 'git push':</span><br><span class="line">    main pushes to main (up to date)</span><br></pre></td></tr></table></figure><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>main</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>main</code> 分支合并到本地 <code>main</code> 分支。 它也会列出拉取到的所有远程引用。</p></li></ul></li><li><p><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端（例如 <code>GitHub</code>）并更新远端引用</p></li><li><p><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</p></li><li><p><code>git fetch</code>: 从远端获取对象/索引，若要从远程仓库中获得数据，可以执行该命令</p><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <strong><code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作</strong>。 当准备好时你必须手动将其合并入你的工作。</p></li><li><p><code>git pull</code>: 相当于 <code>git fetch; git merge</code></p><p>该命令可以自动抓取该远程分支并合并到当前分支，默认情况下，<code>git clone</code> 命令会自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><p><code>git pull &lt;远程仓库&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p></li><li><p><code>git remote rename &lt;oldRemoteName&gt; &lt;newRemoteName&gt;</code>：用来修改一个远程仓库的简写名。</p></li><li><p><code>git remote remove &lt;remote&gt;</code>：用来移除一个远程仓库，一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p></li><li><p><code>git clone</code>: 从远端下载仓库</p></li></ul><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><h5 id="git-commit-–amend、git-checkout-、git-restore"><a href="#git-commit-–amend、git-checkout-、git-restore" class="headerlink" title="git commit –amend、git checkout <file>、git restore"></a>git commit –amend、git checkout &lt;file&gt;、git restore</h5><ul><li><p><code>git commit --amend</code>: 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来<strong>重新提交</strong>，这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。</p><p><strong>最终你只会有一个提交——第二次提交将代替第一次提交的结果</strong>。</p></li><li><p><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</p></li><li><p><strong><code>git checkout &lt;file&gt;</code>: 丢弃修改（在未将文件 <code>git add</code> 到暂存区中时有效）</strong></p></li><li><p><strong><code>git restore &lt;filename&gt;</code>: git2.32 版本后取代 <code>git reset</code> 进行许多撤销操作</strong></p><ul><li><strong><code>git restore --staged &lt;filename&gt;</code>：在对文件使用 <code>git add</code> 后（将文件保存到暂存区后），可以使用这个命令以取消暂存。</strong></li><li><code>git restore &lt;filename&gt;</code>：在文件还未保存到暂存区时，将文件撤销到当前版本库版本；在文件保存到暂存区后，将文件撤销到到暂存区版本。</li></ul></li></ul><h3 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h3><h4 id="git-config、git-add-p、git-blame、git-show、git-stash、-gitignore、pull-request、git-rebase"><a href="#git-config、git-add-p、git-blame、git-show、git-stash、-gitignore、pull-request、git-rebase" class="headerlink" title="git config、git add -p、git blame、git show、git stash、.gitignore、pull request、git rebase"></a>git config、git add -p、git blame、git show、git stash、.gitignore、pull request、git rebase</h4><ul><li><p><strong><code>git config</code>: <code>Git</code> 是一个 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</strong></p></li><li><p><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</p></li><li><p><strong><code>git add -p</code>: 交互式暂存</strong></p></li><li><p><code>git rebase -i</code>: 交互式变基</p></li><li><p><code>git blame</code> 配合 <code>git show</code> 使用：</p><ul><li>**<code>git blame &lt;filename&gt;</code>: ** ，用来追溯一个指定文件的历史修改记录。它能显示任何文件中每行最后一次修改的提交记录。可以用来查看最后修改文件中某行（配合着 grep 使用）的人</li><li><strong><code>git show &lt;commit-sha1id&gt;</code>：查看某次 <code>commit</code> 的内容</strong></li></ul><p>例如：最后一次修改 <code>_config.yml</code> 文件中 <code>collections:</code> 行时的提交信息是什么？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先用 git blame 得到修改 _config.yml 文件的信息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再用 grep 搜索到修改 collections: 的提交的 sha-1 <span class="built_in">id</span></span></span><br><span class="line">1@Running-Noob MINGW64 ~/Desktop/missing-semester (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git blame _config.yml | grep collection</span></span><br><span class="line">a88b4eac (Anish Athalye 2020-01-17 15:26:30 -0500 18) collections:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到提交的 sha-1 <span class="built_in">id</span> 为 a88b4eac，再用 git show 查看具体提交内容</span></span><br><span class="line">1@Running-Noob MINGW64 ~/Desktop/missing-semester (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show a88b4eac</span></span><br><span class="line">commit a88b4eac326483e29bdac5ee0a39b180948ae7fc</span><br><span class="line">Author: Anish Athalye &lt;me@anishathalye.com&gt;</span><br><span class="line">Date:   Fri Jan 17 15:26:30 2020 -0500</span><br><span class="line"></span><br><span class="line">    Redo lectures as a collection</span><br><span class="line"></span><br><span class="line">diff --git a/2020/index.html b/2020/index.html</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 153ddc8..0000000</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li><li><p><strong><code>git stash</code>: 暂时移除工作目录下的修改内容</strong></p><ul><li><strong><code>git stash pop</code>：恢复暂时移除工作目录下的修改内容</strong></li></ul></li><li><p><code>git bisect</code>: 通过二分查找搜索历史记录</p></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:16px">---------------The End---------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Fzy</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://running-noob.github.io/2022/11/25/Lecture6-version-control-git/" title="Lecture6-version control - git">https://running-noob.github.io/2022/11/25/Lecture6-version-control-git/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/11/22/Lecture5-command-line/" rel="prev" title="Lecture5-command-line"><i class="fa fa-chevron-left"></i> Lecture5-command-line</a></div><div class="post-nav-item"><a href="/2022/11/29/Lecture8-metaprogramming/" rel="next" title="Lecture8-metaprogramming">Lecture8-metaprogramming <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">个人信息</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%98%85Lecture-6-Version-Control%EF%BC%88git%EF%BC%89"><span class="nav-text">★Lecture 6 Version Control（git）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85Git-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-text">★Git 的数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7"><span class="nav-text">快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%85%B3%E8%81%94%E5%BF%AB%E7%85%A7"><span class="nav-text">历史记录建模：关联快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-text">数据模型及其伪代码表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="nav-text">对象和内存寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git-cat-file-p-SHA-1"><span class="nav-text">git cat-file -p SHA-1</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#master%E3%80%81HEAD"><span class="nav-text">master、HEAD</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%93%E5%BA%93"><span class="nav-text">仓库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="nav-text">★暂存区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%98%85Git-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3"><span class="nav-text">★Git 的命令行接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git-init%E3%80%81git-status%E3%80%81git-add%E3%80%81git-rm%E3%80%81git-commit%E3%80%81git-log%E3%80%81git-diff%E3%80%81git-checkout%E3%80%81git-mv"><span class="nav-text">git init、git status、git add、git rm、git commit、git log、git diff、git checkout、git mv</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6"><span class="nav-text">分支和合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git-branch%E3%80%81git-checkout-b%E3%80%81git-merge"><span class="nav-text">git branch、git checkout -b、git merge</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="nav-text">远端操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git-remote%E3%80%81git-push%E3%80%81git-fetch%E3%80%81git-pull%E3%80%81git-remote-rename%E3%80%81git-remote-remove%E3%80%81git-clone"><span class="nav-text">git remote、git push、git fetch、git pull、git remote rename、git remote remove、git clone</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E9%94%80"><span class="nav-text">撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git-commit-%E2%80%93amend%E3%80%81git-checkout-%E3%80%81git-restore"><span class="nav-text">git commit –amend、git checkout &lt;file&gt;、git restore</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-text">Git 高级操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#git-config%E3%80%81git-add-p%E3%80%81git-blame%E3%80%81git-show%E3%80%81git-stash%E3%80%81-gitignore%E3%80%81pull-request%E3%80%81git-rebase"><span class="nav-text">git config、git add -p、git blame、git show、git stash、.gitignore、pull request、git rebase</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Fzy" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Fzy</p><div class="site-description" itemprop="description">华东理工大学 - 计算机硕士在读<br>研究方向：云计算</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">238</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Running-Noob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Running-Noob" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/840506988304424" title="Juejin → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;840506988304424" rel="noopener" target="_blank"><i class="fa custom juejin fa-fw"></i>Juejin</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Fzy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">463k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">28:05</span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("08/13/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by">Powered by Hexo & NexT</div></div></footer></div><script color="108,108,108" opacity="0.5" zindex="-1" count="0" src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script></body></html>